[
  {
    "page_content": "Skip to content\nVue.js\nSearch\nMain Navigation\nDocs\nGuide\nTutorial\nExamples\nQuick Start\nGlossary\nError Reference\nVue 2 Docs\nMigration from Vue 2\nAPI\nPlayground\nEcosystem\nResources\nPartners\nThemes\nUI Components\nCertification\nJobs\nT-Shirt Shop\nOfficial Libraries\nVue Router\nPinia\nTooling Guide\nVideo Courses\nVue Mastery\nVue School\nHelp\nDiscord Chat\nGitHub Discussions\nDEV Community\nNews\nBlog\nTwitter\nEvents\nNewsletters\nAbout\nFAQ\nTeam\nReleases\nCommunity Guide\nCode of Conduct\nPrivacy Policy\nThe Documentary\nSponsor\nPartners\n简体中文\n日本語\nУкраїнська\nFrançais\n한국어\nPortuguês\nবাংলা\nItaliano\nفارسی\nРусский\nČeština\n繁體中文\nHelp Us Translate!\ngithub\ntwitter\ndiscord\nAppearance\ngithub\ntwitter\ndiscord\nTutorial has loaded",
    "metadata": {
      "source": "https://vuejs.org/tutorial/",
      "title": "Tutorial | Vue.js"
    }
  },
  {
    "page_content": "SFC Syntax Specification\nOverview\nA Vue Single-File Component (SFC), conventionally using the *.vue\nfile extension, is a custom file format that uses an HTML-like syntax to describe a Vue component. A Vue SFC is syntactically compatible with HTML.\nEach *.vue\nfile consists of three types of top-level language blocks: <template>\n, <script>\n, and <style>\n, and optionally additional custom blocks:\nvue\n<template>\n<div class=\"example\">{{ msg }}</div>\n</template>\n<script>\nexport default {\ndata() {\nreturn {\nmsg: 'Hello world!'\n}\n}\n}\n</script>\n<style>\n.example {\ncolor: red;\n}\n</style>\n<custom1>\nThis could be e.g. documentation for the component.\n</custom1>\nLanguage Blocks\n<template>\nEach\n*.vue\nfile can contain at most one top-level<template>\nblock.Contents will be extracted and passed on to\n@vue/compiler-dom\n, pre-compiled into JavaScript render functions, and attached to the exported component as itsrender\noption.\n<script>\nEach\n*.vue\nfile can contain at most one<script>\nblock (excluding<script setup>\n).The script is executed as an ES Module.\nThe default export should be a Vue component options object, either as a plain object or as the return value of defineComponent.\n<script setup>\nEach\n*.vue\nfile can contain at most one<script setup>\nblock (excluding normal<script>\n).The script is pre-processed and used as the component's\nsetup()\nfunction, which means it will be executed for each instance of the component. Top-level bindings in<script setup>\nare automatically exposed to the template. For more details, see dedicated documentation on<script setup>\n.\n<style>\nA single\n*.vue\nfile can contain multiple<style>\ntags.A\n<style>\ntag can havescoped\normodule\nattributes (see SFC Style Features for more details) to help encapsulate the styles to the current component. Multiple<style>\ntags with different encapsulation modes can be mixed in the same component.\nCustom Blocks\nAdditional custom blocks can be included in a *.vue\nfile for any project-specific needs, for example a <docs>\nblock. Some real-world examples of custom blocks include:\nHandling of Custom Blocks will depend on tooling - if you want to build your own custom block integrations, see the SFC custom block integrations tooling section for more details.\nAutomatic Name Inference\nAn SFC automatically infers the component's name from its filename in the following cases:\n- Dev warning formatting\n- DevTools inspection\n- Recursive self-reference, e.g. a file named\nFooBar.vue\ncan refer to itself as<FooBar/>\nin its template. This has lower priority than explicitly registered/imported components.\nPre-Processors\nBlocks can declare pre-processor languages using the lang\nattribute. The most common case is using TypeScript for the <script>\nblock:\ntemplate\n<script lang=\"ts\">\n// use TypeScript\n</script>\nlang\ncan be applied to any block - for example we can use <style>\nwith Sass and <template>\nwith Pug:\ntemplate\n<template lang=\"pug\">\np {{ msg }}\n</template>\n<style lang=\"scss\">\n$primary-color: #333;\nbody {\ncolor: $primary-color;\n}\n</style>\nNote that integration with various pre-processors may differ by toolchain. Check out the respective documentation for examples:\nsrc\nImports\nIf you prefer splitting up your *.vue\ncomponents into multiple files, you can use the src\nattribute to import an external file for a language block:\nvue\n<template src=\"./template.html\"></template>\n<style src=\"./style.css\"></style>\n<script src=\"./script.js\"></script>\nBeware that src\nimports follow the same path resolution rules as webpack module requests, which means:\n- Relative paths need to start with\n./\n- You can import resources from npm dependencies:\nvue\n<!-- import a file from the installed \"todomvc-app-css\" npm package -->\n<style src=\"todomvc-app-css/index.css\" />\nsrc\nimports also work with custom blocks, e.g.:\nvue\n<unit-test src=\"./unit-test.js\">\n</unit-test>\nComments\nInside each block you shall use the comment syntax of the language being used (HTML, CSS, JavaScript, Pug, etc.). For top-level comments, use HTML comment syntax: <!-- comment contents here -->",
    "metadata": {
      "source": "https://vuejs.org/api/sfc-spec",
      "title": "SFC Syntax Specification | Vue.js"
    }
  },
  {
    "page_content": "Options: State\ndata\nA function that returns the initial reactive state for the component instance.\nType\ntsinterface ComponentOptions { data?( this: ComponentPublicInstance, vm: ComponentPublicInstance ): object }\nDetails\nThe function is expected to return a plain JavaScript object, which will be made reactive by Vue. After the instance is created, the reactive data object can be accessed as\nthis.$data\n. The component instance also proxies all the properties found on the data object, sothis.a\nwill be equivalent tothis.$data.a\n.All top-level data properties must be included in the returned data object. Adding new properties to\nthis.$data\nis possible, but it is not recommended. If the desired value of a property is not yet available then an empty value such asundefined\nornull\nshould be included as a placeholder to ensure that Vue knows that the property exists.Properties that start with\n_\nor$\nwill not be proxied on the component instance because they may conflict with Vue's internal properties and API methods. You will have to access them asthis.$data._property\n.It is not recommended to return objects with their own stateful behavior like browser API objects and prototype properties. The returned object should ideally be a plain object that only represents the state of the component.\nExample\njsexport default { data() { return { a: 1 } }, created() { console.log(this.a) // 1 console.log(this.$data) // { a: 1 } } }\nNote that if you use an arrow function with the\ndata\nproperty,this\nwon't be the component's instance, but you can still access the instance as the function's first argument:jsdata: (vm) => ({ a: vm.myProp })\nSee also Reactivity in Depth\nprops\nDeclare the props of a component.\nType\ntsinterface ComponentOptions { props?: ArrayPropsOptions | ObjectPropsOptions } type ArrayPropsOptions = string[] type ObjectPropsOptions = { [key: string]: Prop } type Prop<T = any> = PropOptions<T> | PropType<T> | null interface PropOptions<T> { type?: PropType<T> required?: boolean default?: T | ((rawProps: object) => T) validator?: (value: unknown, rawProps: object) => boolean } type PropType<T> = { new (): T } | { new (): T }[]\nTypes are simplified for readability.\nDetails\nIn Vue, all component props need to be explicitly declared. Component props can be declared in two forms:\n- Simple form using an array of strings\n- Full form using an object where each property key is the name of the prop, and the value is the prop's type (a constructor function) or advanced options.\nWith object-based syntax, each prop can further define the following options:\ntype\n: Can be one of the following native constructors:String\n,Number\n,Boolean\n,Array\n,Object\n,Date\n,Function\n,Symbol\n, any custom constructor function or an array of those. In development mode, Vue will check if a prop's value matches the declared type, and will throw a warning if it doesn't. See Prop Validation for more details.Also note that a prop with\nBoolean\ntype affects its value casting behavior in both development and production. See Boolean Casting for more details.default\n: Specifies a default value for the prop when it is not passed by the parent or hasundefined\nvalue. Object or array defaults must be returned using a factory function. The factory function also receives the raw props object as the argument.required\n: Defines if the prop is required. In a non-production environment, a console warning will be thrown if this value is truthy and the prop is not passed.validator\n: Custom validator function that takes the prop value as the sole argument. In development mode, a console warning will be thrown if this function returns a falsy value (i.e. the validation fails).\nExample\nSimple declaration:\njsexport default { props: ['size', 'myMessage'] }\nObject declaration with validations:\njsexport default { props: { // type check height: Number, // type check plus other validations age: { type: Number, default: 0, required: true, validator: (value) => { return value >= 0 } } } }\nSee also\ncomputed\nDeclare computed properties to be exposed on the component instance.\nType\ntsinterface ComponentOptions { computed?: { [key: string]: ComputedGetter<any> | WritableComputedOptions<any> } } type ComputedGetter<T> = ( this: ComponentPublicInstance, vm: ComponentPublicInstance ) => T type ComputedSetter<T> = ( this: ComponentPublicInstance, value: T ) => void type WritableComputedOptions<T> = { get: ComputedGetter<T> set: ComputedSetter<T> }\nDetails\nThe option accepts an object where the key is the name of the computed property, and the value is either a computed getter, or an object with\nget\nandset\nmethods (for writable computed properties).All getters and setters have their\nthis\ncontext automatically bound to the component instance.Note that if you use an arrow function with a computed property,\nthis\nwon't point to the component's instance, but you can still access the instance as the function's first argument:jsexport default { computed: { aDouble: (vm) => vm.a * 2 } }\nExample\njsexport default { data() { return { a: 1 } }, computed: { // readonly aDouble() { return this.a * 2 }, // writable aPlus: { get() { return this.a + 1 }, set(v) { this.a = v - 1 } } }, created() { console.log(this.aDouble) // => 2 console.log(this.aPlus) // => 2 this.aPlus = 3 console.log(this.a) // => 2 console.log(this.aDouble) // => 4 } }\nSee also\nmethods\nDeclare methods to be mixed into the component instance.\nType\ntsinterface ComponentOptions { methods?: { [key: string]: (this: ComponentPublicInstance, ...args: any[]) => any } }\nDetails\nDeclared methods can be directly accessed on the component instance, or used in template expressions. All methods have their\nthis\ncontext automatically bound to the component instance, even when passed around.Avoid using arrow functions when declaring methods, as they will not have access to the component instance via\nthis\n.Example\njsexport default { data() { return { a: 1 } }, methods: { plus() { this.a++ } }, created() { this.plus() console.log(this.a) // => 2 } }\nSee also Event Handling\nwatch\nDeclare watch callbacks to be invoked on data change.\nType\ntsinterface ComponentOptions { watch?: { [key: string]: WatchOptionItem | WatchOptionItem[] } } type WatchOptionItem = string | WatchCallback | ObjectWatchOptionItem type WatchCallback<T> = ( value: T, oldValue: T, onCleanup: (cleanupFn: () => void) => void ) => void type ObjectWatchOptionItem = { handler: WatchCallback | string immediate?: boolean // default: false deep?: boolean // default: false flush?: 'pre' | 'post' | 'sync' // default: 'pre' onTrack?: (event: DebuggerEvent) => void onTrigger?: (event: DebuggerEvent) => void }\nTypes are simplified for readability.\nDetails\nThe\nwatch\noption expects an object where keys are the reactive component instance properties to watch (e.g. properties declared viadata\norcomputed\n) — and values are the corresponding callbacks. The callback receives the new value and the old value of the watched source.In addition to a root-level property, the key can also be a simple dot-delimited path, e.g.\na.b.c\n. Note that this usage does not support complex expressions - only dot-delimited paths are supported. If you need to watch complex data sources, use the imperative$watch()\nAPI instead.The value can also be a string of a method name (declared via\nmethods\n), or an object that contains additional options. When using the object syntax, the callback should be declared under thehandler\nfield. Additional options include:immediate\n: trigger the callback immediately on watcher creation. Old value will beundefined\non the first call.deep\n: force deep traversal of the source if it is an object or an array, so that the callback fires on deep mutations. See Deep Watchers.flush\n: adjust the callback's flush timing. See Callback Flush Timing andwatchEffect()\n.onTrack / onTrigger\n: debug the watcher's dependencies. See Watcher Debugging.\nAvoid using arrow functions when declaring watch callbacks as they will not have access to the component instance via\nthis\n.Example\njsexport default { data() { return { a: 1, b: 2, c: { d: 4 }, e: 5, f: 6 } }, watch: { // watching top-level property a(val, oldVal) { console.log(`new: ${val}, old: ${oldVal}`) }, // string method name b: 'someMethod', // the callback will be called whenever any of the watched object properties change regardless of their nested depth c: { handler(val, oldVal) { console.log('c changed') }, deep: true }, // watching a single nested property: 'c.d': function (val, oldVal) { // do something }, // the callback will be called immediately after the start of the observation e: { handler(val, oldVal) { console.log('e changed') }, immediate: true }, // you can pass array of callbacks, they will be called one-by-one f: [ 'handle1', function handle2(val, oldVal) { console.log('handle2 triggered') }, { handler: function handle3(val, oldVal) { console.log('handle3 triggered') } /* ... */ } ] }, methods: { someMethod() { console.log('b changed') }, handle1() { console.log('handle 1 triggered') } }, created() { this.a = 3 // => new: 3, old: 1 } }\nSee also Watchers\nemits\nDeclare the custom events emitted by the component.\nType\ntsinterface ComponentOptions { emits?: ArrayEmitsOptions | ObjectEmitsOptions } type ArrayEmitsOptions = string[] type ObjectEmitsOptions = { [key: string]: EmitValidator | null } type EmitValidator = (...args: unknown[]) => boolean\nDetails\nEmitted events can be declared in two forms:\n- Simple form using an array of strings\n- Full form using an object where each property key is the name of the event, and the value is either\nnull\nor a validator function.\nThe validation function will receive the additional arguments passed to the component's\n$emit\ncall. For example, ifthis.$emit('foo', 1)\nis called, the corresponding validator forfoo\nwill receive the argument1\n. The validator function should return a boolean to indicate whether the event arguments are valid.Note that the\nemits\noption affects which event listeners are considered component event listeners, rather than native DOM event listeners. The listeners for declared events will be removed from the component's$attrs\nobject, so they will not be passed through to the component's root element. See Fallthrough Attributes for more details.Example\nArray syntax:\njsexport default { emits: ['check'], created() { this.$emit('check') } }\nObject syntax:\njsexport default { emits: { // no validation click: null, // with validation submit: (payload) => { if (payload.email && payload.password) { return true } else { console.warn(`Invalid submit event payload!`) return false } } } }\nSee also\nexpose\nDeclare exposed public properties when the component instance is accessed by a parent via template refs.\nType\ntsinterface ComponentOptions { expose?: string[] }\nDetails\nBy default, a component instance exposes all instance properties to the parent when accessed via\n$parent\n,$root\n, or template refs. This can be undesirable, since a component most likely has internal state or methods that should be kept private to avoid tight coupling.The\nexpose\noption expects a list of property name strings. Whenexpose\nis used, only the properties explicitly listed will be exposed on the component's public instance.expose\nonly affects user-defined properties - it does not filter out built-in component instance properties.Example\njsexport default { // only `publicMethod` will be available on the public instance expose: ['publicMethod'], methods: { publicMethod() { // ... }, privateMethod() { // ... } } }",
    "metadata": {
      "source": "https://vuejs.org/api/options-state",
      "title": "Options: State | Vue.js"
    }
  },
  {
    "page_content": "Component Instance\nINFO\nThis page documents the built-in properties and methods exposed on the component public instance, i.e. this\n.\nAll properties listed on this page are readonly (except nested properties in $data\n).\n$data\nThe object returned from the data\noption, made reactive by the component. The component instance proxies access to the properties on its data object.\nType\ntsinterface ComponentPublicInstance { $data: object }\n$props\nAn object representing the component's current, resolved props.\nType\ntsinterface ComponentPublicInstance { $props: object }\nDetails\nOnly props declared via the\nprops\noption will be included. The component instance proxies access to the properties on its props object.\n$el\nThe root DOM node that the component instance is managing.\nType\ntsinterface ComponentPublicInstance { $el: Node | undefined }\nDetails\n$el\nwill beundefined\nuntil the component is mounted.- For components with a single root element,\n$el\nwill point to that element. - For components with text root,\n$el\nwill point to the text node. - For components with multiple root nodes,\n$el\nwill be the placeholder DOM node that Vue uses to keep track of the component's position in the DOM (a text node, or a comment node in SSR hydration mode).\nTIP\nFor consistency, it is recommended to use template refs for direct access to elements instead of relying on\n$el\n.- For components with a single root element,\n$options\nThe resolved component options used for instantiating the current component instance.\nType\ntsinterface ComponentPublicInstance { $options: ComponentOptions }\nDetails\nThe\n$options\nobject exposes the resolved options for the current component and is the merge result of these possible sources:- Global mixins\n- Component\nextends\nbase - Component mixins\nIt is typically used to support custom component options:\njsconst app = createApp({ customOption: 'foo', created() { console.log(this.$options.customOption) // => 'foo' } })\nSee also\napp.config.optionMergeStrategies\n$parent\nThe parent instance, if the current instance has one. It will be null\nfor the root instance itself.\nType\ntsinterface ComponentPublicInstance { $parent: ComponentPublicInstance | null }\n$root\nThe root component instance of the current component tree. If the current instance has no parents this value will be itself.\nType\ntsinterface ComponentPublicInstance { $root: ComponentPublicInstance }\n$slots\nAn object representing the slots passed by the parent component.\nType\ntsinterface ComponentPublicInstance { $slots: { [name: string]: Slot } } type Slot = (...args: any[]) => VNode[]\nDetails\nTypically used when manually authoring render functions, but can also be used to detect whether a slot is present.\nEach slot is exposed on\nthis.$slots\nas a function that returns an array of vnodes under the key corresponding to that slot's name. The default slot is exposed asthis.$slots.default\n.If a slot is a scoped slot, arguments passed to the slot functions are available to the slot as its slot props.\nSee also Render Functions - Rendering Slots\n$refs\nAn object of DOM elements and component instances, registered via template refs.\nType\ntsinterface ComponentPublicInstance { $refs: { [name: string]: Element | ComponentPublicInstance | null } }\nSee also\n$attrs\nAn object that contains the component's fallthrough attributes.\nType\ntsinterface ComponentPublicInstance { $attrs: object }\nDetails\nFallthrough Attributes are attributes and event handlers passed by the parent component, but not declared as a prop or an emitted event by the child.\nBy default, everything in\n$attrs\nwill be automatically inherited on the component's root element if there is only a single root element. This behavior is disabled if the component has multiple root nodes, and can be explicitly disabled with theinheritAttrs\noption.See also\n$watch()\nImperative API for creating watchers.\nType\ntsinterface ComponentPublicInstance { $watch( source: string | (() => any), callback: WatchCallback, options?: WatchOptions ): StopHandle } type WatchCallback<T> = ( value: T, oldValue: T, onCleanup: (cleanupFn: () => void) => void ) => void interface WatchOptions { immediate?: boolean // default: false deep?: boolean // default: false flush?: 'pre' | 'post' | 'sync' // default: 'pre' onTrack?: (event: DebuggerEvent) => void onTrigger?: (event: DebuggerEvent) => void } type StopHandle = () => void\nDetails\nThe first argument is the watch source. It can be a component property name string, a simple dot-delimited path string, or a getter function.\nThe second argument is the callback function. The callback receives the new value and the old value of the watched source.\nimmediate\n: trigger the callback immediately on watcher creation. Old value will beundefined\non the first call.deep\n: force deep traversal of the source if it is an object, so that the callback fires on deep mutations. See Deep Watchers.flush\n: adjust the callback's flush timing. See Callback Flush Timing andwatchEffect()\n.onTrack / onTrigger\n: debug the watcher's dependencies. See Watcher Debugging.\nExample\nWatch a property name:\njsthis.$watch('a', (newVal, oldVal) => {})\nWatch a dot-delimited path:\njsthis.$watch('a.b', (newVal, oldVal) => {})\nUsing getter for more complex expressions:\njsthis.$watch( // every time the expression `this.a + this.b` yields // a different result, the handler will be called. // It's as if we were watching a computed property // without defining the computed property itself. () => this.a + this.b, (newVal, oldVal) => {} )\nStopping the watcher:\njsconst unwatch = this.$watch('a', cb) // later... unwatch()\nSee also\n$emit()\nTrigger a custom event on the current instance. Any additional arguments will be passed into the listener's callback function.\nType\ntsinterface ComponentPublicInstance { $emit(event: string, ...args: any[]): void }\nExample\njsexport default { created() { // only event this.$emit('foo') // with additional arguments this.$emit('bar', 1, 2, 3) } }\nSee also\n$forceUpdate()\nForce the component instance to re-render.\nType\ntsinterface ComponentPublicInstance { $forceUpdate(): void }\nDetails\nThis should be rarely needed given Vue's fully automatic reactivity system. The only cases where you may need it is when you have explicitly created non-reactive component state using advanced reactivity APIs.\n$nextTick()\nInstance-bound version of the global nextTick()\n.\nType\ntsinterface ComponentPublicInstance { $nextTick(callback?: (this: ComponentPublicInstance) => void): Promise<void> }\nDetails\nThe only difference from the global version of\nnextTick()\nis that the callback passed tothis.$nextTick()\nwill have itsthis\ncontext bound to the current component instance.See also\nnextTick()",
    "metadata": {
      "source": "https://vuejs.org/api/component-instance",
      "title": "Component Instance | Vue.js"
    }
  },
  {
    "page_content": "Custom Renderer API\ncreateRenderer()\nCreates a custom renderer. By providing platform-specific node creation and manipulation APIs, you can leverage Vue's core runtime to target non-DOM environments.\nType\ntsfunction createRenderer<HostNode, HostElement>( options: RendererOptions<HostNode, HostElement> ): Renderer<HostElement> interface Renderer<HostElement> { render: RootRenderFunction<HostElement> createApp: CreateAppFunction<HostElement> } interface RendererOptions<HostNode, HostElement> { patchProp( el: HostElement, key: string, prevValue: any, nextValue: any, // the rest is unused for most custom renderers isSVG?: boolean, prevChildren?: VNode<HostNode, HostElement>[], parentComponent?: ComponentInternalInstance | null, parentSuspense?: SuspenseBoundary | null, unmountChildren?: UnmountChildrenFn ): void insert( el: HostNode, parent: HostElement, anchor?: HostNode | null ): void remove(el: HostNode): void createElement( type: string, isSVG?: boolean, isCustomizedBuiltIn?: string, vnodeProps?: (VNodeProps & { [key: string]: any }) | null ): HostElement createText(text: string): HostNode createComment(text: string): HostNode setText(node: HostNode, text: string): void setElementText(node: HostElement, text: string): void parentNode(node: HostNode): HostElement | null nextSibling(node: HostNode): HostNode | null // optional, DOM-specific querySelector?(selector: string): HostElement | null setScopeId?(el: HostElement, id: string): void cloneNode?(node: HostNode): HostNode insertStaticContent?( content: string, parent: HostElement, anchor: HostNode | null, isSVG: boolean ): [HostNode, HostNode] }\nExample\njsimport { createRenderer } from '@vue/runtime-core' const { render, createApp } = createRenderer({ patchProp, insert, remove, createElement // ... }) // `render` is the low-level API // `createApp` returns an app instance export { render, createApp } // re-export Vue core APIs export * from '@vue/runtime-core'\nVue's own\n@vue/runtime-dom\nis implemented using the same API. For a simpler implementation, check out@vue/runtime-test\nwhich is a private package for Vue's own unit testing.",
    "metadata": {
      "source": "https://vuejs.org/api/custom-renderer",
      "title": "Custom Renderer API | Vue.js"
    }
  },
  {
    "page_content": "Reactivity API: Utilities\nisRef()\nChecks if a value is a ref object.\nType\ntsfunction isRef<T>(r: Ref<T> | unknown): r is Ref<T>\nNote the return type is a type predicate, which means\nisRef\ncan be used as a type guard:tslet foo: unknown if (isRef(foo)) { // foo's type is narrowed to Ref<unknown> foo.value }\nunref()\nReturns the inner value if the argument is a ref, otherwise return the argument itself. This is a sugar function for val = isRef(val) ? val.value : val\n.\nType\ntsfunction unref<T>(ref: T | Ref<T>): T\nExample\ntsfunction useFoo(x: number | Ref<number>) { const unwrapped = unref(x) // unwrapped is guaranteed to be number now }\ntoRef()\nCan be used to normalize values / refs / getters into refs (3.3+).\nCan also be used to create a ref for a property on a source reactive object. The created ref is synced with its source property: mutating the source property will update the ref, and vice-versa.\nType\nts// normalization signature (3.3+) function toRef<T>( value: T ): T extends () => infer R ? Readonly<Ref<R>> : T extends Ref ? T : Ref<UnwrapRef<T>> // object property signature function toRef<T extends object, K extends keyof T>( object: T, key: K, defaultValue?: T[K] ): ToRef<T[K]> type ToRef<T> = T extends Ref ? T : Ref<T>\nExample\nNormalization signature (3.3+):\njs// returns existing refs as-is toRef(existingRef) // creates a readonly ref that calls the getter on .value access toRef(() => props.foo) // creates normal refs from non-function values // equivalent to ref(1) toRef(1)\nObject property signature:\njsconst state = reactive({ foo: 1, bar: 2 }) // a two-way ref that syncs with the original property const fooRef = toRef(state, 'foo') // mutating the ref updates the original fooRef.value++ console.log(state.foo) // 2 // mutating the original also updates the ref state.foo++ console.log(fooRef.value) // 3\nNote this is different from:\njsconst fooRef = ref(state.foo)\nThe above ref is not synced with\nstate.foo\n, because theref()\nreceives a plain number value.toRef()\nis useful when you want to pass the ref of a prop to a composable function:vue<script setup> import { toRef } from 'vue' const props = defineProps(/* ... */) // convert `props.foo` into a ref, then pass into // a composable useSomeFeature(toRef(props, 'foo')) // getter syntax - recommended in 3.3+ useSomeFeature(toRef(() => props.foo)) </script>\nWhen\ntoRef\nis used with component props, the usual restrictions around mutating the props still apply. Attempting to assign a new value to the ref is equivalent to trying to modify the prop directly and is not allowed. In that scenario you may want to consider usingcomputed\nwithget\nandset\ninstead. See the guide to usingv-model\nwith components for more information.When using the object property signature,\ntoRef()\nwill return a usable ref even if the source property doesn't currently exist. This makes it possible to work with optional properties, which wouldn't be picked up bytoRefs\n.\ntoValue()\nNormalizes values / refs / getters to values. This is similar to unref(), except that it also normalizes getters. If the argument is a getter, it will be invoked and its return value will be returned.\nThis can be used in Composables to normalize an argument that can be either a value, a ref, or a getter.\nType\ntsfunction toValue<T>(source: T | Ref<T> | (() => T)): T\nExample\njstoValue(1) // --> 1 toValue(ref(1)) // --> 1 toValue(() => 1) // --> 1\nNormalizing arguments in composables:\ntsimport type { MaybeRefOrGetter } from 'vue' function useFeature(id: MaybeRefOrGetter<number>) { watch(() => toValue(id), id => { // react to id changes }) } // this composable supports any of the following: useFeature(1) useFeature(ref(1)) useFeature(() => 1)\ntoRefs()\nConverts a reactive object to a plain object where each property of the resulting object is a ref pointing to the corresponding property of the original object. Each individual ref is created using toRef()\n.\nType\ntsfunction toRefs<T extends object>( object: T ): { [K in keyof T]: ToRef<T[K]> } type ToRef = T extends Ref ? T : Ref<T>\nExample\njsconst state = reactive({ foo: 1, bar: 2 }) const stateAsRefs = toRefs(state) /* Type of stateAsRefs: { foo: Ref<number>, bar: Ref<number> } */ // The ref and the original property is \"linked\" state.foo++ console.log(stateAsRefs.foo.value) // 2 stateAsRefs.foo.value++ console.log(state.foo) // 3\ntoRefs\nis useful when returning a reactive object from a composable function so that the consuming component can destructure/spread the returned object without losing reactivity:jsfunction useFeatureX() { const state = reactive({ foo: 1, bar: 2 }) // ...logic operating on state // convert to refs when returning return toRefs(state) } // can destructure without losing reactivity const { foo, bar } = useFeatureX()\ntoRefs\nwill only generate refs for properties that are enumerable on the source object at call time. To create a ref for a property that may not exist yet, usetoRef\ninstead.\nisProxy()\nChecks if an object is a proxy created by reactive()\n, readonly()\n, shallowReactive()\nor shallowReadonly()\n.\nType\ntsfunction isProxy(value: any): boolean\nisReactive()\nChecks if an object is a proxy created by reactive()\nor shallowReactive()\n.\nType\ntsfunction isReactive(value: unknown): boolean\nisReadonly()\nChecks whether the passed value is a readonly object. The properties of a readonly object can change, but they can't be assigned directly via the passed object.\nThe proxies created by readonly()\nand shallowReadonly()\nare both considered readonly, as is a computed()\nref without a set\nfunction.\nType\ntsfunction isReadonly(value: unknown): boolean",
    "metadata": {
      "source": "https://vuejs.org/api/reactivity-utilities",
      "title": "Reactivity API: Utilities | Vue.js"
    }
  },
  {
    "page_content": "API Reference\nGlobal API\nApplication\n- createApp()\n- createSSRApp()\n- app.mount()\n- app.unmount()\n- app.component()\n- app.directive()\n- app.use()\n- app.mixin()\n- app.provide()\n- app.runWithContext()\n- app.version\n- app.config\n- app.config.errorHandler\n- app.config.warnHandler\n- app.config.performance\n- app.config.compilerOptions\n- app.config.globalProperties\n- app.config.optionMergeStrategies",
    "metadata": {
      "source": "https://vuejs.org/api/",
      "title": "API Reference | Vue.js"
    }
  },
  {
    "page_content": "Glossary\nThis glossary is intended to provide some guidance about the meanings of technical terms that are in common usage when talking about Vue. It is intended to be descriptive of how terms are commonly used, not a prescriptive specification of how they must be used. Some terms may have slightly different meanings or nuances depending on the surrounding context.\nasync component\nAn async component is a wrapper around another component that allows for the wrapped component to be lazy loaded. This is typically used as a way to reduce the size of the built .js\nfiles, allowing them to be split into smaller chunks that are loaded only when required.\nVue Router has a similar feature for the lazy loading of route components, though this does not use Vue's async components feature.\nFor more details see:\ncompiler macro\nA compiler macro is special code that is processed by a compiler and converted into something else. They are effectively a clever form of string replacement.\nVue's SFC compiler supports various macros, such as defineProps()\n, defineEmits()\nand defineExpose()\n. These macros are intentionally designed to look like normal JavaScript functions so that they can leverage the same parser and type inference tooling around JavaScript / TypeScript. However, they are not actual functions that are run in the browser. These are special strings that the compiler detects and replaces with the real JavaScript code that will actually be run.\nMacros have limitations on their use that don't apply to normal JavaScript code. For example, you might think that const dp = defineProps\nwould allow you to create an alias for defineProps\n, but it'll actually result in an error. There are also limitations on what values can be passed to defineProps()\n, as the 'arguments' have to be processed by the compiler and not at runtime.\nFor more details see:\ncomponent\nThe term component is not unique to Vue. It is common to many UI frameworks. It describes a chunk of the UI, such as a button or checkbox. Components can also be combined to form larger components.\nComponents are the primary mechanism provided by Vue to split a UI into smaller pieces, both to improve maintainability and to allow for code reuse.\nA Vue component is an object. All properties are optional, but either a template or render function is required for the component to render. For example, the following object would be a valid component:\njs\nconst HelloWorldComponent = {\nrender() {\nreturn 'Hello world!'\n}\n}\nIn practice, most Vue applications are written using Single-File Components (.vue\nfiles). While these components may not appear to be objects at first glance, the SFC compiler will convert them into an object, which is used as the default export for the file. From an external perspective, a .vue\nfile is just an ES module that exports a component object.\nThe properties of a component object are usually referred to as options. This is where the Options API gets its name.\nThe options for a component define how instances of that component should be created. Components are conceptually similar to classes, though Vue doesn't use actual JavaScript classes to define them.\nThe term component can also be used more loosely to refer to component instances.\nFor more details see:\nThe word 'component' also features in several other terms:\ncomposable\nThe term composable describes a common usage pattern in Vue. It isn't a separate feature of Vue, it's just a way of using the framework's Composition API.\n- A composable is a function.\n- Composables are used to encapsulate and reuse stateful logic.\n- The function name usually begins with\nuse\n, so that other developers know it's a composable. - The function is typically expected to be called during the synchronous execution of a component's\nsetup()\nfunction (or, equivalently, during the execution of a<script setup>\nblock). This ties the invocation of the composable to the current component context, e.g. via calls toprovide()\n,inject()\noronMounted()\n. - Composables typically return a plain object, not a reactive object. This object usually contains refs and functions and is expected to be destructured within the calling code.\nAs with many patterns, there can be some disagreement about whether specific code qualifies for the label. Not all JavaScript utility functions are composables. If a function doesn't use the Composition API then it probably isn't a composable. If it doesn't expect to be called during the synchronous execution of setup()\nthen it probably isn't a composable. Composables are specifically used to encapsulate stateful logic, they are not just a naming convention for functions.\nSee Guide - Composables for more details about writing composables.\nComposition API\nThe Composition API is a collection of functions used to write components and composables in Vue.\nThe term is also used to describe one of the two main styles used to write components, the other being the Options API. Components written using the Composition API use either <script setup>\nor an explicit setup()\nfunction.\nSee the Composition API FAQ for more details.\ncustom element\nA custom element is a feature of the Web Components standard, which is implemented in modern web browsers. It refers to the ability to use a custom HTML element in your HTML markup to include a Web Component at that point in the page.\nVue has built-in support for rendering custom elements and allows them to be used directly in Vue component templates.\nCustom elements should not be confused with the ability to include Vue components as tags within another Vue component's template. Custom elements are used to create Web Components, not Vue components.\nFor more details see:\ndirective\nThe term directive refers to template attributes beginning with the v-\nprefix, or their equivalent shorthands.\nBuilt-in directives include v-if\n, v-for\n, v-bind\n, v-on\nand v-slot\n.\nVue also supports creating custom directives, though they are typically only used as an 'escape hatch' for manipulating DOM nodes directly. Custom directives generally can't be used to recreate the functionality of the built-in directives.\nFor more details see:\ndynamic component\nThe term dynamic component is used to describe cases where the choice of which child component to render needs to be made dynamically. Typically, this is achieved using <component :is=\"type\">\n.\nA dynamic component is not a special type of component. Any component can be used as a dynamic component. It is the choice of component that is dynamic, rather than the component itself.\nFor more details see:\neffect\nSee reactive effect and side effect.\nevent\nThe use of events for communicating between different parts of a program is common to many different areas of programming. Within Vue, the term is commonly applied to both native HTML element events and Vue component events. The v-on\ndirective is used in templates to listen for both types of event.\nFor more details see:\nfragment\nThe term fragment refers to a special type of VNode that is used as a parent for other VNodes, but which doesn't render any elements itself.\nThe name comes from the similar concept of a DocumentFragment\nin the native DOM API.\nFragments are used to support components with multiple root nodes. While such components might appear to have multiple roots, behind the scenes they use a fragment node as a single root, as a parent of the 'root' nodes.\nFragments are also used by the template compiler as a way to wrap multiple dynamic nodes, e.g. those created via v-for\nor v-if\n. This allows for extra hints to be passed to the VDOM patching algorithm. Much of this is handled internally, but one place you may encounter this directly is using a key\non a <template>\ntag with v-for\n. In that scenario, the key\nis added as a prop to the fragment VNode.\nFragment nodes are currently rendered to the DOM as empty text nodes, though that is an implementation detail. You may encounter those text nodes if you use $el\nor attempt to walk the DOM with built-in browser APIs.\nfunctional component\nA component definition is usually an object containing options. It may not appear that way if you're using <script setup>\n, but the component exported from the .vue\nfile will still be an object.\nA functional component is an alternative form of component that is declared using a function instead. That function acts as the render function for the component.\nA functional component cannot have any state of its own. It also doesn't go through the usual component lifecycle, so lifecycle hooks can't be used. This makes them slightly lighter than normal, stateful components.\nFor more details see:\nhoisting\nThe term hoisting is used to describe running a section of code before it is reached, ahead of other code. The execution is 'pulled up' to an earlier point.\nJavaScript uses hoisting for some constructs, such as var\n, import\nand function declarations.\nIn a Vue context, the template compiler applies static hoisting to improve performance. When converting a template to a render function, VNodes that correspond to static content can be created once and then reused. These static VNodes are described as hoisted because they are created outside the render function, before it runs. A similar form of hoisting is applied to static objects or arrays that are generated by the template compiler.\nFor more details see:\nin-DOM template\nThere are various ways to specify a template for a component. In most cases the template is provided as a string.\nThe term in-DOM template refers to the scenario where the template is provided in the form of DOM nodes, instead of a string. Vue then converts the DOM nodes into a template string using innerHTML\n.\nTypically, an in-DOM template starts off as HTML markup written directly in the HTML of the page. The browser then parses this into DOM nodes, which Vue then uses to read off the innerHTML\n.\nFor more details see:\n- Guide - Creating an Application - In-DOM Root Component Template\n- Guide - Component Basics - in-DOM Template Parsing Caveats\n- Options: Rendering - template\ninject\nSee provide / inject.\nlifecycle hooks\nA Vue component instance goes through a lifecycle. For example, it is created, mounted, updated, and unmounted.\nThe lifecycle hooks are a way to listen for these lifecycle events.\nWith the Options API, each hook is provided as a separate option, e.g. mounted\n. The Composition API uses functions instead, such as onMounted()\n.\nFor more details see:\nmacro\nSee compiler macro.\nnamed slot\nA component can have multiple slots, differentiated by name. Slots other than the default slot are referred to as named slots.\nFor more details see:\nOptions API\nVue components are defined using objects. The properties of these component objects are known as options.\nComponents can be written in two styles. One style uses the Composition API in conjunction with setup\n(either via a setup()\noption or <script setup>\n). The other style makes very little direct use of the Composition API, instead using various component options to achieve a similar result. The component options that are used in this way are referred to as the Options API.\nThe Options API includes options such as data()\n, computed\n, methods\nand created()\n.\nSome options, such as props\n, emits\nand inheritAttrs\n, can be used when authoring components with either API. As they are component options, they could be considered part of the Options API. However, as these options are also used in conjunction with setup()\n, it is usually more useful to think of them as shared between the two component styles.\nThe setup()\nfunction itself is a component option, so it could be described as part of the Options API. However, this is not how the term 'Options API' is normally used. Instead, the setup()\nfunction is considered to be part of Composition API.\nplugin\nWhile the term plugin can be used in a wide variety of contexts, Vue has a specific concept of a plugin as a way to add functionality to an application.\nPlugins are added to an application by calling app.use(plugin)\n. The plugin itself is either a function or an object with an install\nfunction. That function will be passed the application instance and can then do whatever it needs to do.\nFor more details see:\nprop\nThere are three common uses of the term prop in Vue:\n- Component props\n- VNode props\n- Slot props\nComponent props are what most people think of as props. These are explicitly defined by a component using either defineProps()\nor the props\noption.\nThe term VNode props refers to the properties of the object passed as the second argument to h()\n. These can include component props, but they can also include component events, DOM events, DOM attributes and DOM properties. You'd usually only encounter VNode props if you're working with render functions to manipulate VNodes directly.\nSlot props are the properties passed to a scoped slot.\nIn all cases, props are properties that are passed in from elsewhere.\nWhile the word props is derived from the word properties, the term props has a much more specific meaning in the context of Vue. You should avoid using it as an abbreviation of properties.\nFor more details see:\nprovide / inject\nprovide\nand inject\nare a form of inter-component communication.\nWhen a component provides a value, all descendants of that component can then choose to grab that value, using inject\n. Unlike with props, the providing component doesn't know precisely which component is receiving the value.\nprovide\nand inject\nare sometimes used to avoid prop drilling. They can also be used as an implicit way for a component to communicate with its slot contents.\nprovide\ncan also be used at the application level, making a value available to all components within that application.\nFor more details see:\nreactive effect\nA reactive effect is part of Vue's reactivity system. It refers to the process of tracking the dependencies of a function and re-running that function when the values of those dependencies change.\nwatchEffect()\nis the most direct way to create an effect. Various other parts of Vue use effects internally. e.g. component rendering updates, computed()\nand watch()\n.\nVue can only track reactive dependencies within a reactive effect. If a property's value is read outside a reactive effect it'll 'lose' reactivity, in the sense that Vue won't know what to do if that property subsequently changes.\nThe term is derived from 'side effect'. Calling the effect function is a side effect of the property value being changed.\nFor more details see:\nreactivity\nIn general, reactivity refers to the ability to automatically perform actions in response to data changes. For example, updating the DOM or making a network request when a data value changes.\nIn a Vue context, reactivity is used to describe a collection of features. Those features combine to form a reactivity system, which is exposed via the Reactivity API.\nThere are various different ways that a reactivity system could be implemented. For example, it could be done by static analysis of code to determine its dependencies. However, Vue doesn't employ that form of reactivity system.\nInstead, Vue's reactivity system tracks property access at runtime. It does this using both Proxy wrappers and getter/setter functions for properties.\nFor more details see:\nReactivity API\nThe Reactivity API is a collection of core Vue functions related to reactivity. These can be used independently of components. It includes functions such as ref()\n, reactive()\n, computed()\n, watch()\nand watchEffect()\n.\nThe Reactivity API is a subset of the Composition API.\nFor more details see:\nref\nThis entry is about the use of\nref\nfor reactivity. For theref\nattribute used in templates, see template ref instead.\nA ref\nis part of Vue's reactivity system. It is an object with a single reactive property, called value\n.\nThere are various different types of ref. For example, refs can be created using ref()\n, shallowRef()\n, computed()\n, and customRef()\n. The function isRef()\ncan be used to check whether an object is a ref, and isReadonly()\ncan be used to check whether the ref allows the direct reassignment of its value.\nFor more details see:\n- Guide - Reactivity Fundamentals\n- Reactivity API: Core\n- Reactivity API: Utilities\n- Reactivity API: Advanced\nrender function\nA render function is the part of a component that generates the VNodes used during rendering. Templates are compiled down into render functions.\nFor more details see:\nscheduler\nThe scheduler is the part of Vue's internals that controls the timing of when reactive effects are run.\nWhen reactive state changes, Vue doesn't immediately trigger rendering updates. Instead, it batches them together using a queue. This ensures that a component only re-renders once, even if multiple changes are made to the underlying data.\nWatchers are also batched using the scheduler queue. Watchers with flush: 'pre'\n(the default) will run before component rendering, whereas those with flush: 'post'\nwill run after component rendering.\nJobs in the scheduler are also used to perform various other internal tasks, such as triggering some lifecycle hooks and updating template refs.\nscoped slot\nThe term scoped slot is used to refer to a slot that receives props.\nHistorically, Vue made a much greater distinction between scoped and non-scoped slots. To some extent they could be regarded as two separate features, unified behind a common template syntax.\nIn Vue 3, the slot APIs were simplified to make all slots behave like scoped slots. However, the use cases for scoped and non-scoped slots often differ, so the term still proves useful as a way to refer to slots with props.\nThe props passed to a slot can only be used within a specific region of the parent template, responsible for defining the slot's contents. This region of the template behaves as a variable scope for the props, hence the name 'scoped slot'.\nFor more details see:\nSFC\nside effect\nThe term side effect is not specific to Vue. It is used to describe operations or functions that do something beyond their local scope.\nFor example, in the context of setting a property like user.name = null\n, it is expected that this will change the value of user.name\n. If it also does something else, like triggering Vue's reactivity system, then this would be described as a side effect. This is the origin of the term reactive effect within Vue.\nWhen a function is described as having side effects, it means that the function performs some sort of action that is observable outside the function, aside from just returning a value. This might mean that it updates a value in state, or triggers a network request.\nThe term is often used when describing rendering or computed properties. It is considered best practice for rendering to have no side effects. Likewise, the getter function for a computed property should have no side effects.\nSingle-File Component\nThe term Single-File Component, or SFC, refers to the .vue\nfile format that is commonly used for Vue components.\nSee also:\nslot\nSlots are used to pass content to child components. Whereas props are used to pass data values, slots are used to pass richer content consisting of HTML elements and other Vue components.\nFor more details see:\ntemplate ref\nThe term template ref refers to using a ref\nattribute on a tag within a template. After the component renders, this attribute is used to populate a corresponding property with either the HTML element or the component instance that corresponds to the tag in the template.\nIf you are using the Options API then the refs are exposed via properties of the $refs\nobject.\nWith the Composition API, template refs populate a reactive ref with the same name.\nTemplate refs should not be confused with the reactive refs found in Vue's reactivity system.\nFor more details see:\nVDOM\nSee virtual DOM.\nvirtual DOM\nThe term virtual DOM (VDOM) is not unique to Vue. It is a common approach used by several web frameworks for managing updates to the UI.\nBrowsers use a tree of nodes to represent the current state of the page. That tree, and the JavaScript APIs used to interact with it, are referred to as the document object model, or DOM.\nManipulating the DOM is a major performance bottleneck. The virtual DOM provides one strategy for managing that.\nRather than creating DOM nodes directly, Vue components generate a description of what DOM nodes they would like. These descriptors are plain JavaScript objects, known as VNodes (virtual DOM nodes). Creating VNodes is relatively cheap.\nEvery time a component re-renders, the new tree of VNodes is compared to the previous tree of VNodes and any differences are then applied to the real DOM. If nothing has changed then the DOM doesn't need to be touched.\nVue uses a hybrid approach that we call Compiler-Informed Virtual DOM. Vue's template compiler is able to apply performance optimizations based on static analysis of the template. Rather than performing a full comparison of a component's old and new VNode trees at runtime, Vue can use information extracted by the compiler to reduce the comparison to just the parts of the tree that can actually change.\nFor more details see:\nVNode\nA VNode is a virtual DOM node. They can be created using the h()\nfunction.\nSee virtual DOM for more information.\nWeb Component\nThe Web Components standard is a collection of features implemented in modern web browsers.\nVue components are not Web Components, but defineCustomElement()\ncan be used to create a custom element from a Vue component. Vue also supports the use of custom elements inside Vue components.\nFor more details see:",
    "metadata": {
      "source": "https://vuejs.org/glossary/",
      "title": "Glossary | Vue.js"
    }
  },
  {
    "page_content": "SFC CSS Features\nScoped CSS\nWhen a <style>\ntag has the scoped\nattribute, its CSS will apply to elements of the current component only. This is similar to the style encapsulation found in Shadow DOM. It comes with some caveats, but doesn't require any polyfills. It is achieved by using PostCSS to transform the following:\nvue\n<style scoped>\n.example {\ncolor: red;\n}\n</style>\n<template>\n<div class=\"example\">hi</div>\n</template>\nInto the following:\nvue\n<style>\n.example[data-v-f3f3eg9] {\ncolor: red;\n}\n</style>\n<template>\n<div class=\"example\" data-v-f3f3eg9>hi</div>\n</template>\nChild Component Root Elements\nWith scoped\n, the parent component's styles will not leak into child components. However, a child component's root node will be affected by both the parent's scoped CSS and the child's scoped CSS. This is by design so that the parent can style the child root element for layout purposes.\nDeep Selectors\nIf you want a selector in scoped\nstyles to be \"deep\", i.e. affecting child components, you can use the :deep()\npseudo-class:\nvue\n<style scoped>\n.a :deep(.b) {\n/* ... */\n}\n</style>\nThe above will be compiled into:\ncss\n.a[data-v-f3f3eg9] .b {\n/* ... */\n}\nTIP\nDOM content created with v-html\nare not affected by scoped styles, but you can still style them using deep selectors.\nSlotted Selectors\nBy default, scoped styles do not affect contents rendered by <slot/>\n, as they are considered to be owned by the parent component passing them in. To explicitly target slot content, use the :slotted\npseudo-class:\nvue\n<style scoped>\n:slotted(div) {\ncolor: red;\n}\n</style>\nGlobal Selectors\nIf you want just one rule to apply globally, you can use the :global\npseudo-class rather than creating another <style>\n(see below):\nvue\n<style scoped>\n:global(.red) {\ncolor: red;\n}\n</style>\nMixing Local and Global Styles\nYou can also include both scoped and non-scoped styles in the same component:\nvue\n<style>\n/* global styles */\n</style>\n<style scoped>\n/* local styles */\n</style>\nScoped Style Tips\nScoped styles do not eliminate the need for classes. Due to the way browsers render various CSS selectors,\np { color: red }\nwill be many times slower when scoped (i.e. when combined with an attribute selector). If you use classes or ids instead, such as in.example { color: red }\n, then you virtually eliminate that performance hit.Be careful with descendant selectors in recursive components! For a CSS rule with the selector\n.a .b\n, if the element that matches.a\ncontains a recursive child component, then all.b\nin that child component will be matched by the rule.\nCSS Modules\nA <style module>\ntag is compiled as CSS Modules and exposes the resulting CSS classes to the component as an object under the key of $style\n:\nvue\n<template>\n<p :class=\"$style.red\">This should be red</p>\n</template>\n<style module>\n.red {\ncolor: red;\n}\n</style>\nThe resulting classes are hashed to avoid collision, achieving the same effect of scoping the CSS to the current component only.\nRefer to the CSS Modules spec for more details such as global exceptions and composition.\nCustom Inject Name\nYou can customize the property key of the injected classes object by giving the module\nattribute a value:\nvue\n<template>\n<p :class=\"classes.red\">red</p>\n</template>\n<style module=\"classes\">\n.red {\ncolor: red;\n}\n</style>\nUsage with Composition API\nThe injected classes can be accessed in setup()\nand <script setup>\nvia the useCssModule\nAPI. For <style module>\nblocks with custom injection names, useCssModule\naccepts the matching module\nattribute value as the first argument:\njs\nimport { useCssModule } from 'vue'\n// inside setup() scope...\n// default, returns classes for <style module>\nuseCssModule()\n// named, returns classes for <style module=\"classes\">\nuseCssModule('classes')\nv-bind()\nin CSS\nSFC <style>\ntags support linking CSS values to dynamic component state using the v-bind\nCSS function:\nvue\n<template>\n<div class=\"text\">hello</div>\n</template>\n<script>\nexport default {\ndata() {\nreturn {\ncolor: 'red'\n}\n}\n}\n</script>\n<style>\n.text {\ncolor: v-bind(color);\n}\n</style>\nThe syntax works with <script setup>\n, and supports JavaScript expressions (must be wrapped in quotes):\nvue\n<script setup>\nimport { ref } from 'vue'\nconst theme = ref({\ncolor: 'red',\n})\n</script>\n<template>\n<p>hello</p>\n</template>\n<style scoped>\np {\ncolor: v-bind('theme.color');\n}\n</style>\nThe actual value will be compiled into a hashed CSS custom property, so the CSS is still static. The custom property will be applied to the component's root element via inline styles and reactively updated if the source value changes.",
    "metadata": {
      "source": "https://vuejs.org/api/sfc-css-features",
      "title": "SFC CSS Features | Vue.js"
    }
  },
  {
    "page_content": "Global API: General\nversion\nExposes the current version of Vue.\nType:\nstring\nExample\njsimport { version } from 'vue' console.log(version)\nnextTick()\nA utility for waiting for the next DOM update flush.\nType\ntsfunction nextTick(callback?: () => void): Promise<void>\nDetails\nWhen you mutate reactive state in Vue, the resulting DOM updates are not applied synchronously. Instead, Vue buffers them until the \"next tick\" to ensure that each component updates only once no matter how many state changes you have made.\nnextTick()\ncan be used immediately after a state change to wait for the DOM updates to complete. You can either pass a callback as an argument, or await the returned Promise.Example\nvue<script setup> import { ref, nextTick } from 'vue' const count = ref(0) async function increment() { count.value++ // DOM not yet updated console.log(document.getElementById('counter').textContent) // 0 await nextTick() // DOM is now updated console.log(document.getElementById('counter').textContent) // 1 } </script> <template> <button id=\"counter\" @click=\"increment\">{{ count }}</button> </template>\nSee also\nthis.$nextTick()\ndefineComponent()\nA type helper for defining a Vue component with type inference.\nType\nts// options syntax function defineComponent( component: ComponentOptions ): ComponentConstructor // function syntax (requires 3.3+) function defineComponent( setup: ComponentOptions['setup'], extraOptions?: ComponentOptions ): () => any\nType is simplified for readability.\nDetails\nThe first argument expects a component options object. The return value will be the same options object, since the function is essentially a runtime no-op for type inference purposes only.\nNote that the return type is a bit special: it will be a constructor type whose instance type is the inferred component instance type based on the options. This is used for type inference when the returned type is used as a tag in TSX.\nYou can extract the instance type of a component (equivalent to the type of\nthis\nin its options) from the return type ofdefineComponent()\nlike this:tsconst Foo = defineComponent(/* ... */) type FooInstance = InstanceType<typeof Foo>\nFunction Signature\ndefineComponent()\nalso has an alternative signature that is meant to be used with Composition API and render functions or JSX.Instead of passing in an options object, a function is expected instead. This function works the same as the Composition API\nsetup()\nfunction: it receives the props and the setup context. The return value should be a render function - bothh()\nand JSX are supported:jsimport { ref, h } from 'vue' const Comp = defineComponent( (props) => { // use Composition API here like in <script setup> const count = ref(0) return () => { // render function or JSX return h('div', count.value) } }, // extra options, e.g. declare props and emits { props: { /* ... */ } } )\nThe main use case for this signature is with TypeScript (and in particular with TSX), as it supports generics:\ntsxconst Comp = defineComponent( <T extends string | number>(props: { msg: T; list: T[] }) => { // use Composition API here like in <script setup> const count = ref(0) return () => { // render function or JSX return <div>{count.value}</div> } }, // manual runtime props declaration is currently still needed. { props: ['msg', 'list'] } )\nIn the future, we plan to provide a Babel plugin that automatically infers and injects the runtime props (like for\ndefineProps\nin SFCs) so that the runtime props declaration can be omitted.Note on webpack Treeshaking\nBecause\ndefineComponent()\nis a function call, it could look like that it would produce side-effects to some build tools, e.g. webpack. This will prevent the component from being tree-shaken even when the component is never used.To tell webpack that this function call is safe to be tree-shaken, you can add a\n/*#__PURE__*/\ncomment notation before the function call:jsexport default /*#__PURE__*/ defineComponent(/* ... */)\nNote this is not necessary if you are using Vite, because Rollup (the underlying production bundler used by Vite) is smart enough to determine that\ndefineComponent()\nis in fact side-effect-free without the need for manual annotations.See also Guide - Using Vue with TypeScript\ndefineAsyncComponent()\nDefine an async component which is lazy loaded only when it is rendered. The argument can either be a loader function, or an options object for more advanced control of the loading behavior.\nType\ntsfunction defineAsyncComponent( source: AsyncComponentLoader | AsyncComponentOptions ): Component type AsyncComponentLoader = () => Promise<Component> interface AsyncComponentOptions { loader: AsyncComponentLoader loadingComponent?: Component errorComponent?: Component delay?: number timeout?: number suspensible?: boolean onError?: ( error: Error, retry: () => void, fail: () => void, attempts: number ) => any }\nSee also Guide - Async Components\ndefineCustomElement()\nThis method accepts the same argument as defineComponent\n, but instead returns a native Custom Element class constructor.\nType\ntsfunction defineCustomElement( component: | (ComponentOptions & { styles?: string[] }) | ComponentOptions['setup'] ): { new (props?: object): HTMLElement }\nType is simplified for readability.\nDetails\nIn addition to normal component options,\ndefineCustomElement()\nalso supports a special optionstyles\n, which should be an array of inlined CSS strings, for providing CSS that should be injected into the element's shadow root.The return value is a custom element constructor that can be registered using\ncustomElements.define()\n.Example\njsimport { defineCustomElement } from 'vue' const MyVueElement = defineCustomElement({ /* component options */ }) // Register the custom element. customElements.define('my-vue-element', MyVueElement)\nSee also\nAlso note that\ndefineCustomElement()\nrequires special config when used with Single-File Components.",
    "metadata": {
      "source": "https://vuejs.org/api/general",
      "title": "Global API: General | Vue.js"
    }
  },
  {
    "page_content": "Utility Types\nINFO\nThis page only lists a few commonly used utility types that may need explanation for their usage. For a full list of exported types, consult the source code.\nPropType<T>\nUsed to annotate a prop with more advanced types when using runtime props declarations.\nExample\ntsimport type { PropType } from 'vue' interface Book { title: string author: string year: number } export default { props: { book: { // provide more specific type to `Object` type: Object as PropType<Book>, required: true } } }\nSee also Guide - Typing Component Props\nMaybeRef<T>\nAlias for T | Ref<T>\n. Useful for annotating arguments of Composables.\n- Only supported in 3.3+.\nMaybeRefOrGetter<T>\nAlias for T | Ref<T> | (() => T)\n. Useful for annotating arguments of Composables.\n- Only supported in 3.3+.\nExtractPropTypes<T>\nExtract prop types from a runtime props options object. The extracted types are internal facing - i.e. the resolved props received by the component. This means boolean props and props with default values are always defined, even if they are not required.\nTo extract public facing props, i.e. props that the parent is allowed to pass, use ExtractPublicPropTypes\n.\nExample\ntsconst propsOptions = { foo: String, bar: Boolean, baz: { type: Number, required: true }, qux: { type: Number, default: 1 } } as const type Props = ExtractPropTypes<typeof propsOptions> // { // foo?: string, // bar: boolean, // baz: number, // qux: number // }\nExtractPublicPropTypes<T>\nExtract prop types from a runtime props options object. The extracted types are public facing - i.e. the props that the parent is allowed to pass.\nOnly supported in 3.3+.\nExample\ntsconst propsOptions = { foo: String, bar: Boolean, baz: { type: Number, required: true }, qux: { type: Number, default: 1 } } as const type Props = ExtractPublicPropTypes<typeof propsOptions> // { // foo?: string, // bar?: boolean, // baz: number, // qux?: number // }\nComponentCustomProperties\nUsed to augment the component instance type to support custom global properties.\nExample\ntsimport axios from 'axios' declare module 'vue' { interface ComponentCustomProperties { $http: typeof axios $translate: (key: string) => string } }\nTIP\nAugmentations must be placed in a module\n.ts\nor.d.ts\nfile. See Type Augmentation Placement for more details.See also Guide - Augmenting Global Properties\nComponentCustomOptions\nUsed to augment the component options type to support custom options.\nExample\ntsimport { Route } from 'vue-router' declare module 'vue' { interface ComponentCustomOptions { beforeRouteEnter?(to: any, from: any, next: () => void): void } }\nTIP\nAugmentations must be placed in a module\n.ts\nor.d.ts\nfile. See Type Augmentation Placement for more details.See also Guide - Augmenting Custom Options\nComponentCustomProps\nUsed to augment allowed TSX props in order to use non-declared props on TSX elements.\nExample\ntsdeclare module 'vue' { interface ComponentCustomProps { hello?: string } } export {}\ntsx// now works even if hello is not a declared prop <MyComponent hello=\"world\" />\nTIP\nAugmentations must be placed in a module\n.ts\nor.d.ts\nfile. See Type Augmentation Placement for more details.\nCSSProperties\nUsed to augment allowed values in style property bindings.\nExample\nAllow any custom CSS property\ntsdeclare module 'vue' { interface CSSProperties { [key: `--${string}`]: string } }\ntsx<div style={ { '--bg-color': 'blue' } }>\nhtml<div :style=\"{ '--bg-color': 'blue' }\"></div>\nTIP\nAugmentations must be placed in a module .ts\nor .d.ts\nfile. See Type Augmentation Placement for more details.\nSee also\nSFC <style>\ntags support linking CSS values to dynamic component state using the v-bind\nCSS function. This allows for custom properties without type augmentation.",
    "metadata": {
      "source": "https://vuejs.org/api/utility-types",
      "title": "Utility Types | Vue.js"
    }
  },
  {
    "page_content": "Composition API: setup()\nBasic Usage\nThe setup()\nhook serves as the entry point for Composition API usage in components in the following cases:\n- Using Composition API without a build step;\n- Integrating with Composition-API-based code in an Options API component.\nNote\nIf you are using Composition API with Single-File Components, <script setup>\nis strongly recommended for a more succinct and ergonomic syntax.\nWe can declare reactive state using Reactivity APIs and expose them to the template by returning an object from setup()\n. The properties on the returned object will also be made available on the component instance (if other options are used):\nvue\n<script>\nimport { ref } from 'vue'\nexport default {\nsetup() {\nconst count = ref(0)\n// expose to template and other options API hooks\nreturn {\ncount\n}\n},\nmounted() {\nconsole.log(this.count) // 0\n}\n}\n</script>\n<template>\n<button @click=\"count++\">{{ count }}</button>\n</template>\nrefs returned from setup\nare automatically shallow unwrapped when accessed in the template so you do not need to use .value\nwhen accessing them. They are also unwrapped in the same way when accessed on this\n.\nsetup()\nitself does not have access to the component instance - this\nwill have a value of undefined\ninside setup()\n. You can access Composition-API-exposed values from Options API, but not the other way around.\nsetup()\nshould return an object synchronously. The only case when async setup()\ncan be used is when the component is a descendant of a Suspense component.\nAccessing Props\nThe first argument in the setup\nfunction is the props\nargument. Just as you would expect in a standard component, props\ninside of a setup\nfunction are reactive and will be updated when new props are passed in.\njs\nexport default {\nprops: {\ntitle: String\n},\nsetup(props) {\nconsole.log(props.title)\n}\n}\nNote that if you destructure the props\nobject, the destructured variables will lose reactivity. It is therefore recommended to always access props in the form of props.xxx\n.\nIf you really need to destructure the props, or need to pass a prop into an external function while retaining reactivity, you can do so with the toRefs() and toRef() utility APIs:\njs\nimport { toRefs, toRef } from 'vue'\nexport default {\nsetup(props) {\n// turn `props` into an object of refs, then destructure\nconst { title } = toRefs(props)\n// `title` is a ref that tracks `props.title`\nconsole.log(title.value)\n// OR, turn a single property on `props` into a ref\nconst title = toRef(props, 'title')\n}\n}\nSetup Context\nThe second argument passed to the setup\nfunction is a Setup Context object. The context object exposes other values that may be useful inside setup\n:\njs\nexport default {\nsetup(props, context) {\n// Attributes (Non-reactive object, equivalent to $attrs)\nconsole.log(context.attrs)\n// Slots (Non-reactive object, equivalent to $slots)\nconsole.log(context.slots)\n// Emit events (Function, equivalent to $emit)\nconsole.log(context.emit)\n// Expose public properties (Function)\nconsole.log(context.expose)\n}\n}\nThe context object is not reactive and can be safely destructured:\njs\nexport default {\nsetup(props, { attrs, slots, emit, expose }) {\n...\n}\n}\nattrs\nand slots\nare stateful objects that are always updated when the component itself is updated. This means you should avoid destructuring them and always reference properties as attrs.x\nor slots.x\n. Also note that, unlike props\n, the properties of attrs\nand slots\nare not reactive. If you intend to apply side effects based on changes to attrs\nor slots\n, you should do so inside an onBeforeUpdate\nlifecycle hook.\nExposing Public Properties\nexpose\nis a function that can be used to explicitly limit the properties exposed when the component instance is accessed by a parent component via template refs:\njs\nexport default {\nsetup(props, { expose }) {\n// make the instance \"closed\" -\n// i.e. do not expose anything to the parent\nexpose()\nconst publicCount = ref(0)\nconst privateCount = ref(0)\n// selectively expose local state\nexpose({ count: publicCount })\n}\n}\nUsage with Render Functions\nsetup\ncan also return a render function which can directly make use of the reactive state declared in the same scope:\njs\nimport { h, ref } from 'vue'\nexport default {\nsetup() {\nconst count = ref(0)\nreturn () => h('div', count.value)\n}\n}\nReturning a render function prevents us from returning anything else. Internally that shouldn't be a problem, but it can be problematic if we want to expose methods of this component to the parent component via template refs.\nWe can solve this problem by calling expose()\n:\njs\nimport { h, ref } from 'vue'\nexport default {\nsetup(props, { expose }) {\nconst count = ref(0)\nconst increment = () => ++count.value\nexpose({\nincrement\n})\nreturn () => h('div', count.value)\n}\n}\nThe increment\nmethod would then be available in the parent component via a template ref.",
    "metadata": {
      "source": "https://vuejs.org/api/composition-api-setup",
      "title": "Composition API: setup() | Vue.js"
    }
  },
  {
    "page_content": "Application API\ncreateApp()\nCreates an application instance.\nType\ntsfunction createApp(rootComponent: Component, rootProps?: object): App\nDetails\nThe first argument is the root component. The second optional argument is the props to be passed to the root component.\nExample\nWith inline root component:\njsimport { createApp } from 'vue' const app = createApp({ /* root component options */ })\nWith imported component:\njsimport { createApp } from 'vue' import App from './App.vue' const app = createApp(App)\nSee also Guide - Creating a Vue Application\ncreateSSRApp()\nCreates an application instance in SSR Hydration mode. Usage is exactly the same as createApp()\n.\napp.mount()\nMounts the application instance in a container element.\nType\ntsinterface App { mount(rootContainer: Element | string): ComponentPublicInstance }\nDetails\nThe argument can either be an actual DOM element or a CSS selector (the first matched element will be used). Returns the root component instance.\nIf the component has a template or a render function defined, it will replace any existing DOM nodes inside the container. Otherwise, if the runtime compiler is available, the\ninnerHTML\nof the container will be used as the template.In SSR hydration mode, it will hydrate the existing DOM nodes inside the container. If there are mismatches, the existing DOM nodes will be morphed to match the expected output.\nFor each app instance,\nmount()\ncan only be called once.Example\njsimport { createApp } from 'vue' const app = createApp(/* ... */) app.mount('#app')\nCan also mount to an actual DOM element:\njsapp.mount(document.body.firstChild)\napp.unmount()\nUnmounts a mounted application instance, triggering the unmount lifecycle hooks for all components in the application's component tree.\nType\ntsinterface App { unmount(): void }\napp.component()\nRegisters a global component if passing both a name string and a component definition, or retrieves an already registered one if only the name is passed.\nType\ntsinterface App { component(name: string): Component | undefined component(name: string, component: Component): this }\nExample\njsimport { createApp } from 'vue' const app = createApp({}) // register an options object app.component('my-component', { /* ... */ }) // retrieve a registered component const MyComponent = app.component('my-component')\nSee also Component Registration\napp.directive()\nRegisters a global custom directive if passing both a name string and a directive definition, or retrieves an already registered one if only the name is passed.\nType\ntsinterface App { directive(name: string): Directive | undefined directive(name: string, directive: Directive): this }\nExample\njsimport { createApp } from 'vue' const app = createApp({ /* ... */ }) // register (object directive) app.directive('my-directive', { /* custom directive hooks */ }) // register (function directive shorthand) app.directive('my-directive', () => { /* ... */ }) // retrieve a registered directive const myDirective = app.directive('my-directive')\nSee also Custom Directives\napp.use()\nInstalls a plugin.\nType\ntsinterface App { use(plugin: Plugin, ...options: any[]): this }\nDetails\nExpects the plugin as the first argument, and optional plugin options as the second argument.\nThe plugin can either be an object with an\ninstall()\nmethod, or just a function that will be used as theinstall()\nmethod. The options (second argument ofapp.use()\n) will be passed along to the plugin'sinstall()\nmethod.When\napp.use()\nis called on the same plugin multiple times, the plugin will be installed only once.Example\njsimport { createApp } from 'vue' import MyPlugin from './plugins/MyPlugin' const app = createApp({ /* ... */ }) app.use(MyPlugin)\nSee also Plugins\napp.mixin()\nApplies a global mixin (scoped to the application). A global mixin applies its included options to every component instance in the application.\nNot Recommended\nMixins are supported in Vue 3 mainly for backwards compatibility, due to their widespread use in ecosystem libraries. Use of mixins, especially global mixins, should be avoided in application code.\nFor logic reuse, prefer Composables instead.\nType\ntsinterface App { mixin(mixin: ComponentOptions): this }\napp.provide()\nProvide a value that can be injected in all descendant components within the application.\nType\ntsinterface App { provide<T>(key: InjectionKey<T> | symbol | string, value: T): this }\nDetails\nExpects the injection key as the first argument, and the provided value as the second. Returns the application instance itself.\nExample\njsimport { createApp } from 'vue' const app = createApp(/* ... */) app.provide('message', 'hello')\nInside a component in the application:\njsimport { inject } from 'vue' export default { setup() { console.log(inject('message')) // 'hello' } }\nSee also\napp.runWithContext()\nExecute a callback with the current app as injection context.\nType\ntsinterface App { runWithContext<T>(fn: () => T): T }\nDetails\nExpects a callback function and runs the callback immediately. During the synchronous call of the callback,\ninject()\ncalls are able to look up injections from the values provided by the current app, even when there is no current active component instance. The return value of the callback will also be returned.Example\njsimport { inject } from 'vue' app.provide('id', 1) const injected = app.runWithContext(() => { return inject('id') }) console.log(injected) // 1\napp.version\nProvides the version of Vue that the application was created with. This is useful inside plugins, where you might need conditional logic based on different Vue versions.\nType\ntsinterface App { version: string }\nExample\nPerforming a version check inside a plugin:\njsexport default { install(app) { const version = Number(app.version.split('.')[0]) if (version < 3) { console.warn('This plugin requires Vue 3') } } }\nSee also Global API - version\napp.config\nEvery application instance exposes a config\nobject that contains the configuration settings for that application. You can modify its properties (documented below) before mounting your application.\njs\nimport { createApp } from 'vue'\nconst app = createApp(/* ... */)\nconsole.log(app.config)\napp.config.errorHandler\nAssign a global handler for uncaught errors propagating from within the application.\nType\ntsinterface AppConfig { errorHandler?: ( err: unknown, instance: ComponentPublicInstance | null, // `info` is a Vue-specific error info, // e.g. which lifecycle hook the error was thrown in info: string ) => void }\nDetails\nThe error handler receives three arguments: the error, the component instance that triggered the error, and an information string specifying the error source type.\nIt can capture errors from the following sources:\n- Component renders\n- Event handlers\n- Lifecycle hooks\nsetup()\nfunction- Watchers\n- Custom directive hooks\n- Transition hooks\nTIP\nIn production, the 3rd argument (\ninfo\n) will be a shortened code instead of the full information string. You can find the code to string mapping in the Production Error Code Reference.Example\njsapp.config.errorHandler = (err, instance, info) => { // handle error, e.g. report to a service }\napp.config.warnHandler\nAssign a custom handler for runtime warnings from Vue.\nType\ntsinterface AppConfig { warnHandler?: ( msg: string, instance: ComponentPublicInstance | null, trace: string ) => void }\nDetails\nThe warning handler receives the warning message as the first argument, the source component instance as the second argument, and a component trace string as the third.\nIt can be used to filter out specific warnings to reduce console verbosity. All Vue warnings should be addressed during development, so this is only recommended during debug sessions to focus on specific warnings among many, and should be removed once the debugging is done.\nTIP\nWarnings only work during development, so this config is ignored in production mode.\nExample\njsapp.config.warnHandler = (msg, instance, trace) => { // `trace` is the component hierarchy trace }\napp.config.performance\nSet this to true\nto enable component init, compile, render and patch performance tracing in the browser devtool performance/timeline panel. Only works in development mode and in browsers that support the performance.mark API.\nType:\nboolean\nSee also Guide - Performance\napp.config.compilerOptions\nConfigure runtime compiler options. Values set on this object will be passed to the in-browser template compiler and affect every component in the configured app. Note you can also override these options on a per-component basis using the compilerOptions\noption.\nImportant\nThis config option is only respected when using the full build (i.e. the standalone vue.js\nthat can compile templates in the browser). If you are using the runtime-only build with a build setup, compiler options must be passed to @vue/compiler-dom\nvia build tool configurations instead.\nFor\nvue-loader\n: pass via thecompilerOptions\nloader option. Also see how to configure it invue-cli\n.For\nvite\n: pass via@vitejs/plugin-vue\noptions.\napp.config.compilerOptions.isCustomElement\nSpecifies a check method to recognize native custom elements.\nType:\n(tag: string) => boolean\nDetails\nShould return\ntrue\nif the tag should be treated as a native custom element. For a matched tag, Vue will render it as a native element instead of attempting to resolve it as a Vue component.Native HTML and SVG tags don't need to be matched in this function - Vue's parser recognizes them automatically.\nExample\njs// treat all tags starting with 'ion-' as custom elements app.config.compilerOptions.isCustomElement = (tag) => { return tag.startsWith('ion-') }\nSee also Vue and Web Components\napp.config.compilerOptions.whitespace\nAdjusts template whitespace handling behavior.\nType:\n'condense' | 'preserve'\nDefault:\n'condense'\nDetails\nVue removes / condenses whitespace characters in templates to produce more efficient compiled output. The default strategy is \"condense\", with the following behavior:\n- Leading / ending whitespace characters inside an element are condensed into a single space.\n- Whitespace characters between elements that contain newlines are removed.\n- Consecutive whitespace characters in text nodes are condensed into a single space.\nSetting this option to\n'preserve'\nwill disable (2) and (3).Example\njsapp.config.compilerOptions.whitespace = 'preserve'\napp.config.compilerOptions.delimiters\nAdjusts the delimiters used for text interpolation within the template.\nType:\n[string, string]\nDefault:\n['{{', '}}']\nDetails\nThis is typically used to avoid conflicting with server-side frameworks that also use mustache syntax.\nExample\njs// Delimiters changed to ES6 template string style app.config.compilerOptions.delimiters = ['${', '}']\napp.config.compilerOptions.comments\nAdjusts treatment of HTML comments in templates.\nType:\nboolean\nDefault:\nfalse\nDetails\nBy default, Vue will remove the comments in production. Setting this option to\ntrue\nwill force Vue to preserve comments even in production. Comments are always preserved during development. This option is typically used when Vue is used with other libraries that rely on HTML comments.Example\njsapp.config.compilerOptions.comments = true\napp.config.globalProperties\nAn object that can be used to register global properties that can be accessed on any component instance inside the application.\nType\ntsinterface AppConfig { globalProperties: Record<string, any> }\nDetails\nThis is a replacement of Vue 2's\nVue.prototype\nwhich is no longer present in Vue 3. As with anything global, this should be used sparingly.If a global property conflicts with a component’s own property, the component's own property will have higher priority.\nUsage\njsapp.config.globalProperties.msg = 'hello'\nThis makes\nmsg\navailable inside any component template in the application, and also onthis\nof any component instance:jsexport default { mounted() { console.log(this.msg) // 'hello' } }\nSee also Guide - Augmenting Global Properties\napp.config.optionMergeStrategies\nAn object for defining merging strategies for custom component options.\nType\ntsinterface AppConfig { optionMergeStrategies: Record<string, OptionMergeFunction> } type OptionMergeFunction = (to: unknown, from: unknown) => any\nDetails\nSome plugins / libraries add support for custom component options (by injecting global mixins). These options may require special merging logic when the same option needs to be \"merged\" from multiple sources (e.g. mixins or component inheritance).\nA merge strategy function can be registered for a custom option by assigning it on the\napp.config.optionMergeStrategies\nobject using the option's name as the key.The merge strategy function receives the value of that option defined on the parent and child instances as the first and second arguments, respectively.\nExample\njsconst app = createApp({ // option from self msg: 'Vue', // option from a mixin mixins: [ { msg: 'Hello ' } ], mounted() { // merged options exposed on this.$options console.log(this.$options.msg) } }) // define a custom merge strategy for `msg` app.config.optionMergeStrategies.msg = (parent, child) => { return (parent || '') + (child || '') } app.mount('#app') // logs 'Hello Vue'\nSee also Component Instance -\n$options",
    "metadata": {
      "source": "https://vuejs.org/api/application",
      "title": "Application API | Vue.js"
    }
  },
  {
    "page_content": "Built-in Special Attributes\nkey\nThe key\nspecial attribute is primarily used as a hint for Vue's virtual DOM algorithm to identify vnodes when diffing the new list of nodes against the old list.\nExpects:\nnumber | string | symbol\nDetails\nWithout keys, Vue uses an algorithm that minimizes element movement and tries to patch/reuse elements of the same type in-place as much as possible. With keys, it will reorder elements based on the order change of keys, and elements with keys that are no longer present will always be removed / destroyed.\nChildren of the same common parent must have unique keys. Duplicate keys will cause render errors.\nThe most common use case is combined with\nv-for\n:template<ul> <li v-for=\"item in items\" :key=\"item.id\">...</li> </ul>\nIt can also be used to force replacement of an element/component instead of reusing it. This can be useful when you want to:\n- Properly trigger lifecycle hooks of a component\n- Trigger transitions\nFor example:\ntemplate<transition> <span :key=\"text\">{{ text }}</span> </transition>\nWhen\ntext\nchanges, the<span>\nwill always be replaced instead of patched, so a transition will be triggered.See also Guide - List Rendering - Maintaining State with\nkey\nref\nDenotes a template ref.\nExpects:\nstring | Function\nDetails\nref\nis used to register a reference to an element or a child component.In Options API, the reference will be registered under the component's\nthis.$refs\nobject:template<!-- stored as this.$refs.p --> <p ref=\"p\">hello</p>\nIn Composition API, the reference will be stored in a ref with matching name:\nvue<script setup> import { ref } from 'vue' const p = ref() </script> <template> <p ref=\"p\">hello</p> </template>\nIf used on a plain DOM element, the reference will be that element; if used on a child component, the reference will be the child component instance.\nAlternatively\nref\ncan accept a function value which provides full control over where to store the reference:template<ChildComponent :ref=\"(el) => child = el\" />\nAn important note about the ref registration timing: because the refs themselves are created as a result of the render function, you must wait until the component is mounted before accessing them.\nthis.$refs\nis also non-reactive, therefore you should not attempt to use it in templates for data-binding.See also\nis\nUsed for binding dynamic components.\nExpects:\nstring | Component\nUsage on native elements 3.1+\nWhen the\nis\nattribute is used on a native HTML element, it will be interpreted as a Customized built-in element, which is a native web platform feature.There is, however, a use case where you may need Vue to replace a native element with a Vue component, as explained in in-DOM Template Parsing Caveats. You can prefix the value of the\nis\nattribute withvue:\nso that Vue will render the element as a Vue component instead:template<table> <tr is=\"vue:my-row-component\"></tr> </table>\nSee also",
    "metadata": {
      "source": "https://vuejs.org/api/built-in-special-attributes",
      "title": "Built-in Special Attributes | Vue.js"
    }
  },
  {
    "page_content": "Reactivity API: Core\nSee also\nTo better understand the Reactivity APIs, it is recommended to read the following chapters in the guide:\n- Reactivity Fundamentals (with the API preference set to Composition API)\n- Reactivity in Depth\nref()\nTakes an inner value and returns a reactive and mutable ref object, which has a single property .value\nthat points to the inner value.\nType\ntsfunction ref<T>(value: T): Ref<UnwrapRef<T>> interface Ref<T> { value: T }\nDetails\nThe ref object is mutable - i.e. you can assign new values to\n.value\n. It is also reactive - i.e. any read operations to.value\nare tracked, and write operations will trigger associated effects.If an object is assigned as a ref's value, the object is made deeply reactive with reactive(). This also means if the object contains nested refs, they will be deeply unwrapped.\nTo avoid the deep conversion, use\nshallowRef()\ninstead.Example\njsconst count = ref(0) console.log(count.value) // 0 count.value = 1 console.log(count.value) // 1\nSee also\ncomputed()\nTakes a getter function and returns a readonly reactive ref object for the returned value from the getter. It can also take an object with get\nand set\nfunctions to create a writable ref object.\nType\nts// read-only function computed<T>( getter: (oldValue: T | undefined) => T, // see \"Computed Debugging\" link below debuggerOptions?: DebuggerOptions ): Readonly<Ref<Readonly<T>>> // writable function computed<T>( options: { get: (oldValue: T | undefined) => T set: (value: T) => void }, debuggerOptions?: DebuggerOptions ): Ref<T>\nExample\nCreating a readonly computed ref:\njsconst count = ref(1) const plusOne = computed(() => count.value + 1) console.log(plusOne.value) // 2 plusOne.value++ // error\nCreating a writable computed ref:\njsconst count = ref(1) const plusOne = computed({ get: () => count.value + 1, set: (val) => { count.value = val - 1 } }) plusOne.value = 1 console.log(count.value) // 0\nDebugging:\njsconst plusOne = computed(() => count.value + 1, { onTrack(e) { debugger }, onTrigger(e) { debugger } })\nSee also\nreactive()\nReturns a reactive proxy of the object.\nType\ntsfunction reactive<T extends object>(target: T): UnwrapNestedRefs<T>\nDetails\nThe reactive conversion is \"deep\": it affects all nested properties. A reactive object also deeply unwraps any properties that are refs while maintaining reactivity.\nIt should also be noted that there is no ref unwrapping performed when the ref is accessed as an element of a reactive array or a native collection type like\nMap\n.To avoid the deep conversion and only retain reactivity at the root level, use shallowReactive() instead.\nThe returned object and its nested objects are wrapped with ES Proxy and not equal to the original objects. It is recommended to work exclusively with the reactive proxy and avoid relying on the original object.\nExample\nCreating a reactive object:\njsconst obj = reactive({ count: 0 }) obj.count++\nRef unwrapping:\ntsconst count = ref(1) const obj = reactive({ count }) // ref will be unwrapped console.log(obj.count === count.value) // true // it will update `obj.count` count.value++ console.log(count.value) // 2 console.log(obj.count) // 2 // it will also update `count` ref obj.count++ console.log(obj.count) // 3 console.log(count.value) // 3\nNote that refs are not unwrapped when accessed as array or collection elements:\njsconst books = reactive([ref('Vue 3 Guide')]) // need .value here console.log(books[0].value) const map = reactive(new Map([['count', ref(0)]])) // need .value here console.log(map.get('count').value)\nWhen assigning a ref to a\nreactive\nproperty, that ref will also be automatically unwrapped:tsconst count = ref(1) const obj = reactive({}) obj.count = count console.log(obj.count) // 1 console.log(obj.count === count.value) // true\nSee also\nreadonly()\nTakes an object (reactive or plain) or a ref and returns a readonly proxy to the original.\nType\ntsfunction readonly<T extends object>( target: T ): DeepReadonly<UnwrapNestedRefs<T>>\nDetails\nA readonly proxy is deep: any nested property accessed will be readonly as well. It also has the same ref-unwrapping behavior as\nreactive()\n, except the unwrapped values will also be made readonly.To avoid the deep conversion, use shallowReadonly() instead.\nExample\njsconst original = reactive({ count: 0 }) const copy = readonly(original) watchEffect(() => { // works for reactivity tracking console.log(copy.count) }) // mutating original will trigger watchers relying on the copy original.count++ // mutating the copy will fail and result in a warning copy.count++ // warning!\nwatchEffect()\nRuns a function immediately while reactively tracking its dependencies and re-runs it whenever the dependencies are changed.\nType\ntsfunction watchEffect( effect: (onCleanup: OnCleanup) => void, options?: WatchEffectOptions ): StopHandle type OnCleanup = (cleanupFn: () => void) => void interface WatchEffectOptions { flush?: 'pre' | 'post' | 'sync' // default: 'pre' onTrack?: (event: DebuggerEvent) => void onTrigger?: (event: DebuggerEvent) => void } type StopHandle = () => void\nDetails\nThe first argument is the effect function to be run. The effect function receives a function that can be used to register a cleanup callback. The cleanup callback will be called right before the next time the effect is re-run, and can be used to clean up invalidated side effects, e.g. a pending async request (see example below).\nThe second argument is an optional options object that can be used to adjust the effect's flush timing or to debug the effect's dependencies.\nBy default, watchers will run just prior to component rendering. Setting\nflush: 'post'\nwill defer the watcher until after component rendering. See Callback Flush Timing for more information. In rare cases, it might be necessary to trigger a watcher immediately when a reactive dependency changes, e.g. to invalidate a cache. This can be achieved usingflush: 'sync'\n. However, this setting should be used with caution, as it can lead to problems with performance and data consistency if multiple properties are being updated at the same time.The return value is a handle function that can be called to stop the effect from running again.\nExample\njsconst count = ref(0) watchEffect(() => console.log(count.value)) // -> logs 0 count.value++ // -> logs 1\nSide effect cleanup:\njswatchEffect(async (onCleanup) => { const { response, cancel } = doAsyncWork(id.value) // `cancel` will be called if `id` changes // so that previous pending request will be cancelled // if not yet completed onCleanup(cancel) data.value = await response })\nStopping the watcher:\njsconst stop = watchEffect(() => {}) // when the watcher is no longer needed: stop()\nOptions:\njswatchEffect(() => {}, { flush: 'post', onTrack(e) { debugger }, onTrigger(e) { debugger } })\nSee also\nwatchPostEffect()\nAlias of watchEffect()\nwith flush: 'post'\noption.\nwatchSyncEffect()\nAlias of watchEffect()\nwith flush: 'sync'\noption.\nwatch()\nWatches one or more reactive data sources and invokes a callback function when the sources change.\nType\nts// watching single source function watch<T>( source: WatchSource<T>, callback: WatchCallback<T>, options?: WatchOptions ): StopHandle // watching multiple sources function watch<T>( sources: WatchSource<T>[], callback: WatchCallback<T[]>, options?: WatchOptions ): StopHandle type WatchCallback<T> = ( value: T, oldValue: T, onCleanup: (cleanupFn: () => void) => void ) => void type WatchSource<T> = | Ref<T> // ref | (() => T) // getter | T extends object ? T : never // reactive object interface WatchOptions extends WatchEffectOptions { immediate?: boolean // default: false deep?: boolean // default: false flush?: 'pre' | 'post' | 'sync' // default: 'pre' onTrack?: (event: DebuggerEvent) => void onTrigger?: (event: DebuggerEvent) => void once?: boolean // default: false (3.4+) }\nTypes are simplified for readability.\nDetails\nwatch()\nis lazy by default - i.e. the callback is only called when the watched source has changed.The first argument is the watcher's source. The source can be one of the following:\n- A getter function that returns a value\n- A ref\n- A reactive object\n- ...or an array of the above.\nThe second argument is the callback that will be called when the source changes. The callback receives three arguments: the new value, the old value, and a function for registering a side effect cleanup callback. The cleanup callback will be called right before the next time the effect is re-run, and can be used to clean up invalidated side effects, e.g. a pending async request.\nWhen watching multiple sources, the callback receives two arrays containing new / old values corresponding to the source array.\nThe third optional argument is an options object that supports the following options:\nimmediate\n: trigger the callback immediately on watcher creation. Old value will beundefined\non the first call.deep\n: force deep traversal of the source if it is an object, so that the callback fires on deep mutations. See Deep Watchers.flush\n: adjust the callback's flush timing. See Callback Flush Timing andwatchEffect()\n.onTrack / onTrigger\n: debug the watcher's dependencies. See Watcher Debugging.once\n: run the callback only once. The watcher is automatically stopped after the first callback run.\nCompared to\nwatchEffect()\n,watch()\nallows us to:- Perform the side effect lazily;\n- Be more specific about what state should trigger the watcher to re-run;\n- Access both the previous and current value of the watched state.\nExample\nWatching a getter:\njsconst state = reactive({ count: 0 }) watch( () => state.count, (count, prevCount) => { /* ... */ } )\nWatching a ref:\njsconst count = ref(0) watch(count, (count, prevCount) => { /* ... */ })\nWhen watching multiple sources, the callback receives arrays containing new / old values corresponding to the source array:\njswatch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) => { /* ... */ })\nWhen using a getter source, the watcher only fires if the getter's return value has changed. If you want the callback to fire even on deep mutations, you need to explicitly force the watcher into deep mode with\n{ deep: true }\n. Note in deep mode, the new value and the old will be the same object if the callback was triggered by a deep mutation:jsconst state = reactive({ count: 0 }) watch( () => state, (newValue, oldValue) => { // newValue === oldValue }, { deep: true } )\nWhen directly watching a reactive object, the watcher is automatically in deep mode:\njsconst state = reactive({ count: 0 }) watch(state, () => { /* triggers on deep mutation to state */ })\nwatch()\nshares the same flush timing and debugging options withwatchEffect()\n:jswatch(source, callback, { flush: 'post', onTrack(e) { debugger }, onTrigger(e) { debugger } })\nStopping the watcher:\njsconst stop = watch(source, callback) // when the watcher is no longer needed: stop()\nSide effect cleanup:\njswatch(id, async (newId, oldId, onCleanup) => { const { response, cancel } = doAsyncWork(newId) // `cancel` will be called if `id` changes, cancelling // the previous request if it hasn't completed yet onCleanup(cancel) data.value = await response })\nSee also",
    "metadata": {
      "source": "https://vuejs.org/api/reactivity-core",
      "title": "Reactivity API: Core | Vue.js"
    }
  },
  {
    "page_content": "Options: Composition\nprovide\nProvide values that can be injected by descendant components.\nType\ntsinterface ComponentOptions { provide?: object | ((this: ComponentPublicInstance) => object) }\nDetails\nprovide\nandinject\nare used together to allow an ancestor component to serve as a dependency injector for all its descendants, regardless of how deep the component hierarchy is, as long as they are in the same parent chain.The\nprovide\noption should be either an object or a function that returns an object. This object contains the properties that are available for injection into its descendants. You can use Symbols as keys in this object.Example\nBasic usage:\njsconst s = Symbol() export default { provide: { foo: 'foo', [s]: 'bar' } }\nUsing a function to provide per-component state:\njsexport default { data() { return { msg: 'foo' } } provide() { return { msg: this.msg } } }\nNote in the above example, the provided\nmsg\nwill NOT be reactive. See Working with Reactivity for more details.See also Provide / Inject\ninject\nDeclare properties to inject into the current component by locating them from ancestor providers.\nType\ntsinterface ComponentOptions { inject?: ArrayInjectOptions | ObjectInjectOptions } type ArrayInjectOptions = string[] type ObjectInjectOptions = { [key: string | symbol]: | string | symbol | { from?: string | symbol; default?: any } }\nDetails\nThe\ninject\noption should be either:- An array of strings, or\n- An object where the keys are the local binding name and the value is either:\n- The key (string or Symbol) to search for in available injections, or\n- An object where:\n- The\nfrom\nproperty is the key (string or Symbol) to search for in available injections, and - The\ndefault\nproperty is used as fallback value. Similar to props default values, a factory function is needed for object types to avoid value sharing between multiple component instances.\n- The\nAn injected property will be\nundefined\nif neither a matching property nor a default value was provided.Note that injected bindings are NOT reactive. This is intentional. However, if the injected value is a reactive object, properties on that object do remain reactive. See Working with Reactivity for more details.\nExample\nBasic usage:\njsexport default { inject: ['foo'], created() { console.log(this.foo) } }\nUsing an injected value as the default for a prop:\njsconst Child = { inject: ['foo'], props: { bar: { default() { return this.foo } } } }\nUsing an injected value as data entry:\njsconst Child = { inject: ['foo'], data() { return { bar: this.foo } } }\nInjections can be optional with default value:\njsconst Child = { inject: { foo: { default: 'foo' } } }\nIf it needs to be injected from a property with a different name, use\nfrom\nto denote the source property:jsconst Child = { inject: { foo: { from: 'bar', default: 'foo' } } }\nSimilar to prop defaults, you need to use a factory function for non-primitive values:\njsconst Child = { inject: { foo: { from: 'bar', default: () => [1, 2, 3] } } }\nSee also Provide / Inject\nmixins\nAn array of option objects to be mixed into the current component.\nType\ntsinterface ComponentOptions { mixins?: ComponentOptions[] }\nDetails\nThe\nmixins\noption accepts an array of mixin objects. These mixin objects can contain instance options like normal instance objects, and they will be merged against the eventual options using the certain option merging logic. For example, if your mixin contains acreated\nhook and the component itself also has one, both functions will be called.Mixin hooks are called in the order they are provided, and called before the component's own hooks.\nNo Longer Recommended\nIn Vue 2, mixins were the primary mechanism for creating reusable chunks of component logic. While mixins continue to be supported in Vue 3, Composable functions using Composition API is now the preferred approach for code reuse between components.\nExample\njsconst mixin = { created() { console.log(1) } } createApp({ created() { console.log(2) }, mixins: [mixin] }) // => 1 // => 2\nextends\nA \"base class\" component to extend from.\nType\ntsinterface ComponentOptions { extends?: ComponentOptions }\nDetails\nAllows one component to extend another, inheriting its component options.\nFrom an implementation perspective,\nextends\nis almost identical tomixins\n. The component specified byextends\nwill be treated as though it were the first mixin.However,\nextends\nandmixins\nexpress different intents. Themixins\noption is primarily used to compose chunks of functionality, whereasextends\nis primarily concerned with inheritance.As with\nmixins\n, any options (except forsetup()\n) will be merged using the relevant merge strategy.Example\njsconst CompA = { ... } const CompB = { extends: CompA, ... }\nNot Recommended for Composition API\nextends\nis designed for Options API and does not handle the merging of thesetup()\nhook.In Composition API, the preferred mental model for logic reuse is \"compose\" over \"inheritance\". If you have logic from a component that needs to be reused in another one, consider extracting the relevant logic into a Composable.\nIf you still intend to \"extend\" a component using Composition API, you can call the base component's\nsetup()\nin the extending component'ssetup()\n:jsimport Base from './Base.js' export default { extends: Base, setup(props, ctx) { return { ...Base.setup(props, ctx), // local bindings } } }",
    "metadata": {
      "source": "https://vuejs.org/api/options-composition",
      "title": "Options: Composition | Vue.js"
    }
  },
  {
    "page_content": "Production Error Code Reference\nRuntime Errors\nIn production builds, the 3rd argument passed to the following error handler APIs will be a short code instead of the full information string:\napp.config.errorHandler\nonErrorCaptured\n(Composition API)errorCaptured\n(Options API)\nThe following table maps the codes to their original full information strings.\nCode | Message |\n---|---|\n0 | setup function |\n1 | render function |\n2 | watcher getter |\n3 | watcher callback |\n4 | watcher cleanup function |\n5 | native event handler |\n6 | component event handler |\n7 | vnode hook |\n8 | directive hook |\n9 | transition hook |\n10 | app errorHandler |\n11 | app warnHandler |\n12 | ref function |\n13 | async component loader |\n14 | scheduler flush |\n15 | component update |\nsp | serverPrefetch hook |\nbc | beforeCreate hook |\nc | created hook |\nbm | beforeMount hook |\nm | mounted hook |\nbu | beforeUpdate hook |\nu | updated |\nbum | beforeUnmount hook |\num | unmounted hook |\na | activated hook |\nda | deactivated hook |\nec | errorCaptured hook |\nrtc | renderTracked hook |\nrtg | renderTriggered hook |\nCompiler Errors\nThe following table provides a mapping of the production compiler error codes to their original messages.\nCode | Message |\n---|---|\n0 | Illegal comment. |\n1 | CDATA section is allowed only in XML context. |\n2 | Duplicate attribute. |\n3 | End tag cannot have attributes. |\n4 | Illegal '/' in tags. |\n5 | Unexpected EOF in tag. |\n6 | Unexpected EOF in CDATA section. |\n7 | Unexpected EOF in comment. |\n8 | Unexpected EOF in script. |\n9 | Unexpected EOF in tag. |\n10 | Incorrectly closed comment. |\n11 | Incorrectly opened comment. |\n12 | Illegal tag name. Use '<' to print '<'. |\n13 | Attribute value was expected. |\n14 | End tag name was expected. |\n15 | Whitespace was expected. |\n16 | Unexpected '<!--' in comment. |\n17 | Attribute name cannot contain U+0022 (\"), U+0027 ('), and U+003C (<). |\n18 | Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`). |\n19 | Attribute name cannot start with '='. |\n20 | Unexpected null character. |\n21 | '<?' is allowed only in XML context. |\n22 | Illegal '/' in tags. |\n23 | Invalid end tag. |\n24 | Element is missing end tag. |\n25 | Interpolation end sign was not found. |\n26 | Legal directive name was expected. |\n27 | End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces. |\n28 | v-if/v-else-if is missing expression. |\n29 | v-if/else branches must use unique keys. |\n30 | v-else/v-else-if has no adjacent v-if or v-else-if. |\n31 | v-for is missing expression. |\n32 | v-for has invalid expression. |\n33 | <template v-for> key should be placed on the <template> tag. |\n34 | v-bind is missing expression. |\n35 | v-on is missing expression. |\n36 | Unexpected custom directive on <slot> outlet. |\n37 | Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity. |\n38 | Duplicate slot names found. |\n39 | Extraneous children found when component already has explicitly named default slot. These children will be ignored. |\n40 | v-slot can only be used on components or <template> tags. |\n41 | v-model is missing expression. |\n42 | v-model value must be a valid JavaScript member expression. |\n43 | v-model cannot be used on v-for or v-slot scope variables because they are not writable. |\n44 | v-model cannot be used on a prop, because local prop bindings are not writable. Use a v-bind binding combined with a v-on listener that emits update:x event instead. |\n45 | Error parsing JavaScript expression: |\n46 | <KeepAlive> expects exactly one child component. |\n47 | \"prefixIdentifiers\" option is not supported in this build of compiler. |\n48 | ES module mode is not supported in this build of compiler. |\n49 | \"cacheHandlers\" option is only supported when the \"prefixIdentifiers\" option is enabled. |\n50 | \"scopeId\" option is only supported in module mode. |\n51 | @vnode-* hooks in templates are no longer supported. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support has been removed in 3.4. |\n52 | v-bind with same-name shorthand only allows static argument. |\n53 | v-html is missing expression. |\n54 | v-html will override element children. |\n55 | v-text is missing expression. |\n56 | v-text will override element children. |\n57 | v-model can only be used on <input>, <textarea> and <select> elements. |\n58 | v-model argument is not supported on plain elements. |\n59 | v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead. |\n60 | Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior. |\n61 | v-show is missing expression. |\n62 | <Transition> expects exactly one child element or component. |\n63 | Tags with side effect (<script> and <style>) are ignored in client component templates. |",
    "metadata": {
      "source": "https://vuejs.org/error-reference/",
      "title": "Production Error Code Reference | Vue.js"
    }
  },
  {
    "page_content": "Skip to content\nVue.js\nSearch\nMain Navigation\nDocs\nGuide\nTutorial\nExamples\nQuick Start\nGlossary\nError Reference\nVue 2 Docs\nMigration from Vue 2\nAPI\nPlayground\nEcosystem\nResources\nPartners\nThemes\nUI Components\nCertification\nJobs\nT-Shirt Shop\nOfficial Libraries\nVue Router\nPinia\nTooling Guide\nVideo Courses\nVue Mastery\nVue School\nHelp\nDiscord Chat\nGitHub Discussions\nDEV Community\nNews\nBlog\nTwitter\nEvents\nNewsletters\nAbout\nFAQ\nTeam\nReleases\nCommunity Guide\nCode of Conduct\nPrivacy Policy\nThe Documentary\nSponsor\nPartners\n简体中文\n日本語\nУкраїнська\nFrançais\n한국어\nPortuguês\nবাংলা\nItaliano\nفارسی\nРусский\nČeština\n繁體中文\nHelp Us Translate!\ngithub\ntwitter\ndiscord\nAppearance\ngithub\ntwitter\ndiscord\nMenu\nExamples has loaded",
    "metadata": {
      "source": "https://vuejs.org/examples/",
      "title": "Examples | Vue.js"
    }
  },
  {
    "page_content": "Compile-Time Flags\nTIP\nCompile-time flags only apply when using the esm-bundler\nbuild of Vue (i.e. vue/dist/vue.esm-bundler.js\n).\nWhen using Vue with a build step, it is possible to configure a number of compile-time flags to enable / disable certain features. The benefit of using compile-time flags is that features disabled this way can be removed from the final bundle via tree-shaking.\nVue will work even if these flags are not explicitly configured. However, it is recommended to always configure them so that the relevant features can be properly removed when possible.\nSee Configuration Guides on how to configure them depending on your build tool.\n__VUE_OPTIONS_API__\nDefault:\ntrue\nEnable / disable Options API support. Disabling this will result in smaller bundles, but may affect compatibility with 3rd party libraries if they rely on Options API.\n__VUE_PROD_DEVTOOLS__\nDefault:\nfalse\nEnable / disable devtools support in production builds. This will result in more code included in the bundle, so it is recommended to only enable this for debugging purposes.\n__VUE_PROD_HYDRATION_MISMATCH_DETAILS__\nDefault:\nfalse\nEnable/disable detailed warnings for hydration mismatches in production builds. This will result in more code included in the bundle, so it is recommended to only enable this for debugging purposes.\nConfiguration Guides\nVite\n@vitejs/plugin-vue\nautomatically provides default values for these flags. To change the default values, use Vite's define\nconfig option:\njs\n// vite.config.js\nimport { defineConfig } from 'vite'\nexport default defineConfig({\ndefine: {\n// enable hydration mismatch details in production build\n__VUE_PROD_HYDRATION_MISMATCH_DETAILS__: 'true'\n}\n})\nvue-cli\n@vue/cli-service\nautomatically provides default values for some of these flags. To configure /change the values:\njs\n// vue.config.js\nmodule.exports = {\nchainWebpack: (config) => {\nconfig.plugin('define').tap((definitions) => {\nObject.assign(definitions[0], {\n__VUE_OPTIONS_API__: 'true',\n__VUE_PROD_DEVTOOLS__: 'false',\n__VUE_PROD_HYDRATION_MISMATCH_DETAILS__: 'false'\n})\nreturn definitions\n})\n}\n}\nwebpack\nFlags should be defined using webpack's DefinePlugin:\njs\n// webpack.config.js\nmodule.exports = {\n// ...\nplugins: [\nnew webpack.DefinePlugin({\n__VUE_OPTIONS_API__: 'true',\n__VUE_PROD_DEVTOOLS__: 'false',\n__VUE_PROD_HYDRATION_MISMATCH_DETAILS__: 'false'\n})\n]\n}\nRollup\nFlags should be defined using @rollup/plugin-replace:\njs\n// rollup.config.js\nimport replace from '@rollup/plugin-replace'\nexport default {\nplugins: [\nreplace({\n__VUE_OPTIONS_API__: 'true',\n__VUE_PROD_DEVTOOLS__: 'false',\n__VUE_PROD_HYDRATION_MISMATCH_DETAILS__: 'false'\n})\n]\n}",
    "metadata": {
      "source": "https://vuejs.org/api/compile-time-flags",
      "title": "Compile-Time Flags | Vue.js"
    }
  },
  {
    "page_content": "Render Function APIs\nh()\nCreates virtual DOM nodes (vnodes).\nType\nts// full signature function h( type: string | Component, props?: object | null, children?: Children | Slot | Slots ): VNode // omitting props function h(type: string | Component, children?: Children | Slot): VNode type Children = string | number | boolean | VNode | null | Children[] type Slot = () => Children type Slots = { [name: string]: Slot }\nTypes are simplified for readability.\nDetails\nThe first argument can either be a string (for native elements) or a Vue component definition. The second argument is the props to be passed, and the third argument is the children.\nWhen creating a component vnode, the children must be passed as slot functions. A single slot function can be passed if the component expects only the default slot. Otherwise, the slots must be passed as an object of slot functions.\nFor convenience, the props argument can be omitted when the children is not a slots object.\nExample\nCreating native elements:\njsimport { h } from 'vue' // all arguments except the type are optional h('div') h('div', { id: 'foo' }) // both attributes and properties can be used in props // Vue automatically picks the right way to assign it h('div', { class: 'bar', innerHTML: 'hello' }) // class and style have the same object / array // value support like in templates h('div', { class: [foo, { bar }], style: { color: 'red' } }) // event listeners should be passed as onXxx h('div', { onClick: () => {} }) // children can be a string h('div', { id: 'foo' }, 'hello') // props can be omitted when there are no props h('div', 'hello') h('div', [h('span', 'hello')]) // children array can contain mixed vnodes and strings h('div', ['hello', h('span', 'hello')])\nCreating components:\njsimport Foo from './Foo.vue' // passing props h(Foo, { // equivalent of some-prop=\"hello\" someProp: 'hello', // equivalent of @update=\"() => {}\" onUpdate: () => {} }) // passing single default slot h(Foo, () => 'default slot') // passing named slots // notice the `null` is required to avoid // slots object being treated as props h(MyComponent, null, { default: () => 'default slot', foo: () => h('div', 'foo'), bar: () => [h('span', 'one'), h('span', 'two')] })\nmergeProps()\nMerge multiple props objects with special handling for certain props.\nType\ntsfunction mergeProps(...args: object[]): object\nDetails\nmergeProps()\nsupports merging multiple props objects with special handling for the following props:class\nstyle\nonXxx\nevent listeners - multiple listeners with the same name will be merged into an array.\nIf you do not need the merge behavior and want simple overwrites, native object spread can be used instead.\nExample\njsimport { mergeProps } from 'vue' const one = { class: 'foo', onClick: handlerA } const two = { class: { bar: true }, onClick: handlerB } const merged = mergeProps(one, two) /** { class: 'foo bar', onClick: [handlerA, handlerB] } */\ncloneVNode()\nClones a vnode.\nType\ntsfunction cloneVNode(vnode: VNode, extraProps?: object): VNode\nDetails\nReturns a cloned vnode, optionally with extra props to merge with the original.\nVnodes should be considered immutable once created, and you should not mutate the props of an existing vnode. Instead, clone it with different / extra props.\nVnodes have special internal properties, so cloning them is not as simple as an object spread.\ncloneVNode()\nhandles most of the internal logic.Example\njsimport { h, cloneVNode } from 'vue' const original = h('div') const cloned = cloneVNode(original, { id: 'foo' })\nisVNode()\nChecks if a value is a vnode.\nType\ntsfunction isVNode(value: unknown): boolean\nresolveComponent()\nFor manually resolving a registered component by name.\nType\ntsfunction resolveComponent(name: string): Component | string\nDetails\nNote: you do not need this if you can import the component directly.\nresolveComponent()\nmust be called inside eithersetup()\nor the render function in order to resolve from the correct component context.If the component is not found, a runtime warning will be emitted, and the name string is returned.\nExample\njsimport { h, resolveComponent } from 'vue' export default { setup() { const ButtonCounter = resolveComponent('ButtonCounter') return () => { return h(ButtonCounter) } } }\nresolveDirective()\nFor manually resolving a registered directive by name.\nType\ntsfunction resolveDirective(name: string): Directive | undefined\nDetails\nNote: you do not need this if you can import the directive directly.\nresolveDirective()\nmust be called inside eithersetup()\nor the render function in order to resolve from the correct component context.If the directive is not found, a runtime warning will be emitted, and the function returns\nundefined\n.\nwithDirectives()\nFor adding custom directives to vnodes.\nType\ntsfunction withDirectives( vnode: VNode, directives: DirectiveArguments ): VNode // [Directive, value, argument, modifiers] type DirectiveArguments = Array< | [Directive] | [Directive, any] | [Directive, any, string] | [Directive, any, string, DirectiveModifiers] >\nDetails\nWraps an existing vnode with custom directives. The second argument is an array of custom directives. Each custom directive is also represented as an array in the form of\n[Directive, value, argument, modifiers]\n. Tailing elements of the array can be omitted if not needed.Example\njsimport { h, withDirectives } from 'vue' // a custom directive const pin = { mounted() { /* ... */ }, updated() { /* ... */ } } // <div v-pin:top.animate=\"200\"></div> const vnode = withDirectives(h('div'), [ [pin, 200, 'top', { animate: true }] ])\nwithModifiers()\nFor adding built-in v-on\nmodifiers to an event handler function.\nType\ntsfunction withModifiers(fn: Function, modifiers: ModifierGuardsKeys[]): Function\nExample\njsimport { h, withModifiers } from 'vue' const vnode = h('button', { // equivalent of v-on:click.stop.prevent onClick: withModifiers(() => { // ... }, ['stop', 'prevent']) })",
    "metadata": {
      "source": "https://vuejs.org/api/render-function",
      "title": "Render Function APIs | Vue.js"
    }
  },
  {
    "page_content": "Built-in Directives\nv-text\nUpdate the element's text content.\nExpects:\nstring\nDetails\nv-text\nworks by setting the element's textContent property, so it will overwrite any existing content inside the element. If you need to update the part oftextContent\n, you should use mustache interpolations instead.Example\ntemplate<span v-text=\"msg\"></span> <!-- same as --> <span>{{msg}}</span>\nSee also Template Syntax - Text Interpolation\nv-html\nUpdate the element's innerHTML.\nExpects:\nstring\nDetails\nContents of\nv-html\nare inserted as plain HTML - Vue template syntax will not be processed. If you find yourself trying to compose templates usingv-html\n, try to rethink the solution by using components instead.Security Note\nDynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to XSS attacks. Only use\nv-html\non trusted content and never on user-provided content.In Single-File Components,\nscoped\nstyles will not apply to content insidev-html\n, because that HTML is not processed by Vue's template compiler. If you want to targetv-html\ncontent with scoped CSS, you can instead use CSS modules or an additional, global<style>\nelement with a manual scoping strategy such as BEM.Example\ntemplate<div v-html=\"html\"></div>\nSee also Template Syntax - Raw HTML\nv-show\nToggle the element's visibility based on the truthy-ness of the expression value.\nExpects:\nany\nDetails\nv-show\nworks by setting thedisplay\nCSS property via inline styles, and will try to respect the initialdisplay\nvalue when the element is visible. It also triggers transitions when its condition changes.See also Conditional Rendering - v-show\nv-if\nConditionally render an element or a template fragment based on the truthy-ness of the expression value.\nExpects:\nany\nDetails\nWhen a\nv-if\nelement is toggled, the element and its contained directives / components are destroyed and re-constructed. If the initial condition is falsy, then the inner content won't be rendered at all.Can be used on\n<template>\nto denote a conditional block containing only text or multiple elements.This directive triggers transitions when its condition changes.\nWhen used together,\nv-if\nhas a higher priority thanv-for\n. We don't recommend using these two directives together on one element — see the list rendering guide for details.See also Conditional Rendering - v-if\nv-else\nDenote the \"else block\" for v-if\nor a v-if\n/ v-else-if\nchain.\nDoes not expect expression\nDetails\nRestriction: previous sibling element must have\nv-if\norv-else-if\n.Can be used on\n<template>\nto denote a conditional block containing only text or multiple elements.\nExample\ntemplate<div v-if=\"Math.random() > 0.5\"> Now you see me </div> <div v-else> Now you don't </div>\nSee also Conditional Rendering - v-else\nv-else-if\nDenote the \"else if block\" for v-if\n. Can be chained.\nExpects:\nany\nDetails\nRestriction: previous sibling element must have\nv-if\norv-else-if\n.Can be used on\n<template>\nto denote a conditional block containing only text or multiple elements.\nExample\ntemplate<div v-if=\"type === 'A'\"> A </div> <div v-else-if=\"type === 'B'\"> B </div> <div v-else-if=\"type === 'C'\"> C </div> <div v-else> Not A/B/C </div>\nSee also Conditional Rendering - v-else-if\nv-for\nRender the element or template block multiple times based on the source data.\nExpects:\nArray | Object | number | string | Iterable\nDetails\nThe directive's value must use the special syntax\nalias in expression\nto provide an alias for the current element being iterated on:template<div v-for=\"item in items\"> {{ item.text }} </div>\nAlternatively, you can also specify an alias for the index (or the key if used on an Object):\ntemplate<div v-for=\"(item, index) in items\"></div> <div v-for=\"(value, key) in object\"></div> <div v-for=\"(value, name, index) in object\"></div>\nThe default behavior of\nv-for\nwill try to patch the elements in-place without moving them. To force it to reorder elements, you should provide an ordering hint with thekey\nspecial attribute:template<div v-for=\"item in items\" :key=\"item.id\"> {{ item.text }} </div>\nv-for\ncan also work on values that implement the Iterable Protocol, including nativeMap\nandSet\n.See also\nv-on\nAttach an event listener to the element.\nShorthand:\n@\nExpects:\nFunction | Inline Statement | Object (without argument)\nArgument:\nevent\n(optional if using Object syntax)Modifiers\n.stop\n- callevent.stopPropagation()\n..prevent\n- callevent.preventDefault()\n..capture\n- add event listener in capture mode..self\n- only trigger handler if event was dispatched from this element..{keyAlias}\n- only trigger handler on certain keys..once\n- trigger handler at most once..left\n- only trigger handler for left button mouse events..right\n- only trigger handler for right button mouse events..middle\n- only trigger handler for middle button mouse events..passive\n- attaches a DOM event with{ passive: true }\n.\nDetails\nThe event type is denoted by the argument. The expression can be a method name, an inline statement, or omitted if there are modifiers present.\nWhen used on a normal element, it listens to native DOM events only. When used on a custom element component, it listens to custom events emitted on that child component.\nWhen listening to native DOM events, the method receives the native event as the only argument. If using inline statement, the statement has access to the special\n$event\nproperty:v-on:click=\"handle('ok', $event)\"\n.v-on\nalso supports binding to an object of event / listener pairs without an argument. Note when using the object syntax, it does not support any modifiers.Example\ntemplate<!-- method handler --> <button v-on:click=\"doThis\"></button> <!-- dynamic event --> <button v-on:[event]=\"doThis\"></button> <!-- inline statement --> <button v-on:click=\"doThat('hello', $event)\"></button> <!-- shorthand --> <button @click=\"doThis\"></button> <!-- shorthand dynamic event --> <button @[event]=\"doThis\"></button> <!-- stop propagation --> <button @click.stop=\"doThis\"></button> <!-- prevent default --> <button @click.prevent=\"doThis\"></button> <!-- prevent default without expression --> <form @submit.prevent></form> <!-- chain modifiers --> <button @click.stop.prevent=\"doThis\"></button> <!-- key modifier using keyAlias --> <input @keyup.enter=\"onEnter\" /> <!-- the click event will be triggered at most once --> <button v-on:click.once=\"doThis\"></button> <!-- object syntax --> <button v-on=\"{ mousedown: doThis, mouseup: doThat }\"></button>\nListening to custom events on a child component (the handler is called when \"my-event\" is emitted on the child):\ntemplate<MyComponent @my-event=\"handleThis\" /> <!-- inline statement --> <MyComponent @my-event=\"handleThis(123, $event)\" />\nSee also\nv-bind\nDynamically bind one or more attributes, or a component prop to an expression.\nShorthand:\n:\nor.\n(when using.prop\nmodifier)- Omitting value (when attribute and bound value has the same name) 3.4+\nExpects:\nany (with argument) | Object (without argument)\nArgument:\nattrOrProp (optional)\nModifiers\n.camel\n- transform the kebab-case attribute name into camelCase..prop\n- force a binding to be set as a DOM property. 3.2+.attr\n- force a binding to be set as a DOM attribute. 3.2+\nUsage\nWhen used to bind the\nclass\norstyle\nattribute,v-bind\nsupports additional value types such as Array or Objects. See linked guide section below for more details.When setting a binding on an element, Vue by default checks whether the element has the key defined as a property using an\nin\noperator check. If the property is defined, Vue will set the value as a DOM property instead of an attribute. This should work in most cases, but you can override this behavior by explicitly using.prop\nor.attr\nmodifiers. This is sometimes necessary, especially when working with custom elements.When used for component prop binding, the prop must be properly declared in the child component.\nWhen used without an argument, can be used to bind an object containing attribute name-value pairs.\nExample\ntemplate<!-- bind an attribute --> <img v-bind:src=\"imageSrc\" /> <!-- dynamic attribute name --> <button v-bind:[key]=\"value\"></button> <!-- shorthand --> <img :src=\"imageSrc\" /> <!-- same-name shorthand (3.4+), expands to :src=\"src\" --> <img :src /> <!-- shorthand dynamic attribute name --> <button :[key]=\"value\"></button> <!-- with inline string concatenation --> <img :src=\"'/path/to/images/' + fileName\" /> <!-- class binding --> <div :class=\"{ red: isRed }\"></div> <div :class=\"[classA, classB]\"></div> <div :class=\"[classA, { classB: isB, classC: isC }]\"></div> <!-- style binding --> <div :style=\"{ fontSize: size + 'px' }\"></div> <div :style=\"[styleObjectA, styleObjectB]\"></div> <!-- binding an object of attributes --> <div v-bind=\"{ id: someProp, 'other-attr': otherProp }\"></div> <!-- prop binding. \"prop\" must be declared in the child component. --> <MyComponent :prop=\"someThing\" /> <!-- pass down parent props in common with a child component --> <MyComponent v-bind=\"$props\" /> <!-- XLink --> <svg><a :xlink:special=\"foo\"></a></svg>\nThe\n.prop\nmodifier also has a dedicated shorthand,.\n:template<div :someProperty.prop=\"someObject\"></div> <!-- equivalent to --> <div .someProperty=\"someObject\"></div>\nThe\n.camel\nmodifier allows camelizing av-bind\nattribute name when using in-DOM templates, e.g. the SVGviewBox\nattribute:template<svg :view-box.camel=\"viewBox\"></svg>\n.camel\nis not needed if you are using string templates, or pre-compiling the template with a build step.See also\nv-model\nCreate a two-way binding on a form input element or a component.\nExpects: varies based on value of form inputs element or output of components\nLimited to:\n<input>\n<select>\n<textarea>\n- components\nModifiers\nSee also\nv-slot\nDenote named slots or scoped slots that expect to receive props.\nShorthand:\n#\nExpects: JavaScript expression that is valid in a function argument position, including support for destructuring. Optional - only needed if expecting props to be passed to the slot.\nArgument: slot name (optional, defaults to\ndefault\n)Limited to:\n<template>\n- components (for a lone default slot with props)\nExample\ntemplate<!-- Named slots --> <BaseLayout> <template v-slot:header> Header content </template> <template v-slot:default> Default slot content </template> <template v-slot:footer> Footer content </template> </BaseLayout> <!-- Named slot that receives props --> <InfiniteScroll> <template v-slot:item=\"slotProps\"> <div class=\"item\"> {{ slotProps.item.text }} </div> </template> </InfiniteScroll> <!-- Default slot that receive props, with destructuring --> <Mouse v-slot=\"{ x, y }\"> Mouse position: {{ x }}, {{ y }} </Mouse>\nSee also\nv-pre\nSkip compilation for this element and all its children.\nDoes not expect expression\nDetails\nInside the element with\nv-pre\n, all Vue template syntax will be preserved and rendered as-is. The most common use case of this is displaying raw mustache tags.Example\ntemplate<span v-pre>{{ this will not be compiled }}</span>\nv-once\nRender the element and component once only, and skip future updates.\nDoes not expect expression\nDetails\nOn subsequent re-renders, the element/component and all its children will be treated as static content and skipped. This can be used to optimize update performance.\ntemplate<!-- single element --> <span v-once>This will never change: {{msg}}</span> <!-- the element have children --> <div v-once> <h1>Comment</h1> <p>{{msg}}</p> </div> <!-- component --> <MyComponent v-once :comment=\"msg\"></MyComponent> <!-- `v-for` directive --> <ul> <li v-for=\"i in list\" v-once>{{i}}</li> </ul>\nSince 3.2, you can also memoize part of the template with invalidation conditions using\nv-memo\n.See also\nv-memo\nExpects:\nany[]\nDetails\nMemoize a sub-tree of the template. Can be used on both elements and components. The directive expects a fixed-length array of dependency values to compare for the memoization. If every value in the array was the same as last render, then updates for the entire sub-tree will be skipped. For example:\ntemplate<div v-memo=\"[valueA, valueB]\"> ... </div>\nWhen the component re-renders, if both\nvalueA\nandvalueB\nremain the same, all updates for this<div>\nand its children will be skipped. In fact, even the Virtual DOM VNode creation will also be skipped since the memoized copy of the sub-tree can be reused.It is important to specify the memoization array correctly, otherwise we may skip updates that should indeed be applied.\nv-memo\nwith an empty dependency array (v-memo=\"[]\"\n) would be functionally equivalent tov-once\n.Usage with\nv-for\nv-memo\nis provided solely for micro optimizations in performance-critical scenarios and should be rarely needed. The most common case where this may prove helpful is when rendering largev-for\nlists (wherelength > 1000\n):template<div v-for=\"item in list\" :key=\"item.id\" v-memo=\"[item.id === selected]\"> <p>ID: {{ item.id }} - selected: {{ item.id === selected }}</p> <p>...more child nodes</p> </div>\nWhen the component's\nselected\nstate changes, a large amount of VNodes will be created even though most of the items remained exactly the same. Thev-memo\nusage here is essentially saying \"only update this item if it went from non-selected to selected, or the other way around\". This allows every unaffected item to reuse its previous VNode and skip diffing entirely. Note we don't need to includeitem.id\nin the memo dependency array here since Vue automatically infers it from the item's:key\n.WARNING\nWhen using\nv-memo\nwithv-for\n, make sure they are used on the same element.v-memo\ndoes not work insidev-for\n.v-memo\ncan also be used on components to manually prevent unwanted updates in certain edge cases where the child component update check has been de-optimized. But again, it is the developer's responsibility to specify correct dependency arrays to avoid skipping necessary updates.See also\nv-cloak\nUsed to hide un-compiled template until it is ready.\nDoes not expect expression\nDetails\nThis directive is only needed in no-build-step setups.\nWhen using in-DOM templates, there can be a \"flash of un-compiled templates\": the user may see raw mustache tags until the mounted component replaces them with rendered content.\nv-cloak\nwill remain on the element until the associated component instance is mounted. Combined with CSS rules such as[v-cloak] { display: none }\n, it can be used to hide the raw templates until the component is ready.Example\ncss[v-cloak] { display: none; }\ntemplate<div v-cloak> {{ message }} </div>\nThe\n<div>\nwill not be visible until the compilation is done.",
    "metadata": {
      "source": "https://vuejs.org/api/built-in-directives",
      "title": "Built-in Directives | Vue.js"
    }
  },
  {
    "page_content": "Built-in Special Elements\nNot Components\n<component>\n, <slot>\nand <template>\nare component-like features and part of the template syntax. They are not true components and are compiled away during template compilation. As such, they are conventionally written with lowercase in templates.\n<component>\nA \"meta component\" for rendering dynamic components or elements.\nProps\ntsinterface DynamicComponentProps { is: string | Component }\nDetails\nThe actual component to render is determined by the\nis\nprop.When\nis\nis a string, it could be either an HTML tag name or a component's registered name.Alternatively,\nis\ncan also be directly bound to the definition of a component.\nExample\nRendering components by registered name (Options API):\nvue<script> import Foo from './Foo.vue' import Bar from './Bar.vue' export default { components: { Foo, Bar }, data() { return { view: 'Foo' } } } </script> <template> <component :is=\"view\" /> </template>\nRendering components by definition (Composition API with\n<script setup>\n):vue<script setup> import Foo from './Foo.vue' import Bar from './Bar.vue' </script> <template> <component :is=\"Math.random() > 0.5 ? Foo : Bar\" /> </template>\nRendering HTML elements:\ntemplate<component :is=\"href ? 'a' : 'span'\"></component>\nThe built-in components can all be passed to\nis\n, but you must register them if you want to pass them by name. For example:vue<script> import { Transition, TransitionGroup } from 'vue' export default { components: { Transition, TransitionGroup } } </script> <template> <component :is=\"isGroup ? 'TransitionGroup' : 'Transition'\"> ... </component> </template>\nRegistration is not required if you pass the component itself to\nis\nrather than its name, e.g. in<script setup>\n.If\nv-model\nis used on a<component>\ntag, the template compiler will expand it to amodelValue\nprop andupdate:modelValue\nevent listener, much like it would for any other component. However, this won't be compatible with native HTML elements, such as<input>\nor<select>\n. As a result, usingv-model\nwith a dynamically created native element won't work:vue<script setup> import { ref } from 'vue' const tag = ref('input') const username = ref('') </script> <template> <!-- This won't work as 'input' is a native HTML element --> <component :is=\"tag\" v-model=\"username\" /> </template>\nIn practice, this edge case isn't common as native form fields are typically wrapped in components in real applications. If you do need to use a native element directly then you can split the\nv-model\ninto an attribute and event manually.See also Dynamic Components\n<slot>\nDenotes slot content outlets in templates.\nProps\ntsinterface SlotProps { /** * Any props passed to <slot> to passed as arguments * for scoped slots */ [key: string]: any /** * Reserved for specifying slot name. */ name?: string }\nDetails\nThe\n<slot>\nelement can use thename\nattribute to specify a slot name. When noname\nis specified, it will render the default slot. Additional attributes passed to the slot element will be passed as slot props to the scoped slot defined in the parent.The element itself will be replaced by its matched slot content.\n<slot>\nelements in Vue templates are compiled into JavaScript, so they are not to be confused with native<slot>\nelements.See also Component - Slots\n<template>\nThe <template>\ntag is used as a placeholder when we want to use a built-in directive without rendering an element in the DOM.\nDetails\nThe special handling for\n<template>\nis only triggered if it is used with one of these directives:v-if\n,v-else-if\n, orv-else\nv-for\nv-slot\nIf none of those directives are present then it will be rendered as a native\n<template>\nelement instead.A\n<template>\nwith av-for\ncan also have akey\nattribute. All other attributes and directives will be discarded, as they aren't meaningful without a corresponding element.Single-file components use a top-level\n<template>\ntag to wrap the entire template. That usage is separate from the use of<template>\ndescribed above. That top-level tag is not part of the template itself and doesn't support template syntax, such as directives.See also",
    "metadata": {
      "source": "https://vuejs.org/api/built-in-special-elements",
      "title": "Built-in Special Elements | Vue.js"
    }
  },
  {
    "page_content": "Options: Lifecycle\nSee also\nFor shared usage of lifecycle hooks, see Guide - Lifecycle Hooks\nbeforeCreate\nCalled when the instance is initialized.\nType\ntsinterface ComponentOptions { beforeCreate?(this: ComponentPublicInstance): void }\nDetails\nCalled immediately when the instance is initialized and props are resolved.\nThen the props will be defined as reactive properties and the state such as\ndata()\norcomputed\nwill be set up.Note that the\nsetup()\nhook of Composition API is called before any Options API hooks, evenbeforeCreate()\n.\ncreated\nCalled after the instance has finished processing all state-related options.\nType\ntsinterface ComponentOptions { created?(this: ComponentPublicInstance): void }\nDetails\nWhen this hook is called, the following have been set up: reactive data, computed properties, methods, and watchers. However, the mounting phase has not been started, and the\n$el\nproperty will not be available yet.\nbeforeMount\nCalled right before the component is to be mounted.\nType\ntsinterface ComponentOptions { beforeMount?(this: ComponentPublicInstance): void }\nDetails\nWhen this hook is called, the component has finished setting up its reactive state, but no DOM nodes have been created yet. It is about to execute its DOM render effect for the first time.\nThis hook is not called during server-side rendering.\nmounted\nCalled after the component has been mounted.\nType\ntsinterface ComponentOptions { mounted?(this: ComponentPublicInstance): void }\nDetails\nA component is considered mounted after:\nAll of its synchronous child components have been mounted (does not include async components or components inside\n<Suspense>\ntrees).Its own DOM tree has been created and inserted into the parent container. Note it only guarantees that the component's DOM tree is in-document if the application's root container is also in-document.\nThis hook is typically used for performing side effects that need access to the component's rendered DOM, or for limiting DOM-related code to the client in a server-rendered application.\nThis hook is not called during server-side rendering.\nbeforeUpdate\nCalled right before the component is about to update its DOM tree due to a reactive state change.\nType\ntsinterface ComponentOptions { beforeUpdate?(this: ComponentPublicInstance): void }\nDetails\nThis hook can be used to access the DOM state before Vue updates the DOM. It is also safe to modify component state inside this hook.\nThis hook is not called during server-side rendering.\nupdated\nCalled after the component has updated its DOM tree due to a reactive state change.\nType\ntsinterface ComponentOptions { updated?(this: ComponentPublicInstance): void }\nDetails\nA parent component's updated hook is called after that of its child components.\nThis hook is called after any DOM update of the component, which can be caused by different state changes. If you need to access the updated DOM after a specific state change, use nextTick() instead.\nThis hook is not called during server-side rendering.\nWARNING\nDo not mutate component state in the updated hook - this will likely lead to an infinite update loop!\nbeforeUnmount\nCalled right before a component instance is to be unmounted.\nType\ntsinterface ComponentOptions { beforeUnmount?(this: ComponentPublicInstance): void }\nDetails\nWhen this hook is called, the component instance is still fully functional.\nThis hook is not called during server-side rendering.\nunmounted\nCalled after the component has been unmounted.\nType\ntsinterface ComponentOptions { unmounted?(this: ComponentPublicInstance): void }\nDetails\nA component is considered unmounted after:\nAll of its child components have been unmounted.\nAll of its associated reactive effects (render effect and computed / watchers created during\nsetup()\n) have been stopped.\nUse this hook to clean up manually created side effects such as timers, DOM event listeners or server connections.\nThis hook is not called during server-side rendering.\nerrorCaptured\nCalled when an error propagating from a descendant component has been captured.\nType\ntsinterface ComponentOptions { errorCaptured?( this: ComponentPublicInstance, err: unknown, instance: ComponentPublicInstance | null, info: string ): boolean | void }\nDetails\nErrors can be captured from the following sources:\n- Component renders\n- Event handlers\n- Lifecycle hooks\nsetup()\nfunction- Watchers\n- Custom directive hooks\n- Transition hooks\nThe hook receives three arguments: the error, the component instance that triggered the error, and an information string specifying the error source type.\nTIP\nIn production, the 3rd argument (\ninfo\n) will be a shortened code instead of the full information string. You can find the code to string mapping in the Production Error Code Reference.You can modify component state in\nerrorCaptured()\nto display an error state to the user. However, it is important that the error state should not render the original content that caused the error; otherwise the component will be thrown into an infinite render loop.The hook can return\nfalse\nto stop the error from propagating further. See error propagation details below.Error Propagation Rules\nBy default, all errors are still sent to the application-level\napp.config.errorHandler\nif it is defined, so that these errors can still be reported to an analytics service in a single place.If multiple\nerrorCaptured\nhooks exist on a component's inheritance chain or parent chain, all of them will be invoked on the same error, in the order of bottom to top. This is similar to the bubbling mechanism of native DOM events.If the\nerrorCaptured\nhook itself throws an error, both this error and the original captured error are sent toapp.config.errorHandler\n.An\nerrorCaptured\nhook can returnfalse\nto prevent the error from propagating further. This is essentially saying \"this error has been handled and should be ignored.\" It will prevent any additionalerrorCaptured\nhooks orapp.config.errorHandler\nfrom being invoked for this error.\nrenderTracked\nCalled when a reactive dependency has been tracked by the component's render effect.\nThis hook is development-mode-only and not called during server-side rendering.\nType\ntsinterface ComponentOptions { renderTracked?(this: ComponentPublicInstance, e: DebuggerEvent): void } type DebuggerEvent = { effect: ReactiveEffect target: object type: TrackOpTypes /* 'get' | 'has' | 'iterate' */ key: any }\nSee also Reactivity in Depth\nrenderTriggered\nCalled when a reactive dependency triggers the component's render effect to be re-run.\nThis hook is development-mode-only and not called during server-side rendering.\nType\ntsinterface ComponentOptions { renderTriggered?(this: ComponentPublicInstance, e: DebuggerEvent): void } type DebuggerEvent = { effect: ReactiveEffect target: object type: TriggerOpTypes /* 'set' | 'add' | 'delete' | 'clear' */ key: any newValue?: any oldValue?: any oldTarget?: Map<any, any> | Set<any> }\nSee also Reactivity in Depth\nactivated\nCalled after the component instance is inserted into the DOM as part of a tree cached by <KeepAlive>\n.\nThis hook is not called during server-side rendering.\nType\ntsinterface ComponentOptions { activated?(this: ComponentPublicInstance): void }\nSee also Guide - Lifecycle of Cached Instance\ndeactivated\nCalled after the component instance is removed from the DOM as part of a tree cached by <KeepAlive>\n.\nThis hook is not called during server-side rendering.\nType\ntsinterface ComponentOptions { deactivated?(this: ComponentPublicInstance): void }\nSee also Guide - Lifecycle of Cached Instance\nserverPrefetch\nAsync function to be resolved before the component instance is to be rendered on the server.\nType\ntsinterface ComponentOptions { serverPrefetch?(this: ComponentPublicInstance): Promise<any> }\nDetails\nIf the hook returns a Promise, the server renderer will wait until the Promise is resolved before rendering the component.\nThis hook is only called during server-side rendering can be used to perform server-only data fetching.\nExample\njsexport default { data() { return { data: null } }, async serverPrefetch() { // component is rendered as part of the initial request // pre-fetch data on server as it is faster than on the client this.data = await fetchOnServer(/* ... */) }, async mounted() { if (!this.data) { // if data is null on mount, it means the component // is dynamically rendered on the client. Perform a // client-side fetch instead. this.data = await fetchOnClient(/* ... */) } } }\nSee also Server-Side Rendering",
    "metadata": {
      "source": "https://vuejs.org/api/options-lifecycle",
      "title": "Options: Lifecycle | Vue.js"
    }
  },
  {
    "page_content": "Options: Misc\nname\nExplicitly declare a display name for the component.\nType\ntsinterface ComponentOptions { name?: string }\nDetails\nThe name of a component is used for the following:\n- Recursive self-reference in the component's own template\n- Display in Vue DevTools' component inspection tree\n- Display in warning component traces\nWhen you use Single-File Components, the component already infers its own name from the filename. For example, a file named\nMyComponent.vue\nwill have the inferred display name \"MyComponent\".Another case is that when a component is registered globally with\napp.component\n, the global ID is automatically set as its name.The\nname\noption allows you to override the inferred name, or to explicitly provide a name when no name can be inferred (e.g. when not using build tools, or an inlined non-SFC component).There is one case where\nname\nis explicitly necessary: when matching against cacheable components in<KeepAlive>\nvia itsinclude / exclude\nprops.TIP\nSince version 3.2.34, a single-file component using\n<script setup>\nwill automatically infer itsname\noption based on the filename, removing the need to manually declare the name even when used with<KeepAlive>\n.\ninheritAttrs\nControls whether the default component attribute fallthrough behavior should be enabled.\nType\ntsinterface ComponentOptions { inheritAttrs?: boolean // default: true }\nDetails\nBy default, parent scope attribute bindings that are not recognized as props will \"fallthrough\". This means that when we have a single-root component, these bindings will be applied to the root element of the child component as normal HTML attributes. When authoring a component that wraps a target element or another component, this may not always be the desired behavior. By setting\ninheritAttrs\ntofalse\n, this default behavior can be disabled. The attributes are available via the$attrs\ninstance property and can be explicitly bound to a non-root element usingv-bind\n.Example\nWhen declaring this option in a component that uses\n<script setup>\n, you can use thedefineOptions\nmacro:vue<script setup> defineProps(['label', 'value']) defineEmits(['input']) defineOptions({ inheritAttrs: false }) </script> <template> <label> {{ label }} <input v-bind=\"$attrs\" v-bind:value=\"value\" v-on:input=\"$emit('input', $event.target.value)\" /> </label> </template>\nSee also Fallthrough Attributes\ncomponents\nAn object that registers components to be made available to the component instance.\nType\ntsinterface ComponentOptions { components?: { [key: string]: Component } }\nExample\njsimport Foo from './Foo.vue' import Bar from './Bar.vue' export default { components: { // shorthand Foo, // register under a different name RenamedBar: Bar } }\nSee also Component Registration\ndirectives\nAn object that registers directives to be made available to the component instance.\nType\ntsinterface ComponentOptions { directives?: { [key: string]: Directive } }\nExample\njsexport default { directives: { // enables v-focus in template focus: { mounted(el) { el.focus() } } } }\ntemplate<input v-focus>\nSee also Custom Directives",
    "metadata": {
      "source": "https://vuejs.org/api/options-misc",
      "title": "Options: Misc | Vue.js"
    }
  },
  {
    "page_content": "Composition API: Lifecycle Hooks\nUsage Note\nAll APIs listed on this page must be called synchronously during the setup()\nphase of a component. See Guide - Lifecycle Hooks for more details.\nonMounted()\nRegisters a callback to be called after the component has been mounted.\nType\ntsfunction onMounted(callback: () => void): void\nDetails\nA component is considered mounted after:\nAll of its synchronous child components have been mounted (does not include async components or components inside\n<Suspense>\ntrees).Its own DOM tree has been created and inserted into the parent container. Note it only guarantees that the component's DOM tree is in-document if the application's root container is also in-document.\nThis hook is typically used for performing side effects that need access to the component's rendered DOM, or for limiting DOM-related code to the client in a server-rendered application.\nThis hook is not called during server-side rendering.\nExample\nAccessing an element via template ref:\nvue<script setup> import { ref, onMounted } from 'vue' const el = ref() onMounted(() => { el.value // <div> }) </script> <template> <div ref=\"el\"></div> </template>\nonUpdated()\nRegisters a callback to be called after the component has updated its DOM tree due to a reactive state change.\nType\ntsfunction onUpdated(callback: () => void): void\nDetails\nA parent component's updated hook is called after that of its child components.\nThis hook is called after any DOM update of the component, which can be caused by different state changes, because multiple state changes can be batched into a single render cycle for performance reasons. If you need to access the updated DOM after a specific state change, use nextTick() instead.\nThis hook is not called during server-side rendering.\nWARNING\nDo not mutate component state in the updated hook - this will likely lead to an infinite update loop!\nExample\nAccessing updated DOM:\nvue<script setup> import { ref, onUpdated } from 'vue' const count = ref(0) onUpdated(() => { // text content should be the same as current `count.value` console.log(document.getElementById('count').textContent) }) </script> <template> <button id=\"count\" @click=\"count++\">{{ count }}</button> </template>\nonUnmounted()\nRegisters a callback to be called after the component has been unmounted.\nType\ntsfunction onUnmounted(callback: () => void): void\nDetails\nA component is considered unmounted after:\nAll of its child components have been unmounted.\nAll of its associated reactive effects (render effect and computed / watchers created during\nsetup()\n) have been stopped.\nUse this hook to clean up manually created side effects such as timers, DOM event listeners or server connections.\nThis hook is not called during server-side rendering.\nExample\nvue<script setup> import { onMounted, onUnmounted } from 'vue' let intervalId onMounted(() => { intervalId = setInterval(() => { // ... }) }) onUnmounted(() => clearInterval(intervalId)) </script>\nonBeforeMount()\nRegisters a hook to be called right before the component is to be mounted.\nType\ntsfunction onBeforeMount(callback: () => void): void\nDetails\nWhen this hook is called, the component has finished setting up its reactive state, but no DOM nodes have been created yet. It is about to execute its DOM render effect for the first time.\nThis hook is not called during server-side rendering.\nonBeforeUpdate()\nRegisters a hook to be called right before the component is about to update its DOM tree due to a reactive state change.\nType\ntsfunction onBeforeUpdate(callback: () => void): void\nDetails\nThis hook can be used to access the DOM state before Vue updates the DOM. It is also safe to modify component state inside this hook.\nThis hook is not called during server-side rendering.\nonBeforeUnmount()\nRegisters a hook to be called right before a component instance is to be unmounted.\nType\ntsfunction onBeforeUnmount(callback: () => void): void\nDetails\nWhen this hook is called, the component instance is still fully functional.\nThis hook is not called during server-side rendering.\nonErrorCaptured()\nRegisters a hook to be called when an error propagating from a descendant component has been captured.\nType\ntsfunction onErrorCaptured(callback: ErrorCapturedHook): void type ErrorCapturedHook = ( err: unknown, instance: ComponentPublicInstance | null, info: string ) => boolean | void\nDetails\nErrors can be captured from the following sources:\n- Component renders\n- Event handlers\n- Lifecycle hooks\nsetup()\nfunction- Watchers\n- Custom directive hooks\n- Transition hooks\nThe hook receives three arguments: the error, the component instance that triggered the error, and an information string specifying the error source type.\nTIP\nIn production, the 3rd argument (\ninfo\n) will be a shortened code instead of the full information string. You can find the code to string mapping in the Production Error Code Reference.You can modify component state in\nerrorCaptured()\nto display an error state to the user. However, it is important that the error state should not render the original content that caused the error; otherwise the component will be thrown into an infinite render loop.The hook can return\nfalse\nto stop the error from propagating further. See error propagation details below.Error Propagation Rules\nBy default, all errors are still sent to the application-level\napp.config.errorHandler\nif it is defined, so that these errors can still be reported to an analytics service in a single place.If multiple\nerrorCaptured\nhooks exist on a component's inheritance chain or parent chain, all of them will be invoked on the same error, in the order of bottom to top. This is similar to the bubbling mechanism of native DOM events.If the\nerrorCaptured\nhook itself throws an error, both this error and the original captured error are sent toapp.config.errorHandler\n.An\nerrorCaptured\nhook can returnfalse\nto prevent the error from propagating further. This is essentially saying \"this error has been handled and should be ignored.\" It will prevent any additionalerrorCaptured\nhooks orapp.config.errorHandler\nfrom being invoked for this error.\nonRenderTracked()\nRegisters a debug hook to be called when a reactive dependency has been tracked by the component's render effect.\nThis hook is development-mode-only and not called during server-side rendering.\nType\ntsfunction onRenderTracked(callback: DebuggerHook): void type DebuggerHook = (e: DebuggerEvent) => void type DebuggerEvent = { effect: ReactiveEffect target: object type: TrackOpTypes /* 'get' | 'has' | 'iterate' */ key: any }\nSee also Reactivity in Depth\nonRenderTriggered()\nRegisters a debug hook to be called when a reactive dependency triggers the component's render effect to be re-run.\nThis hook is development-mode-only and not called during server-side rendering.\nType\ntsfunction onRenderTriggered(callback: DebuggerHook): void type DebuggerHook = (e: DebuggerEvent) => void type DebuggerEvent = { effect: ReactiveEffect target: object type: TriggerOpTypes /* 'set' | 'add' | 'delete' | 'clear' */ key: any newValue?: any oldValue?: any oldTarget?: Map<any, any> | Set<any> }\nSee also Reactivity in Depth\nonActivated()\nRegisters a callback to be called after the component instance is inserted into the DOM as part of a tree cached by <KeepAlive>\n.\nThis hook is not called during server-side rendering.\nType\ntsfunction onActivated(callback: () => void): void\nSee also Guide - Lifecycle of Cached Instance\nonDeactivated()\nRegisters a callback to be called after the component instance is removed from the DOM as part of a tree cached by <KeepAlive>\n.\nThis hook is not called during server-side rendering.\nType\ntsfunction onDeactivated(callback: () => void): void\nSee also Guide - Lifecycle of Cached Instance\nonServerPrefetch()\nRegisters an async function to be resolved before the component instance is to be rendered on the server.\nType\ntsfunction onServerPrefetch(callback: () => Promise<any>): void\nDetails\nIf the callback returns a Promise, the server renderer will wait until the Promise is resolved before rendering the component.\nThis hook is only called during server-side rendering can be used to perform server-only data fetching.\nExample\nvue<script setup> import { ref, onServerPrefetch, onMounted } from 'vue' const data = ref(null) onServerPrefetch(async () => { // component is rendered as part of the initial request // pre-fetch data on server as it is faster than on the client data.value = await fetchOnServer(/* ... */) }) onMounted(async () => { if (!data.value) { // if data is null on mount, it means the component // is dynamically rendered on the client. Perform a // client-side fetch instead. data.value = await fetchOnClient(/* ... */) } }) </script>\nSee also Server-Side Rendering",
    "metadata": {
      "source": "https://vuejs.org/api/composition-api-lifecycle",
      "title": "Composition API: Lifecycle Hooks | Vue.js"
    }
  },
  {
    "page_content": "Composition API:\nDependency Injection\nprovide()\nProvides a value that can be injected by descendant components.\nType\ntsfunction provide<T>(key: InjectionKey<T> | string, value: T): void\nDetails\nprovide()\ntakes two arguments: the key, which can be a string or a symbol, and the value to be injected.When using TypeScript, the key can be a symbol casted as\nInjectionKey\n- a Vue provided utility type that extendsSymbol\n, which can be used to sync the value type betweenprovide()\nandinject()\n.Similar to lifecycle hook registration APIs,\nprovide()\nmust be called synchronously during a component'ssetup()\nphase.Example\nvue<script setup> import { ref, provide } from 'vue' import { countSymbol } from './injectionSymbols' // provide static value provide('path', '/project/') // provide reactive value const count = ref(0) provide('count', count) // provide with Symbol keys provide(countSymbol, count) </script>\nSee also\ninject()\nInjects a value provided by an ancestor component or the application (via app.provide()\n).\nType\nts// without default value function inject<T>(key: InjectionKey<T> | string): T | undefined // with default value function inject<T>(key: InjectionKey<T> | string, defaultValue: T): T // with factory function inject<T>( key: InjectionKey<T> | string, defaultValue: () => T, treatDefaultAsFactory: true ): T\nDetails\nThe first argument is the injection key. Vue will walk up the parent chain to locate a provided value with a matching key. If multiple components in the parent chain provides the same key, the one closest to the injecting component will \"shadow\" those higher up the chain. If no value with matching key was found,\ninject()\nreturnsundefined\nunless a default value is provided.The second argument is optional and is the default value to be used when no matching value was found.\nThe second argument can also be a factory function that returns values that are expensive to create. In this case,\ntrue\nmust be passed as the third argument to indicate that the function should be used as a factory instead of the value itself.Similar to lifecycle hook registration APIs,\ninject()\nmust be called synchronously during a component'ssetup()\nphase.When using TypeScript, the key can be of type of\nInjectionKey\n- a Vue-provided utility type that extendsSymbol\n, which can be used to sync the value type betweenprovide()\nandinject()\n.Example\nAssuming a parent component has provided values as shown in the previous\nprovide()\nexample:vue<script setup> import { inject } from 'vue' import { countSymbol } from './injectionSymbols' // inject static value without default const path = inject('path') // inject reactive value const count = inject('count') // inject with Symbol keys const count2 = inject(countSymbol) // inject with default value const bar = inject('path', '/default-path') // inject with function default value const fn = inject('function', () => {}) // inject with default value factory const baz = inject('factory', () => new ExpensiveObject(), true) </script>\nSee also\nhasInjectionContext()\nReturns true if inject() can be used without warning about being called in the wrong place (e.g. outside of setup()\n). This method is designed to be used by libraries that want to use inject()\ninternally without triggering a warning to the end user.\nType\ntsfunction hasInjectionContext(): boolean",
    "metadata": {
      "source": "https://vuejs.org/api/composition-api-dependency-injection",
      "title": "Composition API: Dependency Injection | Vue.js"
    }
  },
  {
    "page_content": "Built-in Components\nRegistration and Usage\nBuilt-in components can be used directly in templates without needing to be registered. They are also tree-shakeable: they are only included in the build when they are used.\nWhen using them in render functions, they need to be imported explicitly. For example:\njs\nimport { h, Transition } from 'vue'\nh(Transition, {\n/* props */\n})\n<Transition>\nProvides animated transition effects to a single element or component.\nProps\ntsinterface TransitionProps { /** * Used to automatically generate transition CSS class names. * e.g. `name: 'fade'` will auto expand to `.fade-enter`, * `.fade-enter-active`, etc. */ name?: string /** * Whether to apply CSS transition classes. * Default: true */ css?: boolean /** * Specifies the type of transition events to wait for to * determine transition end timing. * Default behavior is auto detecting the type that has * longer duration. */ type?: 'transition' | 'animation' /** * Specifies explicit durations of the transition. * Default behavior is wait for the first `transitionend` * or `animationend` event on the root transition element. */ duration?: number | { enter: number; leave: number } /** * Controls the timing sequence of leaving/entering transitions. * Default behavior is simultaneous. */ mode?: 'in-out' | 'out-in' | 'default' /** * Whether to apply transition on initial render. * Default: false */ appear?: boolean /** * Props for customizing transition classes. * Use kebab-case in templates, e.g. enter-from-class=\"xxx\" */ enterFromClass?: string enterActiveClass?: string enterToClass?: string appearFromClass?: string appearActiveClass?: string appearToClass?: string leaveFromClass?: string leaveActiveClass?: string leaveToClass?: string }\nEvents\n@before-enter\n@before-leave\n@enter\n@leave\n@appear\n@after-enter\n@after-leave\n@after-appear\n@enter-cancelled\n@leave-cancelled\n(v-show\nonly)@appear-cancelled\nExample\nSimple element:\ntemplate<Transition> <div v-if=\"ok\">toggled content</div> </Transition>\nForcing a transition by changing the\nkey\nattribute:template<Transition> <div :key=\"text\">{{ text }}</div> </Transition>\nDynamic component, with transition mode + animate on appear:\ntemplate<Transition name=\"fade\" mode=\"out-in\" appear> <component :is=\"view\"></component> </Transition>\nListening to transition events:\ntemplate<Transition @after-enter=\"onTransitionComplete\"> <div v-show=\"ok\">toggled content</div> </Transition>\nSee also Guide - Transition\n<TransitionGroup>\nProvides transition effects for multiple elements or components in a list.\nProps\n<TransitionGroup>\naccepts the same props as<Transition>\nexceptmode\n, plus two additional props:tsinterface TransitionGroupProps extends Omit<TransitionProps, 'mode'> { /** * If not defined, renders as a fragment. */ tag?: string /** * For customizing the CSS class applied during move transitions. * Use kebab-case in templates, e.g. move-class=\"xxx\" */ moveClass?: string }\nEvents\n<TransitionGroup>\nemits the same events as<Transition>\n.Details\nBy default,\n<TransitionGroup>\ndoesn't render a wrapper DOM element, but one can be defined via thetag\nprop.Note that every child in a\n<transition-group>\nmust be uniquely keyed for the animations to work properly.<TransitionGroup>\nsupports moving transitions via CSS transform. When a child's position on screen has changed after an update, it will get applied a moving CSS class (auto generated from thename\nattribute or configured with themove-class\nprop). If the CSStransform\nproperty is \"transition-able\" when the moving class is applied, the element will be smoothly animated to its destination using the FLIP technique.Example\ntemplate<TransitionGroup tag=\"ul\" name=\"slide\"> <li v-for=\"item in items\" :key=\"item.id\"> {{ item.text }} </li> </TransitionGroup>\nSee also Guide - TransitionGroup\n<KeepAlive>\nCaches dynamically toggled components wrapped inside.\nProps\ntsinterface KeepAliveProps { /** * If specified, only components with names matched by * `include` will be cached. */ include?: MatchPattern /** * Any component with a name matched by `exclude` will * not be cached. */ exclude?: MatchPattern /** * The maximum number of component instances to cache. */ max?: number | string } type MatchPattern = string | RegExp | (string | RegExp)[]\nDetails\nWhen wrapped around a dynamic component,\n<KeepAlive>\ncaches the inactive component instances without destroying them.There can only be one active component instance as the direct child of\n<KeepAlive>\nat any time.When a component is toggled inside\n<KeepAlive>\n, itsactivated\nanddeactivated\nlifecycle hooks will be invoked accordingly, providing an alternative tomounted\nandunmounted\n, which are not called. This applies to the direct child of<KeepAlive>\nas well as to all of its descendants.Example\nBasic usage:\ntemplate<KeepAlive> <component :is=\"view\"></component> </KeepAlive>\nWhen used with\nv-if\n/v-else\nbranches, there must be only one component rendered at a time:template<KeepAlive> <comp-a v-if=\"a > 1\"></comp-a> <comp-b v-else></comp-b> </KeepAlive>\nUsed together with\n<Transition>\n:template<Transition> <KeepAlive> <component :is=\"view\"></component> </KeepAlive> </Transition>\nUsing\ninclude\n/exclude\n:template<!-- comma-delimited string --> <KeepAlive include=\"a,b\"> <component :is=\"view\"></component> </KeepAlive> <!-- regex (use `v-bind`) --> <KeepAlive :include=\"/a|b/\"> <component :is=\"view\"></component> </KeepAlive> <!-- Array (use `v-bind`) --> <KeepAlive :include=\"['a', 'b']\"> <component :is=\"view\"></component> </KeepAlive>\nUsage with\nmax\n:template<KeepAlive :max=\"10\"> <component :is=\"view\"></component> </KeepAlive>\nSee also Guide - KeepAlive\n<Teleport>\nRenders its slot content to another part of the DOM.\nProps\ntsinterface TeleportProps { /** * Required. Specify target container. * Can either be a selector or an actual element. */ to: string | HTMLElement /** * When `true`, the content will remain in its original * location instead of moved into the target container. * Can be changed dynamically. */ disabled?: boolean }\nExample\nSpecifying target container:\ntemplate<Teleport to=\"#some-id\" /> <Teleport to=\".some-class\" /> <Teleport to=\"[data-teleport]\" />\nConditionally disabling:\ntemplate<Teleport to=\"#popup\" :disabled=\"displayVideoInline\"> <video src=\"./my-movie.mp4\"> </Teleport>\nSee also Guide - Teleport\n<Suspense>\nUsed for orchestrating nested async dependencies in a component tree.\nProps\ntsinterface SuspenseProps { timeout?: string | number suspensible?: boolean }\nEvents\n@resolve\n@pending\n@fallback\nDetails\n<Suspense>\naccepts two slots: the#default\nslot and the#fallback\nslot. It will display the content of the fallback slot while rendering the default slot in memory.If it encounters async dependencies (Async Components and components with\nasync setup()\n) while rendering the default slot, it will wait until all of them are resolved before displaying the default slot.By setting the Suspense as\nsuspensible\n, all the async dependency handling will be handled by the parent Suspense. See implementation detailsSee also Guide - Suspense",
    "metadata": {
      "source": "https://vuejs.org/api/built-in-components",
      "title": "Built-in Components | Vue.js"
    }
  },
  {
    "page_content": "Options: Rendering\ntemplate\nA string template for the component.\nType\ntsinterface ComponentOptions { template?: string }\nDetails\nA template provided via the\ntemplate\noption will be compiled on-the-fly at runtime. It is only supported when using a build of Vue that includes the template compiler. The template compiler is NOT included in Vue builds that have the wordruntime\nin their names, e.g.vue.runtime.esm-bundler.js\n. Consult the dist file guide for more details about the different builds.If the string starts with\n#\nit will be used as aquerySelector\nand use the selected element'sinnerHTML\nas the template string. This allows the source template to be authored using native<template>\nelements.If the\nrender\noption is also present in the same component,template\nwill be ignored.If the root component of your application doesn't have a\ntemplate\norrender\noption specified, Vue will try to use theinnerHTML\nof the mounted element as the template instead.Security Note\nOnly use template sources that you can trust. Do not use user-provided content as your template. See Security Guide for more details.\nrender\nA function that programmatically returns the virtual DOM tree of the component.\nType\ntsinterface ComponentOptions { render?(this: ComponentPublicInstance) => VNodeChild } type VNodeChild = VNodeChildAtom | VNodeArrayChildren type VNodeChildAtom = | VNode | string | number | boolean | null | undefined | void type VNodeArrayChildren = (VNodeArrayChildren | VNodeChildAtom)[]\nDetails\nrender\nis an alternative to string templates that allows you to leverage the full programmatic power of JavaScript to declare the render output of the component.Pre-compiled templates, for example those in Single-File Components, are compiled into the\nrender\noption at build time. If bothrender\nandtemplate\nare present in a component,render\nwill take higher priority.See also\ncompilerOptions\nConfigure runtime compiler options for the component's template.\nType\ntsinterface ComponentOptions { compilerOptions?: { isCustomElement?: (tag: string) => boolean whitespace?: 'condense' | 'preserve' // default: 'condense' delimiters?: [string, string] // default: ['{{', '}}'] comments?: boolean // default: false } }\nDetails\nThis config option is only respected when using the full build (i.e. the standalone\nvue.js\nthat can compile templates in the browser). It supports the same options as the app-level app.config.compilerOptions, and has higher priority for the current component.See also app.config.compilerOptions\nslots\nAn option to assist with type inference when using slots programmatically in render functions. Only supported in 3.3+.\nDetails\nThis option's runtime value is not used. The actual types should be declared via type casting using the\nSlotsType\ntype helper:tsimport { SlotsType } from 'vue' defineComponent({ slots: Object as SlotsType<{ default: { foo: string; bar: number } item: { data: number } }>, setup(props, { slots }) { expectType< undefined | ((scope: { foo: string; bar: number }) => any) >(slots.default) expectType<undefined | ((scope: { data: number }) => any)>( slots.item ) } })",
    "metadata": {
      "source": "https://vuejs.org/api/options-rendering",
      "title": "Options: Rendering | Vue.js"
    }
  },
  {
    "page_content": "Reactivity API: Advanced\nshallowRef()\nShallow version of ref()\n.\nType\ntsfunction shallowRef<T>(value: T): ShallowRef<T> interface ShallowRef<T> { value: T }\nDetails\nUnlike\nref()\n, the inner value of a shallow ref is stored and exposed as-is, and will not be made deeply reactive. Only the.value\naccess is reactive.shallowRef()\nis typically used for performance optimizations of large data structures, or integration with external state management systems.Example\njsconst state = shallowRef({ count: 1 }) // does NOT trigger change state.value.count = 2 // does trigger change state.value = { count: 2 }\nSee also\ntriggerRef()\nForce trigger effects that depends on a shallow ref. This is typically used after making deep mutations to the inner value of a shallow ref.\nType\ntsfunction triggerRef(ref: ShallowRef): void\nExample\njsconst shallow = shallowRef({ greet: 'Hello, world' }) // Logs \"Hello, world\" once for the first run-through watchEffect(() => { console.log(shallow.value.greet) }) // This won't trigger the effect because the ref is shallow shallow.value.greet = 'Hello, universe' // Logs \"Hello, universe\" triggerRef(shallow)\ncustomRef()\nCreates a customized ref with explicit control over its dependency tracking and updates triggering.\nType\ntsfunction customRef<T>(factory: CustomRefFactory<T>): Ref<T> type CustomRefFactory<T> = ( track: () => void, trigger: () => void ) => { get: () => T set: (value: T) => void }\nDetails\ncustomRef()\nexpects a factory function, which receivestrack\nandtrigger\nfunctions as arguments and should return an object withget\nandset\nmethods.In general,\ntrack()\nshould be called insideget()\n, andtrigger()\nshould be called insideset()\n. However, you have full control over when they should be called, or whether they should be called at all.Example\nCreating a debounced ref that only updates the value after a certain timeout after the latest set call:\njsimport { customRef } from 'vue' export function useDebouncedRef(value, delay = 200) { let timeout return customRef((track, trigger) => { return { get() { track() return value }, set(newValue) { clearTimeout(timeout) timeout = setTimeout(() => { value = newValue trigger() }, delay) } } }) }\nUsage in component:\nvue<script setup> import { useDebouncedRef } from './debouncedRef' const text = useDebouncedRef('hello') </script> <template> <input v-model=\"text\" /> </template>\nUse with caution\nWhen using customRef, we should be cautious about the return value of its getter, particularly when generating new object datatypes each time the getter is run. This affects the relationship between parent and child components, where such a customRef has been passed as a prop.\nThe parent component's render function could be triggered by changes to a different reactive state. During rerender, the value of our customRef is reevaluated, returning a new object datatype as a prop to a child component. This prop is compared with its last value in the child component, and since they are different, the reactive dependencies of the customRef are triggered in the child component. Meanwhile, the reactive dependencies in the parent component do not run because the customRef's setter was not called, and its dependencies were not triggered as a result.\nshallowReactive()\nShallow version of reactive()\n.\nType\ntsfunction shallowReactive<T extends object>(target: T): T\nDetails\nUnlike\nreactive()\n, there is no deep conversion: only root-level properties are reactive for a shallow reactive object. Property values are stored and exposed as-is - this also means properties with ref values will not be automatically unwrapped.Use with Caution\nShallow data structures should only be used for root level state in a component. Avoid nesting it inside a deep reactive object as it creates a tree with inconsistent reactivity behavior which can be difficult to understand and debug.\nExample\njsconst state = shallowReactive({ foo: 1, nested: { bar: 2 } }) // mutating state's own properties is reactive state.foo++ // ...but does not convert nested objects isReactive(state.nested) // false // NOT reactive state.nested.bar++\nshallowReadonly()\nShallow version of readonly()\n.\nType\ntsfunction shallowReadonly<T extends object>(target: T): Readonly<T>\nDetails\nUnlike\nreadonly()\n, there is no deep conversion: only root-level properties are made readonly. Property values are stored and exposed as-is - this also means properties with ref values will not be automatically unwrapped.Use with Caution\nShallow data structures should only be used for root level state in a component. Avoid nesting it inside a deep reactive object as it creates a tree with inconsistent reactivity behavior which can be difficult to understand and debug.\nExample\njsconst state = shallowReadonly({ foo: 1, nested: { bar: 2 } }) // mutating state's own properties will fail state.foo++ // ...but works on nested objects isReadonly(state.nested) // false // works state.nested.bar++\ntoRaw()\nReturns the raw, original object of a Vue-created proxy.\nType\ntsfunction toRaw<T>(proxy: T): T\nDetails\ntoRaw()\ncan return the original object from proxies created byreactive()\n,readonly()\n,shallowReactive()\norshallowReadonly()\n.This is an escape hatch that can be used to temporarily read without incurring proxy access / tracking overhead or write without triggering changes. It is not recommended to hold a persistent reference to the original object. Use with caution.\nExample\njsconst foo = {} const reactiveFoo = reactive(foo) console.log(toRaw(reactiveFoo) === foo) // true\nmarkRaw()\nMarks an object so that it will never be converted to a proxy. Returns the object itself.\nType\ntsfunction markRaw<T extends object>(value: T): T\nExample\njsconst foo = markRaw({}) console.log(isReactive(reactive(foo))) // false // also works when nested inside other reactive objects const bar = reactive({ foo }) console.log(isReactive(bar.foo)) // false\nUse with Caution\nmarkRaw()\nand shallow APIs such asshallowReactive()\nallow you to selectively opt-out of the default deep reactive/readonly conversion and embed raw, non-proxied objects in your state graph. They can be used for various reasons:Some values simply should not be made reactive, for example a complex 3rd party class instance, or a Vue component object.\nSkipping proxy conversion can provide performance improvements when rendering large lists with immutable data sources.\nThey are considered advanced because the raw opt-out is only at the root level, so if you set a nested, non-marked raw object into a reactive object and then access it again, you get the proxied version back. This can lead to identity hazards - i.e. performing an operation that relies on object identity but using both the raw and the proxied version of the same object:\njsconst foo = markRaw({ nested: {} }) const bar = reactive({ // although `foo` is marked as raw, foo.nested is not. nested: foo.nested }) console.log(foo.nested === bar.nested) // false\nIdentity hazards are in general rare. However, to properly utilize these APIs while safely avoiding identity hazards requires a solid understanding of how the reactivity system works.\neffectScope()\nCreates an effect scope object which can capture the reactive effects (i.e. computed and watchers) created within it so that these effects can be disposed together. For detailed use cases of this API, please consult its corresponding RFC.\nType\ntsfunction effectScope(detached?: boolean): EffectScope interface EffectScope { run<T>(fn: () => T): T | undefined // undefined if scope is inactive stop(): void }\nExample\njsconst scope = effectScope() scope.run(() => { const doubled = computed(() => counter.value * 2) watch(doubled, () => console.log(doubled.value)) watchEffect(() => console.log('Count: ', doubled.value)) }) // to dispose all effects in the scope scope.stop()\ngetCurrentScope()\nReturns the current active effect scope if there is one.\nType\ntsfunction getCurrentScope(): EffectScope | undefined\nonScopeDispose()\nRegisters a dispose callback on the current active effect scope. The callback will be invoked when the associated effect scope is stopped.\nThis method can be used as a non-component-coupled replacement of onUnmounted\nin reusable composition functions, since each Vue component's setup()\nfunction is also invoked in an effect scope.\nType\ntsfunction onScopeDispose(fn: () => void): void",
    "metadata": {
      "source": "https://vuejs.org/api/reactivity-advanced",
      "title": "Reactivity API: Advanced | Vue.js"
    }
  },
  {
    "page_content": "<script setup>\n<script setup>\nis a compile-time syntactic sugar for using Composition API inside Single-File Components (SFCs). It is the recommended syntax if you are using both SFCs and Composition API. It provides a number of advantages over the normal <script>\nsyntax:\n- More succinct code with less boilerplate\n- Ability to declare props and emitted events using pure TypeScript\n- Better runtime performance (the template is compiled into a render function in the same scope, without an intermediate proxy)\n- Better IDE type-inference performance (less work for the language server to extract types from code)\nBasic Syntax\nTo opt-in to the syntax, add the setup\nattribute to the <script>\nblock:\nvue\n<script setup>\nconsole.log('hello script setup')\n</script>\nThe code inside is compiled as the content of the component's setup()\nfunction. This means that unlike normal <script>\n, which only executes once when the component is first imported, code inside <script setup>\nwill execute every time an instance of the component is created.\nTop-level bindings are exposed to template\nWhen using <script setup>\n, any top-level bindings (including variables, function declarations, and imports) declared inside <script setup>\nare directly usable in the template:\nvue\n<script setup>\n// variable\nconst msg = 'Hello!'\n// functions\nfunction log() {\nconsole.log(msg)\n}\n</script>\n<template>\n<button @click=\"log\">{{ msg }}</button>\n</template>\nImports are exposed in the same fashion. This means you can directly use an imported helper function in template expressions without having to expose it via the methods\noption:\nvue\n<script setup>\nimport { capitalize } from './helpers'\n</script>\n<template>\n<div>{{ capitalize('hello') }}</div>\n</template>\nReactivity\nReactive state needs to be explicitly created using Reactivity APIs. Similar to values returned from a setup()\nfunction, refs are automatically unwrapped when referenced in templates:\nvue\n<script setup>\nimport { ref } from 'vue'\nconst count = ref(0)\n</script>\n<template>\n<button @click=\"count++\">{{ count }}</button>\n</template>\nUsing Components\nValues in the scope of <script setup>\ncan also be used directly as custom component tag names:\nvue\n<script setup>\nimport MyComponent from './MyComponent.vue'\n</script>\n<template>\n<MyComponent />\n</template>\nThink of MyComponent\nas being referenced as a variable. If you have used JSX, the mental model is similar here. The kebab-case equivalent <my-component>\nalso works in the template - however PascalCase component tags are strongly recommended for consistency. It also helps differentiating from native custom elements.\nDynamic Components\nSince components are referenced as variables instead of registered under string keys, we should use dynamic :is\nbinding when using dynamic components inside <script setup>\n:\nvue\n<script setup>\nimport Foo from './Foo.vue'\nimport Bar from './Bar.vue'\n</script>\n<template>\n<component :is=\"Foo\" />\n<component :is=\"someCondition ? Foo : Bar\" />\n</template>\nNote how the components can be used as variables in a ternary expression.\nRecursive Components\nAn SFC can implicitly refer to itself via its filename. E.g. a file named FooBar.vue\ncan refer to itself as <FooBar/>\nin its template.\nNote this has lower priority than imported components. If you have a named import that conflicts with the component's inferred name, you can alias the import:\njs\nimport { FooBar as FooBarChild } from './components'\nNamespaced Components\nYou can use component tags with dots like <Foo.Bar>\nto refer to components nested under object properties. This is useful when you import multiple components from a single file:\nvue\n<script setup>\nimport * as Form from './form-components'\n</script>\n<template>\n<Form.Input>\n<Form.Label>label</Form.Label>\n</Form.Input>\n</template>\nUsing Custom Directives\nGlobally registered custom directives just work as normal. Local custom directives don't need to be explicitly registered with <script setup>\n, but they must follow the naming scheme vNameOfDirective\n:\nvue\n<script setup>\nconst vMyDirective = {\nbeforeMount: (el) => {\n// do something with the element\n}\n}\n</script>\n<template>\n<h1 v-my-directive>This is a Heading</h1>\n</template>\nIf you're importing a directive from elsewhere, it can be renamed to fit the required naming scheme:\nvue\n<script setup>\nimport { myDirective as vMyDirective } from './MyDirective.js'\n</script>\ndefineProps() & defineEmits()\nTo declare options like props\nand emits\nwith full type inference support, we can use the defineProps\nand defineEmits\nAPIs, which are automatically available inside <script setup>\n:\nvue\n<script setup>\nconst props = defineProps({\nfoo: String\n})\nconst emit = defineEmits(['change', 'delete'])\n// setup code\n</script>\ndefineProps\nanddefineEmits\nare compiler macros only usable inside<script setup>\n. They do not need to be imported, and are compiled away when<script setup>\nis processed.defineProps\naccepts the same value as theprops\noption, whiledefineEmits\naccepts the same value as theemits\noption.defineProps\nanddefineEmits\nprovide proper type inference based on the options passed.The options passed to\ndefineProps\nanddefineEmits\nwill be hoisted out of setup into module scope. Therefore, the options cannot reference local variables declared in setup scope. Doing so will result in a compile error. However, it can reference imported bindings since they are in the module scope as well.\nType-only props/emit declarations\nProps and emits can also be declared using pure-type syntax by passing a literal type argument to defineProps\nor defineEmits\n:\nts\nconst props = defineProps<{\nfoo: string\nbar?: number\n}>()\nconst emit = defineEmits<{\n(e: 'change', id: number): void\n(e: 'update', value: string): void\n}>()\n// 3.3+: alternative, more succinct syntax\nconst emit = defineEmits<{\nchange: [id: number] // named tuple syntax\nupdate: [value: string]\n}>()\ndefineProps\nordefineEmits\ncan only use either runtime declaration OR type declaration. Using both at the same time will result in a compile error.When using type declaration, the equivalent runtime declaration is automatically generated from static analysis to remove the need for double declaration and still ensure correct runtime behavior.\nIn dev mode, the compiler will try to infer corresponding runtime validation from the types. For example here\nfoo: String\nis inferred from thefoo: string\ntype. If the type is a reference to an imported type, the inferred result will befoo: null\n(equal toany\ntype) since the compiler does not have information of external files.In prod mode, the compiler will generate the array format declaration to reduce bundle size (the props here will be compiled into\n['foo', 'bar']\n)\nIn version 3.2 and below, the generic type parameter for\ndefineProps()\nwere limited to a type literal or a reference to a local interface.This limitation has been resolved in 3.3. The latest version of Vue supports referencing imported and a limited set of complex types in the type parameter position. However, because the type to runtime conversion is still AST-based, some complex types that require actual type analysis, e.g. conditional types, are not supported. You can use conditional types for the type of a single prop, but not the entire props object.\nDefault props values when using type declaration\nOne drawback of the type-only defineProps\ndeclaration is that it doesn't have a way to provide default values for the props. To resolve this problem, a withDefaults\ncompiler macro is also provided:\nts\nexport interface Props {\nmsg?: string\nlabels?: string[]\n}\nconst props = withDefaults(defineProps<Props>(), {\nmsg: 'hello',\nlabels: () => ['one', 'two']\n})\nThis will be compiled to equivalent runtime props default\noptions. In addition, the withDefaults\nhelper provides type checks for the default values, and ensures the returned props\ntype has the optional flags removed for properties that do have default values declared.\nINFO\nNote that default values for mutable reference types (like arrays or objects) should be wrapped in functions to avoid accidental modification and external side effects. This ensures each component instance gets its own copy of the default value.\ndefineModel()\nThis macro can be used to declare a two-way binding prop that can be consumed via v-model\nfrom the parent component. Example usage is also discussed in the Component v-model\nguide.\nUnder the hood, this macro declares a model prop and a corresponding value update event. If the first argument is a literal string, it will be used as the prop name; Otherwise the prop name will default to \"modelValue\"\n. In both cases, you can also pass an additional object which can include the prop's options and the model ref's value transform options.\njs\n// declares \"modelValue\" prop, consumed by parent via v-model\nconst model = defineModel()\n// OR: declares \"modelValue\" prop with options\nconst model = defineModel({ type: String })\n// emits \"update:modelValue\" when mutated\nmodel.value = 'hello'\n// declares \"count\" prop, consumed by parent via v-model:count\nconst count = defineModel('count')\n// OR: declares \"count\" prop with options\nconst count = defineModel('count', { type: Number, default: 0 })\nfunction inc() {\n// emits \"update:count\" when mutated\ncount.value++\n}\nWARNING\nIf you have a default\nvalue for defineModel\nprop and you don't provide any value for this prop from the parent component, it can cause a de-synchronization between parent and child components. In the example below, the parent's myRef\nis undefined, but the child's model\nis 1:\njs\n// child component:\nconst model = defineModel({ default: 1 })\n// parent component:\nconst myRef = ref()\nhtml\n<Child v-model=\"myRef\"></Child>\nModifiers and Transformers\nTo access modifiers used with the v-model\ndirective, we can destructure the return value of defineModel()\nlike this:\njs\nconst [modelValue, modelModifiers] = defineModel()\n// corresponds to v-model.trim\nif (modelModifiers.trim) {\n// ...\n}\nWhen a modifier is present, we likely need to transform the value when reading or syncing it back to the parent. We can achieve this by using the get\nand set\ntransformer options:\njs\nconst [modelValue, modelModifiers] = defineModel({\n// get() omitted as it is not needed here\nset(value) {\n// if the .trim modifier is used, return trimmed value\nif (modelModifiers.trim) {\nreturn value.trim()\n}\n// otherwise, return the value as-is\nreturn value\n}\n})\nUsage with TypeScript\nLike defineProps\nand defineEmits\n, defineModel\ncan also receive type arguments to specify the types of the model value and the modifiers:\nts\nconst modelValue = defineModel<string>()\n// ^? Ref<string | undefined>\n// default model with options, required removes possible undefined values\nconst modelValue = defineModel<string>({ required: true })\n// ^? Ref<string>\nconst [modelValue, modifiers] = defineModel<string, 'trim' | 'uppercase'>()\n// ^? Record<'trim' | 'uppercase', true | undefined>\ndefineExpose()\nComponents using <script setup>\nare closed by default - i.e. the public instance of the component, which is retrieved via template refs or $parent\nchains, will not expose any of the bindings declared inside <script setup>\n.\nTo explicitly expose properties in a <script setup>\ncomponent, use the defineExpose\ncompiler macro:\nvue\n<script setup>\nimport { ref } from 'vue'\nconst a = 1\nconst b = ref(2)\ndefineExpose({\na,\nb\n})\n</script>\nWhen a parent gets an instance of this component via template refs, the retrieved instance will be of the shape { a: number, b: number }\n(refs are automatically unwrapped just like on normal instances).\ndefineOptions()\nThis macro can be used to declare component options directly inside <script setup>\nwithout having to use a separate <script>\nblock:\nvue\n<script setup>\ndefineOptions({\ninheritAttrs: false,\ncustomOptions: {\n/* ... */\n}\n})\n</script>\n- Only supported in 3.3+.\n- This is a macro. The options will be hoisted to module scope and cannot access local variables in\n<script setup>\nthat are not literal constants.\ndefineSlots()\nThis macro can be used to provide type hints to IDEs for slot name and props type checking.\ndefineSlots()\nonly accepts a type parameter and no runtime arguments. The type parameter should be a type literal where the property key is the slot name, and the value type is the slot function. The first argument of the function is the props the slot expects to receive, and its type will be used for slot props in the template. The return type is currently ignored and can be any\n, but we may leverage it for slot content checking in the future.\nIt also returns the slots\nobject, which is equivalent to the slots\nobject exposed on the setup context or returned by useSlots()\n.\nvue\n<script setup lang=\"ts\">\nconst slots = defineSlots<{\ndefault(props: { msg: string }): any\n}>()\n</script>\n- Only supported in 3.3+.\nuseSlots()\n& useAttrs()\nUsage of slots\nand attrs\ninside <script setup>\nshould be relatively rare, since you can access them directly as $slots\nand $attrs\nin the template. In the rare case where you do need them, use the useSlots\nand useAttrs\nhelpers respectively:\nvue\n<script setup>\nimport { useSlots, useAttrs } from 'vue'\nconst slots = useSlots()\nconst attrs = useAttrs()\n</script>\nuseSlots\nand useAttrs\nare actual runtime functions that return the equivalent of setupContext.slots\nand setupContext.attrs\n. They can be used in normal composition API functions as well.\nUsage alongside normal <script>\n<script setup>\ncan be used alongside normal <script>\n. A normal <script>\nmay be needed in cases where we need to:\n- Declare options that cannot be expressed in\n<script setup>\n, for exampleinheritAttrs\nor custom options enabled via plugins (Can be replaced bydefineOptions\nin 3.3+). - Declaring named exports.\n- Run side effects or create objects that should only execute once.\nvue\n<script>\n// normal <script>, executed in module scope (only once)\nrunSideEffectOnce()\n// declare additional options\nexport default {\ninheritAttrs: false,\ncustomOptions: {}\n}\n</script>\n<script setup>\n// executed in setup() scope (for each instance)\n</script>\nSupport for combining <script setup>\nand <script>\nin the same component is limited to the scenarios described above. Specifically:\n- Do NOT use a separate\n<script>\nsection for options that can already be defined using<script setup>\n, such asprops\nandemits\n. - Variables created inside\n<script setup>\nare not added as properties to the component instance, making them inaccessible from the Options API. Mixing APIs in this way is strongly discouraged.\nIf you find yourself in one of the scenarios that is not supported then you should consider switching to an explicit setup()\nfunction, instead of using <script setup>\n.\nTop-level await\nTop-level await\ncan be used inside <script setup>\n. The resulting code will be compiled as async setup()\n:\nvue\n<script setup>\nconst post = await fetch(`/api/post/1`).then((r) => r.json())\n</script>\nIn addition, the awaited expression will be automatically compiled in a format that preserves the current component instance context after the await\n.\nNote\nasync setup()\nmust be used in combination with Suspense\n, which is currently still an experimental feature. We plan to finalize and document it in a future release - but if you are curious now, you can refer to its tests to see how it works.\nGenerics\nGeneric type parameters can be declared using the generic\nattribute on the <script>\ntag:\nvue\n<script setup lang=\"ts\" generic=\"T\">\ndefineProps<{\nitems: T[]\nselected: T\n}>()\n</script>\nThe value of generic\nworks exactly the same as the parameter list between <...>\nin TypeScript. For example, you can use multiple parameters, extends\nconstraints, default types, and reference imported types:\nvue\n<script\nsetup\nlang=\"ts\"\ngeneric=\"T extends string | number, U extends Item\"\n>\nimport type { Item } from './types'\ndefineProps<{\nid: T\nlist: U[]\n}>()\n</script>\nIn order to use a reference to a generic component in a ref\nyou need to use the vue-component-type-helpers\nlibrary as InstanceType\nwon't work.\nvue\n<script\nsetup\nlang=\"ts\"\n>\nimport componentWithoutGenerics from '../component-without-generics.vue';\nimport genericComponent from '../generic-component.vue';\nimport type { ComponentExposed } from 'vue-component-type-helpers';\n// Works for a component without generics\nref<InstanceType<typeof componentWithoutGenerics>>();\nref<ComponentExposed<typeof genericComponent>>();\nRestrictions\n- Due to the difference in module execution semantics, code inside\n<script setup>\nrelies on the context of an SFC. When moved into external.js\nor.ts\nfiles, it may lead to confusion for both developers and tools. Therefore,<script setup>\ncannot be used with thesrc\nattribute. <script setup>\ndoes not support In-DOM Root Component Template.(Related Discussion)",
    "metadata": {
      "source": "https://vuejs.org/api/sfc-script-setup",
      "title": "<script setup> | Vue.js"
    }
  },
  {
    "page_content": "Server-Side Rendering API\nrenderToString()\nExported from\nvue/server-renderer\nType\ntsfunction renderToString( input: App | VNode, context?: SSRContext ): Promise<string>\nExample\njsimport { createSSRApp } from 'vue' import { renderToString } from 'vue/server-renderer' const app = createSSRApp({ data: () => ({ msg: 'hello' }), template: `<div>{{ msg }}</div>` }) ;(async () => { const html = await renderToString(app) console.log(html) })()\nSSR Context\nYou can pass an optional context object, which can be used to record additional data during the render, for example accessing content of Teleports:\njsconst ctx = {} const html = await renderToString(app, ctx) console.log(ctx.teleports) // { '#teleported': 'teleported content' }\nMost other SSR APIs on this page also optionally accept a context object. The context object can be accessed in component code via the useSSRContext helper.\nSee also Guide - Server-Side Rendering\nrenderToNodeStream()\nRenders input as a Node.js Readable stream.\nExported from\nvue/server-renderer\nType\ntsfunction renderToNodeStream( input: App | VNode, context?: SSRContext ): Readable\nExample\njs// inside a Node.js http handler renderToNodeStream(app).pipe(res)\nNote\nThis method is not supported in the ESM build of\nvue/server-renderer\n, which is decoupled from Node.js environments. UsepipeToNodeWritable\ninstead.\npipeToNodeWritable()\nRender and pipe to an existing Node.js Writable stream instance.\nExported from\nvue/server-renderer\nType\ntsfunction pipeToNodeWritable( input: App | VNode, context: SSRContext = {}, writable: Writable ): void\nExample\njs// inside a Node.js http handler pipeToNodeWritable(app, {}, res)\nrenderToWebStream()\nRenders input as a Web ReadableStream.\nExported from\nvue/server-renderer\nType\ntsfunction renderToWebStream( input: App | VNode, context?: SSRContext ): ReadableStream\nExample\njs// inside an environment with ReadableStream support return new Response(renderToWebStream(app))\nNote\nIn environments that do not expose\nReadableStream\nconstructor in the global scope,pipeToWebWritable()\nshould be used instead.\npipeToWebWritable()\nRender and pipe to an existing Web WritableStream instance.\nExported from\nvue/server-renderer\nType\ntsfunction pipeToWebWritable( input: App | VNode, context: SSRContext = {}, writable: WritableStream ): void\nExample\nThis is typically used in combination with\nTransformStream\n:js// TransformStream is available in environments such as CloudFlare workers. // in Node.js, TransformStream needs to be explicitly imported from 'stream/web' const { readable, writable } = new TransformStream() pipeToWebWritable(app, {}, writable) return new Response(readable)\nrenderToSimpleStream()\nRenders input in streaming mode using a simple readable interface.\nExported from\nvue/server-renderer\nType\ntsfunction renderToSimpleStream( input: App | VNode, context: SSRContext, options: SimpleReadable ): SimpleReadable interface SimpleReadable { push(content: string | null): void destroy(err: any): void }\nExample\njslet res = '' renderToSimpleStream( app, {}, { push(chunk) { if (chunk === null) { // done console(`render complete: ${res}`) } else { res += chunk } }, destroy(err) { // error encountered } } )\nuseSSRContext()\nA runtime API used to retrieve the context object passed to renderToString()\nor other server render APIs.\nType\ntsfunction useSSRContext<T = Record<string, any>>(): T | undefined\nExample\nThe retrieved context can be used to attach information that is needed for rendering the final HTML (e.g. head metadata).\nvue<script setup> import { useSSRContext } from 'vue' // make sure to only call it during SSR // https://vitejs.dev/guide/ssr.html#conditional-logic if (import.meta.env.SSR) { const ctx = useSSRContext() // ...attach properties to the context } </script>",
    "metadata": {
      "source": "https://vuejs.org/api/ssr",
      "title": "Server-Side Rendering API | Vue.js"
    }
  },
  {
    "page_content": "Named Routes\nWhen creating a route, we can optionally give the route a name\n:\nconst routes = [\n{\npath: '/user/:username',\nname: 'profile',\ncomponent: User\n}\n]\nWe can then use the name\ninstead of the path\nwhen passing the to\nprop to <router-link>\n:\n<router-link :to=\"{ name: 'profile', params: { username: 'erina' } }\">\nUser profile\n</router-link>\nThe example above would create a link to /user/erina\n.\nUsing a name\nhas various advantages:\n- No hardcoded URLs.\n- Automatic encoding of\nparams\n. - Avoids URL typos.\n- Bypassing path ranking, e.g. to display a lower-ranked route that matches the same path.\nEach name must be unique across all routes. If you add the same name to multiple routes, the router will only keep the last one. You can read more about this in the Dynamic Routing section.\nThere are various other parts of Vue Router that can be passed a location, e.g. the methods router.push()\nand router.replace()\n. We'll go into more detail about those methods in the guide to programmatic navigation. Just like the to\nprop, these methods also support passing a location by name\n:\nrouter.push({ name: 'profile', params: { username: 'erina' } })",
    "metadata": {
      "source": "https://router.vuejs.org/guide/essentials/named-routes",
      "title": "Named Routes | Vue Router"
    }
  },
  {
    "page_content": "Transitions\nIn order to use transitions on your route components and animate navigations, you need to use the <RouterView>\nslot:\n<router-view v-slot=\"{ Component }\">\n<transition name=\"fade\">\n<component :is=\"Component\" />\n</transition>\n</router-view>\nAll transition APIs work the same here.\nPer-Route Transition\nThe above usage will apply the same transition for all routes. If you want each route's component to have different transitions, you can instead combine meta fields and a dynamic name\non <transition>\n:\nconst routes = [\n{\npath: '/custom-transition',\ncomponent: PanelLeft,\nmeta: { transition: 'slide-left' },\n},\n{\npath: '/other-transition',\ncomponent: PanelRight,\nmeta: { transition: 'slide-right' },\n},\n]\n<router-view v-slot=\"{ Component, route }\">\n<!-- Use a custom transition or fallback to `fade` -->\n<transition :name=\"route.meta.transition || 'fade'\">\n<component :is=\"Component\" />\n</transition>\n</router-view>\nRoute-Based Dynamic Transition\nIt is also possible to determine the transition to use dynamically based on the relationship between the target route and current route. Using a very similar snippet to the one just before:\n<!-- use a dynamic transition name -->\n<router-view v-slot=\"{ Component, route }\">\n<transition :name=\"route.meta.transition\">\n<component :is=\"Component\" />\n</transition>\n</router-view>\nWe can add an after navigation hook to dynamically add information to the meta\nfield based on the depth of the route\nrouter.afterEach((to, from) => {\nconst toDepth = to.path.split('/').length\nconst fromDepth = from.path.split('/').length\nto.meta.transition = toDepth < fromDepth ? 'slide-right' : 'slide-left'\n})\nForcing a transition between reused views\nVue might automatically reuse components that look alike, avoiding any transition. Fortunately, it is possible to add a key\nattribute to force transitions. This also allows you to trigger transitions while staying on the same route with different params:\n<router-view v-slot=\"{ Component, route }\">\n<transition name=\"fade\">\n<component :is=\"Component\" :key=\"route.path\" />\n</transition>\n</router-view>",
    "metadata": {
      "source": "https://router.vuejs.org/guide/advanced/transitions",
      "title": "Transitions | Vue Router"
    }
  },
  {
    "page_content": "Waiting for the result of a Navigation\nWhen using router-link\n, Vue Router calls router.push\nto trigger a navigation. While the expected behavior for most links is to navigate a user to a new page, there are a few situations where users will remain on the same page:\n- Users are already on the page that they are trying to navigate to.\n- A navigation guard aborts the navigation by doing\nreturn false\n. - A new navigation guard takes place while the previous one not finished.\n- A navigation guard redirects somewhere else by returning a new location (e.g.\nreturn '/login'\n). - A navigation guard throws an\nError\n.\nIf we want to do something after a navigation is finished, we need a way to wait after calling router.push\n. Imagine we have a mobile menu that allows us to go to different pages and we only want to hide the menu once we have navigated to the new page, we might want to do something like this:\nrouter.push('/my-profile')\nthis.isMenuOpen = false\nBut this will close the menu right away because navigations are asynchronous, we need to await\nthe promise returned by router.push\n:\nawait router.push('/my-profile')\nthis.isMenuOpen = false\nNow the menu will close once the navigation is finished but it will also close if the navigation was prevented. We need a way to detect if we actually changed the page we are on or not.\nDetecting Navigation Failures\nIf a navigation is prevented, resulting in the user staying on the same page, the resolved value of the Promise\nreturned by router.push\nwill be a Navigation Failure. Otherwise, it will be a falsy value (usually undefined\n). This allows us to differentiate the case where we navigated away from where we are or not:\nconst navigationResult = await router.push('/my-profile')\nif (navigationResult) {\n// navigation prevented\n} else {\n// navigation succeeded (this includes the case of a redirection)\nthis.isMenuOpen = false\n}\nNavigation Failures are Error\ninstances with a few extra properties that gives us enough information to know what navigation was prevented and why. To check the nature of a navigation result, use the isNavigationFailure\nfunction:\nimport { NavigationFailureType, isNavigationFailure } from 'vue-router'\n// trying to leave the editing page of an article without saving\nconst failure = await router.push('/articles/2')\nif (isNavigationFailure(failure, NavigationFailureType.aborted)) {\n// show a small notification to the user\nshowToast('You have unsaved changes, discard and leave anyway?')\n}\nTIP\nIf you omit the second parameter: isNavigationFailure(failure)\n, it will only check if failure\nis a Navigation Failure.\nGlobal navigation failures\nYou can detect global navigation failures globally by using the router.afterEach()\nnavigation guard:\nrouter.afterEach((to, from, failure) => {\nif (failure) {\nsendToAnalytics(to, from, failure)\n}\n})\nDifferentiating Navigation Failures\nAs we said at the beginning, there are different situations aborting a navigation, all of them resulting in different Navigation Failures. They can be differentiated using the isNavigationFailure\nand NavigationFailureType\n. There are three different types:\naborted\n:false\nwas returned inside of a navigation guard to the navigation.cancelled\n: A new navigation took place before the current navigation could finish. e.g.router.push\nwas called while waiting inside of a navigation guard.duplicated\n: The navigation was prevented because we are already at the target location.\nNavigation Failures's properties\nAll navigation failures expose to\nand from\nproperties to reflect the current location as well as the target location for the navigation that failed:\n// trying to access the admin page\nrouter.push('/admin').then(failure => {\nif (isNavigationFailure(failure, NavigationFailureType.aborted)) {\nfailure.to.path // '/admin'\nfailure.from.path // '/'\n}\n})\nIn all cases, to\nand from\nare normalized route locations.\nDetecting Redirections\nWhen returning a new location inside of a Navigation Guard, we are triggering a new navigation that overrides the ongoing one. Differently from other return values, a redirection doesn't prevent a navigation, it creates a new one. It is therefore checked differently, by reading the redirectedFrom\nproperty in a Route Location:\nawait router.push('/my-profile')\nif (router.currentRoute.value.redirectedFrom) {\n// redirectedFrom is resolved route location like to and from in navigation guards\n}",
    "metadata": {
      "source": "https://router.vuejs.org/guide/advanced/navigation-failures",
      "title": "Waiting for the result of a Navigation | Vue Router"
    }
  },
  {
    "page_content": "Typed Routes v4.4.0+\nDANGER\n‼️ Experimental feature\nIt's possible to configure the router to have a map of typed routes. While this can be done manually, it is recommended to use the unplugin-vue-router plugin to generate the routes and the types automatically.\nManual Configuration\nHere is an example of how to manually configure typed routes:\nts\n// import the `RouteRecordInfo` type from vue-router to type your routes\nimport type { RouteRecordInfo } from 'vue-router'\n// Define an interface of routes\nexport interface RouteNamedMap {\n// each key is a name\nhome: RouteRecordInfo<\n// here we have the same name\n'home',\n// this is the path, it will appear in autocompletion\n'/',\n// these are the raw params. In this case, there are no params allowed\nRecord<never, never>,\n// these are the normalized params\nRecord<never, never>\n>\n// repeat for each route..\n// Note you can name them whatever you want\n'named-param': RouteRecordInfo<\n'named-param',\n'/:name',\n{ name: string | number }, // raw value\n{ name: string } // normalized value\n>\n'article-details': RouteRecordInfo<\n'article-details',\n'/articles/:id+',\n{ id: Array<number | string> },\n{ id: string[] }\n>\n'not-found': RouteRecordInfo<\n'not-found',\n'/:path(.*)',\n{ path: string },\n{ path: string }\n>\n}\n// Last, you will need to augment the Vue Router types with this map of routes\ndeclare module 'vue-router' {\ninterface TypesConfig {\nRouteNamedMap: RouteNamedMap\n}\n}\nTIP\nThis is indeed tedious and error-prone. That's why it's recommended to use unplugin-vue-router to generate the routes and the types automatically.",
    "metadata": {
      "source": "https://router.vuejs.org/guide/advanced/typed-routes",
      "title": "Typed Routes | Vue Router"
    }
  },
  {
    "page_content": "Getting Started\nVue Router is the official client-side routing solution for Vue.\nClient-side routing is used by single-page applications (SPAs) to tie the browser URL to the content seen by the user. As users navigate around the application, the URL updates accordingly, but the page doesn't need to be reloaded from the server.\nVue Router is built on Vue's component system. You configure routes to tell Vue Router which components to show for each URL path.\nPrerequisites\nThis guide will assume that you are already familiar with Vue itself. You don't need to be a Vue expert, but you may occasionally need to refer back to the core Vue documentation for more information about certain features.\nAn example\nTo introduce some of the main ideas, we're going to consider this example:\nLet's start by looking at the root component, App.vue\n.\nApp.vue\n<template>\n<h1>Hello App!</h1>\n<p>\n<strong>Current route path:</strong> {{ $route.fullPath }}\n</p>\n<nav>\n<RouterLink to=\"/\">Go to Home</RouterLink>\n<RouterLink to=\"/about\">Go to About</RouterLink>\n</nav>\n<main>\n<RouterView />\n</main>\n</template>\nThis template is using two components provided by Vue Router, RouterLink\nand RouterView\n.\nInstead of using regular <a>\ntags, we use the custom component RouterLink\nto create links. This allows Vue Router to change the URL without reloading the page, handle URL generation, encoding, and various other features. We'll go into more detail about RouterLink\nin later sections of the guide.\nThe RouterView\ncomponent tells Vue Router where to render the current route component. That's the component that corresponds to the current URL path. It doesn't have to be in App.vue\n, you can put it anywhere to adapt it to your layout, but it does need to be included somewhere, otherwise Vue Router won't render anything.\nThe example above also uses {{ $route.fullPath }}\n. You can use $route\nin your component templates to access an object that represents the current route.\nCreating the router instance\nThe router instance is created by calling the function createRouter()\n:\nimport { createMemoryHistory, createRouter } from 'vue-router'\nimport HomeView from './HomeView.vue'\nimport AboutView from './AboutView.vue'\nconst routes = [\n{ path: '/', component: HomeView },\n{ path: '/about', component: AboutView },\n]\nconst router = createRouter({\nhistory: createMemoryHistory(),\nroutes,\n})\nThe routes\noption defines the routes themselves, mapping URL paths to components. The component specified by the component\noption is the one that will be rendered by the <RouterView>\nin our earlier App.vue\n. These route components are sometimes referred to as views, though they are just normal Vue components.\nRoutes support various other options that we'll see later in the guide, but for now we only need path\nand component\n.\nThe history\noption controls how routes are mapped onto URLs and vice versa. For the Playground example we're using createMemoryHistory()\n, which ignores the browser URL entirely and uses its own internal URL instead. That works well for the Playground, but it's unlikely to be what you'd want in a real application. Typically, you'd want to use createWebHistory()\ninstead, or perhaps createWebHashHistory()\n. We'll cover that topic in more detail in the guide to History modes.\nRegistering the router plugin\nOnce we've created our router instance, we need to register it as a plugin by calling use()\non our application:\ncreateApp(App)\n.use(router)\n.mount('#app')\nOr, equivalently:\nconst app = createApp(App)\napp.use(router)\napp.mount('#app')\nLike with most Vue plugins, the call to use()\nneeds to happen before the call to mount()\n.\nIf you're curious about what this plugin does, some of its responsibilities include:\n- Globally registering the\nRouterView\nandRouterLink\ncomponents. - Adding the global\n$router\nand$route\nproperties. - Enabling the\nuseRouter()\nanduseRoute()\ncomposables. - Triggering the router to resolve the initial route.\nAccessing the router and current route\nYou'll likely want to access the router from elsewhere in your application.\nIf you're exporting the router instance from an ES module, you could import the router instance directly where you need it. In some cases this is the best approach, but we have other options if we're inside a component.\nIn component templates, the router instance is exposed as $router\n. This is similar to the $route\nproperty we saw earlier, but note the extra r\non the end.\nIf we're using the Options API, we can access these same two properties as this.$router\nand this.$route\nin our JavaScript code. The HomeView.vue\ncomponent in the Playground example accesses the router that way:\nexport default {\nmethods: {\ngoToAbout() {\nthis.$router.push('/about')\n},\n},\n}\nThis method is calling push()\n, which is used for programmatic navigation. We'll learn more about that later.\nWith the Composition API, we don't have access to the component instance via this\n, so Vue Router includes some composables that we can use instead. AboutView.vue\nin the Playground example is using that approach:\n<script setup>\nimport { computed } from 'vue'\nimport { useRoute, useRouter } from 'vue-router'\nconst router = useRouter()\nconst route = useRoute()\nconst search = computed({\nget() {\nreturn route.query.search ?? ''\n},\nset(search) {\nrouter.replace({ query: { search } })\n}\n})\n</script>\nIt's not necessary to understand all of that code right now. The key thing to notice is that the composables useRouter()\nand useRoute()\nare used to access the router instance and current route respectively.\nNext steps\nIf you'd like to see a complete example using Vite, you can use the create-vue scaffolding tool, which has the option to include Vue Router in its example project:\nnpm create vue@latest\nyarn create vue\npnpm create vue\nThe example project created by create-vue uses similar features to the ones we've seen here. You may find that a useful starting point for exploring the features introduced in the next few pages of this guide.\nConventions in this guide\nSingle-File Components\nVue Router is most commonly used in applications built using a bundler (e.g. Vite) and SFCs (i.e. .vue\nfiles). Most of the examples in this guide will be written in that style, but Vue Router itself doesn't require you to use build tools or SFCs.\nFor example, if you're using the global builds of Vue and Vue Router, the libraries are exposed via global objects, rather than imports:\nconst { createApp } = Vue\nconst { createRouter, createWebHistory } = VueRouter\nComponent API style\nVue Router can be used with both the Composition API and the Options API. Where relevant, the examples in this guide will show components written in both styles. Composition API examples will typically use <script setup>\n, rather than an explicit setup\nfunction.\nIf you need a refresher about the two styles, see Vue - API Styles.\nrouter\nand route\nThroughout the guide, we will often refer to the router instance as router\n. This is the object returned by createRouter()\n. How you access that object in your application will depend on the context. For example, in a component using the Composition API, it can be accessed by calling useRouter()\n. With the Options API, it can be accessed using this.$router\n.\nSimilarly, the current route will be referred to as route\n. It can be accessed in components using useRoute()\nor this.$route\n, depending on which API the component is using.\nRouterView\nand RouterLink\nThe components RouterView\nand RouterLink\nare both registered globally, so they don't need to be imported before using them in component templates. However, if you prefer, you can import them locally, e.g. import { RouterLink } from 'vue-router'\n.\nIn templates, component names can be written in either PascalCase or kebab-case. Vue's template compiler supports either format, so <RouterView>\nand <router-view>\nare usually equivalent. You should follow whatever convention is used within your project.\nIf you're using in-DOM templates then the usual caveats apply: component names must be written in kebab-case and self-closing tags are not supported. So rather than writing <RouterView />\n, you would need to use <router-view></router-view>\ninstead.",
    "metadata": {
      "source": "https://router.vuejs.org/guide/",
      "title": "Getting Started | Vue Router"
    }
  },
  {
    "page_content": "Redirect and Alias\nRedirect\nRedirecting is also done in the routes\nconfiguration. To redirect from /home\nto /\n:\nconst routes = [{ path: '/home', redirect: '/' }]\nThe redirect can also be targeting a named route:\nconst routes = [{ path: '/home', redirect: { name: 'homepage' } }]\nOr even use a function for dynamic redirecting:\nconst routes = [\n{\n// /search/screens -> /search?q=screens\npath: '/search/:searchText',\nredirect: to => {\n// the function receives the target route as the argument\n// we return a redirect path/location here.\nreturn { path: '/search', query: { q: to.params.searchText } }\n},\n},\n{\npath: '/search',\n// ...\n},\n]\nNote that Navigation Guards are not applied on the route that redirects, only on its target. e.g. In the above example, adding a beforeEnter\nguard to the /home\nroute would not have any effect.\nWhen writing a redirect\n, you can omit the component\noption because it is never directly reached so there is no component to render. The only exception are nested routes: if a route record has children\nand a redirect\nproperty, it should also have a component\nproperty.\nRelative redirecting\nIt's also possible to redirect to a relative location:\nconst routes = [\n{\n// will always redirect /users/123/posts to /users/123/profile\npath: '/users/:id/posts',\nredirect: to => {\n// the function receives the target route as the argument\n// a relative location doesn't start with `/`\n// or { path: 'profile'}\nreturn 'profile'\n},\n},\n]\nAlias\nA redirect means when the user visits /home\n, the URL will be replaced by /\n, and then matched as /\n. But what is an alias?\nAn alias of /\nas /home\nmeans when the user visits /home\n, the URL remains /home\n, but it will be matched as if the user is visiting /\n.\nThe above can be expressed in the route configuration as:\nconst routes = [{ path: '/', component: Homepage, alias: '/home' }]\nAn alias gives you the freedom to map a UI structure to an arbitrary URL, instead of being constrained by the configuration's nesting structure. Make the alias start with a /\nto make the path absolute in nested routes. You can even combine both and provide multiple aliases with an array:\nconst routes = [\n{\npath: '/users',\ncomponent: UsersLayout,\nchildren: [\n// this will render the UserList for these 3 URLs\n// - /users\n// - /users/list\n// - /people\n{ path: '', component: UserList, alias: ['/people', 'list'] },\n],\n},\n]\nIf your route has parameters, make sure to include them in any absolute alias:\nconst routes = [\n{\npath: '/users/:id',\ncomponent: UsersByIdLayout,\nchildren: [\n// this will render the UserDetails for these 3 URLs\n// - /users/24\n// - /users/24/profile\n// - /24\n{ path: 'profile', component: UserDetails, alias: ['/:id', ''] },\n],\n},\n]\nNote about SEO: when using aliases, make sure to define canonical links.",
    "metadata": {
      "source": "https://router.vuejs.org/guide/essentials/redirect-and-alias",
      "title": "Redirect and Alias | Vue Router"
    }
  },
  {
    "page_content": "Route Meta Fields\nSometimes, you might want to attach arbitrary information to routes like： transition names, or roles to control who can access the route, etc. This can be achieved through the meta\nproperty which accepts an object of properties and can be accessed on the route location and navigation guards. You can define meta\nproperties like this:\nconst routes = [\n{\npath: '/posts',\ncomponent: PostsLayout,\nchildren: [\n{\npath: 'new',\ncomponent: PostsNew,\n// only authenticated users can create posts\nmeta: { requiresAuth: true },\n},\n{\npath: ':id',\ncomponent: PostsDetail,\n// anybody can read a post\nmeta: { requiresAuth: false },\n},\n],\n},\n]\nSo how do we access this meta\nfield?\nFirst, each route object in the routes\nconfiguration is called a route record. Route records may be nested. Therefore when a route is matched, it can potentially match more than one route record.\nFor example, with the above route config, the URL /posts/new\nwill match both the parent route record (path: '/posts'\n) and the child route record (path: 'new'\n).\nAll route records matched by a route are exposed on the route\nobject (and also route objects in navigation guards) as the route.matched\nArray. We could loop through that array to check all meta\nfields, but Vue Router also provides you a route.meta\nthat is a non-recursive merge of all meta\nfields from parent to child. Meaning you can simply write:\nrouter.beforeEach((to, from) => {\n// instead of having to check every route record with\n// to.matched.some(record => record.meta.requiresAuth)\nif (to.meta.requiresAuth && !auth.isLoggedIn()) {\n// this route requires auth, check if logged in\n// if not, redirect to login page.\nreturn {\npath: '/login',\n// save the location we were at to come back later\nquery: { redirect: to.fullPath },\n}\n}\n})\nTypeScript\nIt is possible to type the meta field by extending the RouteMeta\ninterface from vue-router\n:\n// This can be directly added to any of your `.ts` files like `router.ts`\n// It can also be added to a `.d.ts` file. Make sure it's included in\n// project's tsconfig.json \"files\"\nimport 'vue-router'\n// To ensure it is treated as a module, add at least one `export` statement\nexport {}\ndeclare module 'vue-router' {\ninterface RouteMeta {\n// is optional\nisAdmin?: boolean\n// must be declared by every route\nrequiresAuth: boolean\n}\n}",
    "metadata": {
      "source": "https://router.vuejs.org/guide/advanced/meta",
      "title": "Route Meta Fields | Vue Router"
    }
  },
  {
    "page_content": "Lazy Loading Routes\nWhen building apps with a bundler, the JavaScript bundle can become quite large, and thus affect the page load time. It would be more efficient if we can split each route's components into separate chunks, and only load them when the route is visited.\nVue Router supports dynamic imports out of the box, meaning you can replace static imports with dynamic ones:\n// replace\n// import UserDetails from './views/UserDetails'\n// with\nconst UserDetails = () => import('./views/UserDetails.vue')\nconst router = createRouter({\n// ...\nroutes: [\n{ path: '/users/:id', component: UserDetails }\n// or use it directly in the route definition\n{ path: '/users/:id', component: () => import('./views/UserDetails.vue') },\n],\n})\nThe component\n(and components\n) option accepts a function that returns a Promise of a component and Vue Router will only fetch it when entering the page for the first time, then use the cached version. Which means you can also have more complex functions as long as they return a Promise:\nconst UserDetails = () =>\nPromise.resolve({\n/* component definition */\n})\nIn general, it's a good idea to always use dynamic imports for all your routes.\nNote\nDo not use Async components for routes. Async components can still be used inside route components but route component themselves are just dynamic imports.\nWhen using a bundler like webpack, this will automatically benefit from code splitting\nWhen using Babel, you will need to add the syntax-dynamic-import plugin so that Babel can properly parse the syntax.\nGrouping Components in the Same Chunk\nWith webpack\nSometimes we may want to group all the components nested under the same route into the same async chunk. To achieve that we need to use named chunks by providing a chunk name using a special comment syntax (requires webpack > 2.4):\nconst UserDetails = () =>\nimport(/* webpackChunkName: \"group-user\" */ './UserDetails.vue')\nconst UserDashboard = () =>\nimport(/* webpackChunkName: \"group-user\" */ './UserDashboard.vue')\nconst UserProfileEdit = () =>\nimport(/* webpackChunkName: \"group-user\" */ './UserProfileEdit.vue')\nwebpack will group any async module with the same chunk name into the same async chunk.\nWith Vite\nIn Vite you can define the chunks under the rollupOptions\n:\n// vite.config.js\nexport default defineConfig({\nbuild: {\nrollupOptions: {\n// https://rollupjs.org/guide/en/#outputmanualchunks\noutput: {\nmanualChunks: {\n'group-user': [\n'./src/UserDetails',\n'./src/UserDashboard',\n'./src/UserProfileEdit',\n],\n},\n},\n},\n},\n})",
    "metadata": {
      "source": "https://router.vuejs.org/guide/advanced/lazy-loading",
      "title": "Lazy Loading Routes | Vue Router"
    }
  },
  {
    "page_content": "Passing Props to Route Components\nUsing $route\nor useRoute()\nin your component creates a tight coupling with the route which limits the flexibility of the component as it can only be used on certain URLs. While this is not necessarily a bad thing, we can decouple this behavior with a props\noption.\nLet's return to our earlier example:\n<!-- User.vue -->\n<template>\n<div>\nUser {{ $route.params.id }}\n</div>\n</template>\nwith:\nimport User from './User.vue'\n// these are passed to `createRouter`\nconst routes = [\n{ path: '/users/:id', component: User },\n]\nWe can remove the direct dependency on $route\nin User.vue\nby declaring a prop instead:\n<!-- User.vue -->\n<script setup>\ndefineProps({\nid: String\n})\n</script>\n<template>\n<div>\nUser {{ id }}\n</div>\n</template>\n<!-- User.vue -->\n<script>\nexport default {\nprops: {\nid: String\n}\n}\n</script>\n<template>\n<div>\nUser {{ id }}\n</div>\n</template>\nWe can then configure the route to pass the id\nparam as a prop by setting props: true\n:\nconst routes = [\n{ path: '/user/:id', component: User, props: true }\n]\nThis allows you to use the component anywhere, which makes the component easier to reuse and test.\nBoolean mode\nWhen props\nis set to true\n, the route.params\nwill be set as the component props.\nNamed views\nFor routes with named views, you have to define the props\noption for each named view:\nconst routes = [\n{\npath: '/user/:id',\ncomponents: { default: User, sidebar: Sidebar },\nprops: { default: true, sidebar: false }\n}\n]\nObject mode\nWhen props\nis an object, this will be set as the component props as-is. Useful for when the props are static.\nconst routes = [\n{\npath: '/promotion/from-newsletter',\ncomponent: Promotion,\nprops: { newsletterPopup: false }\n}\n]\nFunction mode\nYou can create a function that returns props. This allows you to cast parameters into other types, combine static values with route-based values, etc.\nconst routes = [\n{\npath: '/search',\ncomponent: SearchUser,\nprops: route => ({ query: route.query.q })\n}\n]\nThe URL /search?q=vue\nwould pass {query: 'vue'}\nas props to the SearchUser\ncomponent.\nTry to keep the props\nfunction stateless, as it's only evaluated on route changes. Use a wrapper component if you need state to define the props, that way Vue can react to state changes.\nVia RouterView\nYou can also pass any props via the <RouterView>\nslot:\n<RouterView v-slot=\"{ Component }\">\n<component\n:is=\"Component\"\nview-prop=\"value\"\n/>\n</RouterView>\nWARNING\nIn this case, all view components will receive view-prop\n. This is usually not a good idea as it means that all of the view components have declared a view-prop\nprop, which is not necessarily true. If possible, use any of the options above.",
    "metadata": {
      "source": "https://router.vuejs.org/guide/essentials/passing-props",
      "title": "Passing Props to Route Components | Vue Router"
    }
  },
  {
    "page_content": "Active links\nIt's common for applications to have a navigation component that renders a list of RouterLink components. Within that list, we might want to style links to the currently active route differently from the others.\nThe RouterLink component adds two CSS classes to active links, router-link-active\nand router-link-exact-active\n. To understand the difference between them, we first need to consider how Vue Router decides that a link is active.\nWhen are links active?\nA RouterLink is considered to be active if:\n- It matches the same route record (i.e. configured route) as the current location.\n- It has the same values for the\nparams\nas the current location.\nIf you're using nested routes, any links to ancestor routes will also be considered active if the relevant params\nmatch.\nOther route properties, such as the query\n, are not taken into account.\nThe path doesn't necessarily need to be a perfect match. For example, using an alias\nwould still be considered a match, so long as it resolves to the same route record and params\n.\nIf a route has a redirect\n, it won't be followed when checking whether a link is active.\nExact active links\nAn exact match does not include ancestor routes.\nLet's imagine we have the following routes:\nconst routes = [\n{\npath: '/user/:username',\ncomponent: User,\nchildren: [\n{\npath: 'role/:roleId',\ncomponent: Role,\n},\n],\n},\n]\nThen consider these two links:\n<RouterLink to=\"/user/erina\">\nUser\n</RouterLink>\n<RouterLink to=\"/user/erina/role/admin\">\nRole\n</RouterLink>\nIf the current location path is /user/erina/role/admin\nthen these would both be considered active, so the class router-link-active\nwould be applied to both links. But only the second link would be considered exact, so only that second link would have the class router-link-exact-active\n.\nConfiguring the classes\nThe RouterLink component has two props, activeClass\nand exactActiveClass\n, that can be used to change the names of the classes that are applied:\n<RouterLink\nactiveClass=\"border-indigo-500\"\nexactActiveClass=\"border-indigo-700\"\n...\n>\nThe default class names can also be changed globally by passing the linkActiveClass\nand linkExactActiveClass\noptions to createRouter()\n:\nconst router = createRouter({\nlinkActiveClass: 'border-indigo-500',\nlinkExactActiveClass: 'border-indigo-700',\n// ...\n})\nSee Extending RouterLink for more advanced customization techniques using the v-slot\nAPI.",
    "metadata": {
      "source": "https://router.vuejs.org/guide/essentials/active-links",
      "title": "Active links | Vue Router"
    }
  },
  {
    "page_content": "Scroll Behavior\nWhen using client-side routing, we may want to scroll to top when navigating to a new route, or preserve the scrolling position of history entries just like real page reload does. Vue Router allows you to achieve these and even better, allows you to completely customize the scroll behavior on route navigation.\nNote: this feature only works if the browser supports history.pushState\n.\nWhen creating the router instance, you can provide the scrollBehavior\nfunction:\nconst router = createRouter({\nhistory: createWebHashHistory(),\nroutes: [...],\nscrollBehavior (to, from, savedPosition) {\n// return desired position\n}\n})\nThe scrollBehavior\nfunction receives the to\nand from\nroute objects, like Navigation Guards. The third argument, savedPosition\n, is only available if this is a popstate\nnavigation (triggered by the browser's back/forward buttons).\nThe function can return a ScrollToOptions\nposition object:\nconst router = createRouter({\nscrollBehavior(to, from, savedPosition) {\n// always scroll to top\nreturn { top: 0 }\n},\n})\nYou can also pass a CSS selector or a DOM element via el\n. In that scenario, top\nand left\nwill be treated as relative offsets to that element.\nconst router = createRouter({\nscrollBehavior(to, from, savedPosition) {\n// always scroll 10px above the element #main\nreturn {\n// could also be\n// el: document.getElementById('main'),\nel: '#main',\n// 10px above the element\ntop: 10,\n}\n},\n})\nIf a falsy value or an empty object is returned, no scrolling will happen.\nReturning the savedPosition\nwill result in a native-like behavior when navigating with back/forward buttons:\nconst router = createRouter({\nscrollBehavior(to, from, savedPosition) {\nif (savedPosition) {\nreturn savedPosition\n} else {\nreturn { top: 0 }\n}\n},\n})\nIf you want to simulate the \"scroll to anchor\" behavior:\nconst router = createRouter({\nscrollBehavior(to, from, savedPosition) {\nif (to.hash) {\nreturn {\nel: to.hash,\n}\n}\n},\n})\nIf your browser supports scroll behavior, you can make it smooth:\nconst router = createRouter({\nscrollBehavior(to, from, savedPosition) {\nif (to.hash) {\nreturn {\nel: to.hash,\nbehavior: 'smooth',\n}\n}\n}\n})\nDelaying the scroll\nSometimes we need to wait a bit before scrolling in the page. For example, when dealing with transitions, we want to wait for the transition to finish before scrolling. To do this you can return a Promise that returns the desired position descriptor. Here is an example where we wait 500ms before scrolling:\nconst router = createRouter({\nscrollBehavior(to, from, savedPosition) {\nreturn new Promise((resolve, reject) => {\nsetTimeout(() => {\nresolve({ left: 0, top: 0 })\n}, 500)\n})\n},\n})\nIt's possible to hook this up with events from a page-level transition component to make the scroll behavior play nicely with your page transitions, but due to the possible variance and complexity in use cases, we simply provide this primitive to enable specific userland implementations.",
    "metadata": {
      "source": "https://router.vuejs.org/guide/advanced/scroll-behavior",
      "title": "Scroll Behavior | Vue Router"
    }
  },
  {
    "page_content": "Migrating from Vue 2\nMost of Vue Router API has remained unchanged during its rewrite from v3 (for Vue 2) to v4 (for Vue 3) but there are still a few breaking changes that you might encounter while migrating your application. This guide is here to help you understand why these changes happened and how to adapt your application to make it work with Vue Router 4.\nBreaking Changes\nChanges are ordered by their usage. It is therefore recommended to follow this list in order.\nnew Router becomes createRouter\nVue Router is no longer a class but a set of functions. Instead of writing new Router()\n, you now have to call createRouter\n:\n// previously was\n// import Router from 'vue-router'\nimport { createRouter } from 'vue-router'\nconst router = createRouter({\n// ...\n})\nNew history\noption to replace mode\nThe mode: 'history'\noption has been replaced with a more flexible one named history\n. Depending on which mode you were using, you will have to replace it with the appropriate function:\n\"history\"\n:createWebHistory()\n\"hash\"\n:createWebHashHistory()\n\"abstract\"\n:createMemoryHistory()\nHere is a full snippet:\nimport { createRouter, createWebHistory } from 'vue-router'\n// there is also createWebHashHistory and createMemoryHistory\ncreateRouter({\nhistory: createWebHistory(),\nroutes: [],\n})\nOn SSR, you need to manually pass the appropriate history:\n// router.js\nlet history = isServer ? createMemoryHistory() : createWebHistory()\nlet router = createRouter({ routes, history })\n// somewhere in your server-entry.js\nrouter.push(req.url) // request url\nrouter.isReady().then(() => {\n// resolve the request\n})\nReason: enable tree shaking of non used histories as well as implementing custom histories for advanced use cases like native solutions.\nMoved the base\noption\nThe base\noption is now passed as the first argument to createWebHistory\n(and other histories):\nimport { createRouter, createWebHistory } from 'vue-router'\ncreateRouter({\nhistory: createWebHistory('/base-directory/'),\nroutes: [],\n})\nRemoval of the fallback\noption\nThe fallback\noption is no longer supported when creating the router:\n-new VueRouter({\n+createRouter({\n- fallback: false,\n// other options...\n})\nReason: All browsers supported by Vue support the HTML5 History API, allowing us to avoid hacks around modifying location.hash\nand directly use history.pushState()\n.\nRemoved *\n(star or catch all) routes\nCatch all routes (*\n, /*\n) must now be defined using a parameter with a custom regex:\nconst routes = [\n// pathMatch is the name of the param, e.g., going to /not/found yields\n// { params: { pathMatch: ['not', 'found'] }}\n// this is thanks to the last *, meaning repeated params and it is necessary if you\n// plan on directly navigating to the not-found route using its name\n{ path: '/:pathMatch(.*)*', name: 'not-found', component: NotFound },\n// if you omit the last `*`, the `/` character in params will be encoded when resolving or pushing\n{ path: '/:pathMatch(.*)', name: 'bad-not-found', component: NotFound },\n]\n// bad example if using named routes:\nrouter.resolve({\nname: 'bad-not-found',\nparams: { pathMatch: 'not/found' },\n}).href // '/not%2Ffound'\n// good example:\nrouter.resolve({\nname: 'not-found',\nparams: { pathMatch: ['not', 'found'] },\n}).href // '/not/found'\nTIP\nYou don't need to add the *\nfor repeated params if you don't plan to directly push to the not found route using its name. If you call router.push('/not/found/url')\n, it will provide the right pathMatch\nparam.\nReason: Vue Router doesn't use path-to-regexp\nanymore, instead it implements its own parsing system that allows route ranking and enables dynamic routing. Since we usually add one single catch-all route per project, there is no big benefit in supporting a special syntax for *\n. The encoding of params is encoding across routes, without exception to make things easier to predict.\nThe currentRoute\nproperty is now a ref()\nPreviously the properties of the currentRoute\nobject on a router instance could be accessed directly.\nWith the introduction of vue-router v4, the underlying type of the currentRoute\nobject on the router instance has changed to Ref<RouteLocationNormalizedLoaded>\n, which comes from the newer reactivity fundamentals introduced in Vue 3.\nWhile this doesn't change anything if you're reading the route with useRoute()\nor this.$route\n, if you're accessing it directly on the router instance, you will need to access the actual route object via currentRoute.value\n:\nconst { page } = router.currentRoute.query\nconst { page } = router.currentRoute.value.query\nReplaced onReady\nwith isReady\nThe existing router.onReady()\nfunction has been replaced with router.isReady()\nwhich doesn't take any argument and returns a Promise:\n// replace\nrouter.onReady(onSuccess, onError)\n// with\nrouter.isReady().then(onSuccess).catch(onError)\n// or use await:\ntry {\nawait router.isReady()\n// onSuccess\n} catch (err) {\n// onError\n}\nscrollBehavior\nchanges\nThe object returned in scrollBehavior\nis now similar to ScrollToOptions\n: x\nis renamed to left\nand y\nis renamed to top\n. See RFC.\nReason: making the object similar to ScrollToOptions\nto make it feel more familiar with native JS APIs and potentially enable future new options.\n<router-view>\n, <keep-alive>\n, and <transition>\ntransition\nand keep-alive\nmust now be used inside of RouterView\nvia the v-slot\nAPI:\n<router-view v-slot=\"{ Component }\">\n<transition>\n<keep-alive>\n<component :is=\"Component\" />\n</keep-alive>\n</transition>\n</router-view>\nReason: This was a necessary change. See the related RFC.\nRemoval of append\nprop in <router-link>\nThe append\nprop has been removed from <router-link>\n. You can manually concatenate the value to an existing path\ninstead:\nreplace\n<router-link to=\"child-route\" append>to relative child</router-link>\nwith\n<router-link :to=\"append($route.path, 'child-route')\">\nto relative child\n</router-link>\nYou must define a global append\nfunction on your App instance:\napp.config.globalProperties.append = (path, pathToAppend) =>\npath + (path.endsWith('/') ? '' : '/') + pathToAppend\nReason: append\nwasn't used very often, is easy to replicate in user land.\nRemoval of event\nand tag\nprops in <router-link>\nBoth event\n, and tag\nprops have been removed from <router-link>\n. You can use the v-slot\nAPI to fully customize <router-link>\n:\nreplace\n<router-link to=\"/about\" tag=\"span\" event=\"dblclick\">About Us</router-link>\nwith\n<router-link to=\"/about\" custom v-slot=\"{ navigate }\">\n<span @click=\"navigate\" @keypress.enter=\"navigate\" role=\"link\">About Us</span>\n</router-link>\nReason: These props were often used together to use something different from an <a>\ntag but were introduced before the v-slot\nAPI and are not used enough to justify adding to the bundle size for everybody.\nRemoval of the exact\nprop in <router-link>\nThe exact\nprop has been removed because the caveat it was fixing is no longer present so you should be able to safely remove it. There are however two things you should be aware of:\n- Routes are now active based on the route records they represent instead of the generated route location objects and their\npath\n,query\n, andhash\nproperties - Only the\npath\nsection is matched,query\n, andhash\naren't taken into account anymore\nIf you wish to customize this behavior, e.g. take into account the hash\nsection, you should use the v-slot\nAPI to extend <router-link>\n.\nReason: See the RFC about active matching changes for more details.\nNavigation guards in mixins are ignored\nAt the moment navigation guards in mixins are not supported. You can track its support at vue-router#454.\nRemoval of router.match\nand changes to router.resolve\nBoth router.match\n, and router.resolve\nhave been merged together into router.resolve\nwith a slightly different signature. Refer to the API for more details.\nReason: Uniting multiple methods that were used for the same purpose.\nRemoval of router.getMatchedComponents()\nThe method router.getMatchedComponents\nis now removed as matched components can be retrieved from router.currentRoute.value.matched\n:\nrouter.currentRoute.value.matched.flatMap(record =>\nObject.values(record.components)\n)\nReason: This method was only used during SSR and is a one liner that can be done by the user.\nRedirect records cannot use special paths\nPreviously, a non documented feature allowed to set a redirect record to a special path like /events/:id\nand it would reuse an existing param id\n. This is no longer possible and there are two options:\n- Using the name of the route without the param:\nredirect: { name: 'events' }\n. Note this won't work if the param:id\nis optional - Using a function to recreate the new location based on the target:\nredirect: to => ({ name: 'events', params: to.params })\nReason: This syntax was rarely used and another way of doing things that wasn't shorter enough compared to the versions above while introducing some complexity and making the router heavier.\nAll navigations are now always asynchronous\nAll navigations, including the first one, are now asynchronous, meaning that, if you use a transition\n, you may need to wait for the router to be ready before mounting the app:\napp.use(router)\n// Note: on Server Side, you need to manually push the initial location\nrouter.isReady().then(() => app.mount('#app'))\nOtherwise there will be an initial transition as if you provided the appear\nprop to transition\nbecause the router displays its initial location (nothing) and then displays the first location.\nNote that if you have navigation guards upon the initial navigation, you might not want to block the app render until they are resolved unless you are doing Server Side Rendering. In this scenario, not waiting the router to be ready to mount the app would yield the same result as in Vue 2.\nRemoval of router.app\nrouter.app\nused to represent the last root component (Vue instance) that injected the router. Vue Router can now be safely used by multiple Vue applications at the same time. You can still add it when using the router:\napp.use(router)\nrouter.app = app\nYou can also extend the TypeScript definition of the Router\ninterface to add the app\nproperty.\nReason: Vue 3 applications do not exist in Vue 2 and now we properly support multiple applications using the same Router instance, so having an app\nproperty would have been misleading because it would have been the application instead of the root instance.\nPassing content to route components' <slot>\nBefore you could directly pass a template to be rendered by a route components' <slot>\nby nesting it under a <router-view>\ncomponent:\n<router-view>\n<p>In Vue Router 3, I render inside the route component</p>\n</router-view>\nBecause of the introduction of the v-slot\napi for <router-view>\n, you must pass it to the <component>\nusing the v-slot\nAPI:\n<router-view v-slot=\"{ Component }\">\n<component :is=\"Component\">\n<p>In Vue Router 3, I render inside the route component</p>\n</component>\n</router-view>\nRemoval of parent\nfrom route locations\nThe parent\nproperty has been removed from normalized route locations (this.$route\nand object returned by router.resolve\n). You can still access it via the matched\narray:\nconst parent = this.$route.matched[this.$route.matched.length - 2]\nReason: Having parent\nand children\ncreates unnecessary circular references while the properties could be retrieved already through matched\n.\nRemoval of pathToRegexpOptions\nThe pathToRegexpOptions\nand caseSensitive\nproperties of route records have been replaced with sensitive\nand strict\noptions for createRouter()\n. They can now also be directly passed when creating the router with createRouter()\n. Any other option specific to path-to-regexp\nhas been removed as path-to-regexp\nis no longer used to parse paths.\nRemoval of unnamed parameters\nDue to the removal of path-to-regexp\n, unnamed parameters are no longer supported:\n/foo(/foo)?/suffix\nbecomes/foo/:_(foo)?/suffix\n/foo(foo)?\nbecomes/foo:_(foo)?\n/foo/(.*)\nbecomes/foo/:_(.*)\nTIP\nNote you can use any name instead of _\nfor the param. The point is to provide one.\nUsage of history.state\nVue Router saves information on the history.state\n. If you have any code manually calling history.pushState()\n, you should likely avoid it or refactor it with a regular router.push()\nand a history.replaceState()\n:\n// replace\nhistory.pushState(myState, '', url)\n// with\nawait router.push(url)\nhistory.replaceState({ ...history.state, ...myState }, '')\nSimilarly, if you were calling history.replaceState()\nwithout preserving the current state, you will need to pass the current history.state\n:\n// replace\nhistory.replaceState({}, '', url)\n// with\nhistory.replaceState(history.state, '', url)\nReason: We use the history state to save information about the navigation like the scroll position, previous location, etc.\nroutes\noption is required in options\nThe property routes\nis now required in options\n.\ncreateRouter({ routes: [] })\nReason: The router is designed to be created with routes even though you can add them later on. You need at least one route in most scenarios and this is written once per app in general.\nNon existent named routes\nPushing or resolving a non existent named route throws an error:\n// Oops, we made a typo in name\nrouter.push({ name: 'homee' }) // throws\nrouter.resolve({ name: 'homee' }) // throws\nReason: Previously, the router would navigate to /\nbut display nothing (instead of the home page). Throwing an error makes more sense because we cannot produce a valid URL to navigate to.\nMissing required params\non named routes\nPushing or resolving a named route without its required params will throw an error:\n// given the following route:\nconst routes = [{ path: '/users/:id', name: 'user', component: UserDetails }]\n// Missing the `id` param will fail\nrouter.push({ name: 'user' })\nrouter.resolve({ name: 'user' })\nReason: Same as above.\nNamed children routes with an empty path\nno longer appends a slash\nGiven any nested named route with an empty path\n:\nconst routes = [\n{\npath: '/dashboard',\nname: 'dashboard-parent',\ncomponent: DashboardParent,\nchildren: [\n{ path: '', name: 'dashboard', component: DashboardDefault },\n{\npath: 'settings',\nname: 'dashboard-settings',\ncomponent: DashboardSettings,\n},\n],\n},\n]\nNavigating or resolving to the named route dashboard\nwill now produce a URL without a trailing slash:\nrouter.resolve({ name: 'dashboard' }).href // '/dashboard'\nThis has an important side effect about children redirect\nrecords like these:\nconst routes = [\n{\npath: '/parent',\ncomponent: Parent,\nchildren: [\n// this would now redirect to `/home` instead of `/parent/home`\n{ path: '', redirect: 'home' },\n{ path: 'home', component: Home },\n],\n},\n]\nNote this will work if path\nwas /parent/\nas the relative location home\nto /parent/\nis indeed /parent/home\nbut the relative location of home\nto /parent\nis /home\n.\nReason: This is to make trailing slash behavior consistent: by default all routes allow a trailing slash. It can be disabled by using the strict\noption and manually appending (or not) a slash to the routes.\n$route\nproperties Encoding\nDecoded values in params\n, query\n, and hash\nare now consistent no matter where the navigation is initiated (older browsers will still produce unencoded path\nand fullPath\n). The initial navigation should yield the same results as in-app navigations.\nGiven any normalized route location:\n- Values in\npath\n,fullPath\nare not decoded anymore. They will appear as provided by the browser (most browsers provide them encoded). e.g. directly writing on the address barhttps://example.com/hello world\nwill yield the encoded version:https://example.com/hello%20world\nand bothpath\nandfullPath\nwill be/hello%20world\n. hash\nis now decoded, that way it can be copied over:router.push({ hash: $route.hash })\nand be used directly in scrollBehavior'sel\noption.- When using\npush\n,resolve\n, andreplace\nand providing astring\nlocation or apath\nproperty in an object, it must be encoded (like in the previous version). On the other hand,params\n,query\nandhash\nmust be provided in its unencoded version. - The slash character (\n/\n) is now properly decoded insideparams\nwhile still producing an encoded version on the URL:%2F\n.\nReason: This allows to easily copy existing properties of a location when calling router.push()\nand router.resolve()\n, and make the resulting route location consistent across browsers. router.push()\nis now idempotent, meaning that calling router.push(route.fullPath)\n, router.push({ hash: route.hash })\n, router.push({ query: route.query })\n, and router.push({ params: route.params })\nwill not create extra encoding.\nTypeScript changes\nTo make typings more consistent and expressive, some types have been renamed:\nvue-router@3 | vue-router@4 |\n---|---|\nRouteConfig | RouteRecordRaw |\nLocation | RouteLocation |\nRoute | RouteLocationNormalized |\nNew Features\nSome of new features to keep an eye on in Vue Router 4 include:",
    "metadata": {
      "source": "https://router.vuejs.org/guide/migration/",
      "title": "Migrating from Vue 2 | Vue Router"
    }
  },
  {
    "page_content": "Dynamic Route Matching with Params\nVery often we will need to map routes with the given pattern to the same component. For example, we may have a User\ncomponent which should be rendered for all users but with different user IDs. In Vue Router we can use a dynamic segment in the path to achieve that, we call that a param:\nimport User from './User.vue'\n// these are passed to `createRouter`\nconst routes = [\n// dynamic segments start with a colon\n{ path: '/users/:id', component: User },\n]\nNow URLs like /users/johnny\nand /users/jolyne\nwill both map to the same route.\nA param is denoted by a colon :\n. When a route is matched, the value of its params will be exposed as route.params\nin every component. Therefore, we can render the current user ID by updating User\n's template to this:\n<template>\n<div>\n<!-- The current route is accessible as $route in the template -->\nUser {{ $route.params.id }}\n</div>\n</template>\nYou can have multiple params in the same route, and they will map to corresponding fields on route.params\n. Examples:\npattern | matched path | route.params |\n---|---|---|\n/users/:username | /users/eduardo | { username: 'eduardo' } |\n/users/:username/posts/:postId | /users/eduardo/posts/123 | { username: 'eduardo', postId: '123' } |\nIn addition to route.params\n, the route\nobject also exposes other useful information such as route.query\n(if there is a query in the URL), route.hash\n, etc. You can check out the full details in the API Reference.\nA working demo of this example can be found here.\nReacting to Params Changes\nOne thing to note when using routes with params is that when the user navigates from /users/johnny\nto /users/jolyne\n, the same component instance will be reused. Since both routes render the same component, this is more efficient than destroying the old instance and then creating a new one. However, this also means that the lifecycle hooks of the component will not be called.\nTo react to params changes in the same component, you can simply watch anything on the route\nobject, in this scenario, the route.params\n:\n<script setup>\nimport { watch } from 'vue'\nimport { useRoute } from 'vue-router'\nconst route = useRoute()\nwatch(\n() => route.params.id,\n(newId, oldId) => {\n// react to route changes...\n}\n)\n</script>\n<script>\nexport default {\ncreated() {\nthis.$watch(\n() => this.$route.params.id,\n(newId, oldId) => {\n// react to route changes...\n}\n)\n},\n}\n</script>\nOr, use the beforeRouteUpdate\nnavigation guard, which also allows you to cancel the navigation:\n<script setup>\nimport { onBeforeRouteUpdate } from 'vue-router'\n// ...\nonBeforeRouteUpdate(async (to, from) => {\n// react to route changes...\nuserData.value = await fetchUser(to.params.id)\n})\n</script>\n<script>\nexport default {\nasync beforeRouteUpdate(to, from) {\n// react to route changes...\nthis.userData = await fetchUser(to.params.id)\n},\n// ...\n}\n</script>\nCatch all / 404 Not found Route\nRegular params will only match characters in between url fragments, separated by /\n. If we want to match anything, we can use a custom param regexp by adding the regexp inside parentheses right after the param:\nconst routes = [\n// will match everything and put it under `route.params.pathMatch`\n{ path: '/:pathMatch(.*)*', name: 'NotFound', component: NotFound },\n// will match anything starting with `/user-` and put it under `route.params.afterUser`\n{ path: '/user-:afterUser(.*)', component: UserGeneric },\n]\nIn this specific scenario, we are using a custom regexp between parentheses and marking the pathMatch\nparam as optionally repeatable. This allows us to directly navigate to the route if we need to by splitting the path\ninto an array:\nrouter.push({\nname: 'NotFound',\n// preserve current path and remove the first char to avoid the target URL starting with `//`\nparams: { pathMatch: route.path.substring(1).split('/') },\n// preserve existing query and hash if any\nquery: route.query,\nhash: route.hash,\n})\nSee more in the repeated params section.\nIf you are using History mode, make sure to follow the instructions to correctly configure your server as well.\nAdvanced Matching Patterns\nVue Router uses its own path matching syntax, inspired by the one used by express\n, so it supports many advanced matching patterns such as optional params, zero or more / one or more requirements, and even custom regex patterns. Please check the Advanced Matching documentation to explore them.",
    "metadata": {
      "source": "https://router.vuejs.org/guide/essentials/dynamic-matching",
      "title": "Dynamic Route Matching with Params | Vue Router"
    }
  },
  {
    "page_content": "Navigation Guards\nAs the name suggests, the navigation guards provided by Vue router are primarily used to guard navigations either by redirecting it or canceling it. There are a number of ways to hook into the route navigation process: globally, per-route, or in-component.\nGlobal Before Guards\nYou can register global before guards using router.beforeEach\n:\nconst router = createRouter({ ... })\nrouter.beforeEach((to, from) => {\n// ...\n// explicitly return false to cancel the navigation\nreturn false\n})\nGlobal before guards are called in creation order, whenever a navigation is triggered. Guards may be resolved asynchronously, and the navigation is considered pending before all hooks have been resolved.\nEvery guard function receives two arguments:\nto\n: the target route location in a normalized format being navigated to.from\n: the current route location in a normalized format being navigated away from.\nAnd can optionally return any of the following values:\nfalse\n: cancel the current navigation. If the browser URL was changed (either manually by the user or via back button), it will be reset to that of thefrom\nroute.A Route Location: Redirect to a different location by passing a route location as if you were calling\nrouter.push()\n, which allows you to pass options likereplace: true\norname: 'home'\n. The current navigation is dropped and a new one is created with the samefrom\n.jsrouter.beforeEach(async (to, from) => { if ( // make sure the user is authenticated !isAuthenticated && // ❗️ Avoid an infinite redirect to.name !== 'Login' ) { // redirect the user to the login page return { name: 'Login' } } })\nIt's also possible to throw an Error\nif an unexpected situation was met. This will also cancel the navigation and call any callback registered via router.onError()\n.\nIf nothing, undefined\nor true\nis returned, the navigation is validated, and the next navigation guard is called.\nAll of the things above work the same way with async\nfunctions and Promises:\nrouter.beforeEach(async (to, from) => {\n// canUserAccess() returns `true` or `false`\nconst canAccess = await canUserAccess(to)\nif (!canAccess) return '/login'\n})\nOptional third argument next\nIn previous versions of Vue Router, it was also possible to use a third argument next\n, this was a common source of mistakes and went through an RFC to remove it. However, it is still supported, meaning you can pass a third argument to any navigation guard. In that case, you must call next\nexactly once in any given pass through a navigation guard. It can appear more than once, but only if the logical paths have no overlap, otherwise the hook will never be resolved or produce errors. Here is a bad example of redirecting the user to /login\nif they are not authenticated:\n// BAD\nrouter.beforeEach((to, from, next) => {\nif (to.name !== 'Login' && !isAuthenticated) next({ name: 'Login' })\n// if the user is not authenticated, `next` is called twice\nnext()\n})\nHere is the correct version:\n// GOOD\nrouter.beforeEach((to, from, next) => {\nif (to.name !== 'Login' && !isAuthenticated) next({ name: 'Login' })\nelse next()\n})\nGlobal Resolve Guards\nYou can register a global guard with router.beforeResolve\n. This is similar to router.beforeEach\nbecause it triggers on every navigation, but resolve guards are called right before the navigation is confirmed, after all in-component guards and async route components are resolved. Here is an example that ensures the user has given access to the Camera for routes that have defined a custom meta property requiresCamera\n:\nrouter.beforeResolve(async to => {\nif (to.meta.requiresCamera) {\ntry {\nawait askForCameraPermission()\n} catch (error) {\nif (error instanceof NotAllowedError) {\n// ... handle the error and then cancel the navigation\nreturn false\n} else {\n// unexpected error, cancel the navigation and pass the error to the global handler\nthrow error\n}\n}\n}\n})\nrouter.beforeResolve\nis the ideal spot to fetch data or do any other operation that you want to avoid doing if the user cannot enter a page.\nGlobal After Hooks\nYou can also register global after hooks, however unlike guards, these hooks do not get a next\nfunction and cannot affect the navigation:\nrouter.afterEach((to, from) => {\nsendToAnalytics(to.fullPath)\n})\nThey are useful for analytics, changing the title of the page, accessibility features like announcing the page and many other things.\nThey also reflect navigation failures as the third argument:\nrouter.afterEach((to, from, failure) => {\nif (!failure) sendToAnalytics(to.fullPath)\n})\nLearn more about navigation failures on its guide.\nGlobal injections within guards\nSince Vue 3.3, it is possible to use inject()\nwithin navigation guards. This is useful for injecting global properties like the pinia stores. Anything that is provided with app.provide()\nis also accessible within router.beforeEach()\n, router.beforeResolve()\n, router.afterEach()\n:\n// main.ts\nconst app = createApp(App)\napp.provide('global', 'hello injections')\n// router.ts or main.ts\nrouter.beforeEach((to, from) => {\nconst global = inject('global') // 'hello injections'\n// a pinia store\nconst userStore = useAuthStore()\n// ...\n})\nPer-Route Guard\nYou can define beforeEnter\nguards directly on a route's configuration object:\nconst routes = [\n{\npath: '/users/:id',\ncomponent: UserDetails,\nbeforeEnter: (to, from) => {\n// reject the navigation\nreturn false\n},\n},\n]\nbeforeEnter\nguards only trigger when entering the route, they don't trigger when the params\n, query\nor hash\nchange e.g. going from /users/2\nto /users/3\nor going from /users/2#info\nto /users/2#projects\n. They are only triggered when navigating from a different route.\nYou can also pass an array of functions to beforeEnter\n, this is useful when reusing guards for different routes:\nfunction removeQueryParams(to) {\nif (Object.keys(to.query).length)\nreturn { path: to.path, query: {}, hash: to.hash }\n}\nfunction removeHash(to) {\nif (to.hash) return { path: to.path, query: to.query, hash: '' }\n}\nconst routes = [\n{\npath: '/users/:id',\ncomponent: UserDetails,\nbeforeEnter: [removeQueryParams, removeHash],\n},\n{\npath: '/about',\ncomponent: UserDetails,\nbeforeEnter: [removeQueryParams],\n},\n]\nWhen working with nested routes, both parent and child routes can use beforeEnter\n. When placed on a parent route, it won't be triggered when moving between children with that same parent. For example:\nconst routes = [\n{\npath: '/user',\nbeforeEnter() {\n// ...\n},\nchildren: [\n{ path: 'list', component: UserList },\n{ path: 'details', component: UserDetails },\n],\n},\n]\nThe beforeEnter\nin the example above won't be called when moving between /user/list\nand /user/details\n, as they share the same parent. If we put the beforeEnter\nguard directly on the details\nroute instead, that would be called when moving between those two routes.\nTIP\nIt is possible to achieve similar behavior to per-route guards by using route meta fields and global navigation guards.\nIn-Component Guards\nFinally, you can directly define route navigation guards inside route components (the ones passed to the router configuration)\nUsing the Options API\nYou can add the following options to route components:\nbeforeRouteEnter\nbeforeRouteUpdate\nbeforeRouteLeave\n<script>\nexport default {\nbeforeRouteEnter(to, from) {\n// called before the route that renders this component is confirmed.\n// does NOT have access to `this` component instance,\n// because it has not been created yet when this guard is called!\n},\nbeforeRouteUpdate(to, from) {\n// called when the route that renders this component has changed, but this component is reused in the new route.\n// For example, given a route with params `/users/:id`, when we navigate between `/users/1` and `/users/2`,\n// the same `UserDetails` component instance will be reused, and this hook will be called when that happens.\n// Because the component is mounted while this happens, the navigation guard has access to `this` component instance.\n},\nbeforeRouteLeave(to, from) {\n// called when the route that renders this component is about to be navigated away from.\n// As with `beforeRouteUpdate`, it has access to `this` component instance.\n},\n}\n</script>\nThe beforeRouteEnter\nguard does NOT have access to this\n, because the guard is called before the navigation is confirmed, thus the new entering component has not even been created yet.\nHowever, you can access the instance by passing a callback to next\n. The callback will be called when the navigation is confirmed, and the component instance will be passed to the callback as the argument:\nbeforeRouteEnter (to, from, next) {\nnext(vm => {\n// access to component public instance via `vm`\n})\n}\nNote that beforeRouteEnter\nis the only guard that supports passing a callback to next\n. For beforeRouteUpdate\nand beforeRouteLeave\n, this\nis already available, so passing a callback is unnecessary and therefore not supported:\nbeforeRouteUpdate (to, from) {\n// just use `this`\nthis.name = to.params.name\n}\nThe leave guard is usually used to prevent the user from accidentally leaving the route with unsaved edits. The navigation can be canceled by returning false\n.\nbeforeRouteLeave (to, from) {\nconst answer = window.confirm('Do you really want to leave? you have unsaved changes!')\nif (!answer) return false\n}\nUsing the Composition API\nIf you are writing your component using the Composition API, you can add update and leave guards through onBeforeRouteUpdate\nand onBeforeRouteLeave\nrespectively. Please refer to the Composition API section for more details.\nThe Full Navigation Resolution Flow\n- Navigation triggered.\n- Call\nbeforeRouteLeave\nguards in deactivated components. - Call global\nbeforeEach\nguards. - Call\nbeforeRouteUpdate\nguards in reused components. - Call\nbeforeEnter\nin route configs. - Resolve async route components.\n- Call\nbeforeRouteEnter\nin activated components. - Call global\nbeforeResolve\nguards. - Navigation is confirmed.\n- Call global\nafterEach\nhooks. - DOM updates triggered.\n- Call callbacks passed to\nnext\ninbeforeRouteEnter\nguards with instantiated instances.",
    "metadata": {
      "source": "https://router.vuejs.org/guide/advanced/navigation-guards",
      "title": "Navigation Guards | Vue Router"
    }
  },
  {
    "page_content": "Nested Routes\nSome applications' UIs are composed of components that are nested multiple levels deep. In this case, it is very common that the segments of a URL correspond to a certain structure of nested components, for example:\n/user/johnny/profile /user/johnny/posts\n┌──────────────────┐ ┌──────────────────┐\n│ User │ │ User │\n│ ┌──────────────┐ │ │ ┌──────────────┐ │\n│ │ Profile │ │ ●────────────▶ │ │ Posts │ │\n│ │ │ │ │ │ │ │\n│ └──────────────┘ │ │ └──────────────┘ │\n└──────────────────┘ └──────────────────┘\nWith Vue Router, you can express this relationship using nested route configurations.\nGiven the app we created in the last chapter:\n<!-- App.vue -->\n<template>\n<router-view />\n</template>\n<!-- User.vue -->\n<template>\n<div>\nUser {{ $route.params.id }}\n</div>\n</template>\nimport User from './User.vue'\n// these are passed to `createRouter`\nconst routes = [{ path: '/user/:id', component: User }]\nThe <router-view>\nhere is a top-level router-view\n. It renders the component matched by a top level route. Similarly, a rendered component can also contain its own, nested <router-view>\n. For example, if we add one inside the User\ncomponent's template:\n<!-- User.vue -->\n<template>\n<div class=\"user\">\n<h2>User {{ $route.params.id }}</h2>\n<router-view />\n</div>\n</template>\nTo render components into this nested router-view\n, we need to use the children\noption in any of the routes:\nconst routes = [\n{\npath: '/user/:id',\ncomponent: User,\nchildren: [\n{\n// UserProfile will be rendered inside User's <router-view>\n// when /user/:id/profile is matched\npath: 'profile',\ncomponent: UserProfile,\n},\n{\n// UserPosts will be rendered inside User's <router-view>\n// when /user/:id/posts is matched\npath: 'posts',\ncomponent: UserPosts,\n},\n],\n},\n]\nNote that nested paths that start with /\nwill be treated as root paths. This allows you to leverage the component nesting without having to use a nested URL.\nAs you can see, the children\noption is just another Array of routes like routes\nitself. Therefore, you can keep nesting views as much as you need.\nAt this point, with the above configuration, when you visit /user/eduardo\n, nothing will be rendered inside User\n's router-view\n, because no nested route is matched. Maybe you do want to render something there. In such case you can provide an empty nested path:\nconst routes = [\n{\npath: '/user/:id',\ncomponent: User,\nchildren: [\n// UserHome will be rendered inside User's <router-view>\n// when /user/:id is matched\n{ path: '', component: UserHome },\n// ...other sub routes\n],\n},\n]\nA working demo of this example can be found here.\nNested Named Routes\nWhen dealing with Named Routes, you usually name the children routes:\nconst routes = [\n{\npath: '/user/:id',\ncomponent: User,\n// notice how only the child route has a name\nchildren: [{ path: '', name: 'user', component: UserHome }],\n},\n]\nThis will ensure navigating to /user/:id\nwill always display the nested route.\nIn some scenarios, you may want to navigate to a named route without navigating to the nested route. For example, if you want to navigate to /user/:id\nwithout displaying the nested route. In that case, you can also name the parent route but note that reloading the page will always display the nested child as it's considered a navigation to the path /users/:id\ninstead of the named route:\nconst routes = [\n{\npath: '/user/:id',\nname: 'user-parent',\ncomponent: User,\nchildren: [{ path: '', name: 'user', component: UserHome }],\n},\n]\nOmitting parent components 4.1+\nWe can also take advantage of the parent-child relationship between routes without needing to nest route components. This can be useful for grouping together routes with a common path prefix, or when working with more advanced features, such as per-route navigation guards or route meta fields.\nTo achieve this, we omit the component\nand components\noptions from the parent route:\nconst routes = [\n{\npath: '/admin',\nchildren: [\n{ path: '', component: AdminOverview },\n{ path: 'users', component: AdminUserList },\n{ path: 'users/:id', component: AdminUserDetails },\n],\n},\n]\nAs the parent doesn't specify a route component, the top-level <router-view>\nwill skip over the parent and just use the component from the relevant child instead.",
    "metadata": {
      "source": "https://router.vuejs.org/guide/essentials/nested-routes",
      "title": "Nested Routes | Vue Router"
    }
  },
  {
    "page_content": "Data Fetching\nSometimes you need to fetch data from the server when a route is activated. For example, before rendering a user profile, you need to fetch the user's data from the server. We can achieve this in two different ways:\nFetching After Navigation: perform the navigation first, and fetch data in the incoming component's lifecycle hook. Display a loading state while data is being fetched.\nFetching Before Navigation: Fetch data before navigation in the route enter guard, and perform the navigation after data has been fetched.\nTechnically, both are valid choices - it ultimately depends on the user experience you are aiming for.\nFetching After Navigation\nWhen using this approach, we navigate and render the incoming component immediately, and fetch data in the component itself. It gives us the opportunity to display a loading state while the data is being fetched over the network, and we can also handle loading differently for each view.\nLet's assume we have a Post\ncomponent that needs to fetch the data for a post based on route.params.id\n:\n<template>\n<div class=\"post\">\n<div v-if=\"loading\" class=\"loading\">Loading...</div>\n<div v-if=\"error\" class=\"error\">{{ error }}</div>\n<div v-if=\"post\" class=\"content\">\n<h2>{{ post.title }}</h2>\n<p>{{ post.body }}</p>\n</div>\n</div>\n</template>\n<script setup>\nimport { ref, watch } from 'vue'\nimport { useRoute } from 'vue-router'\nimport { getPost } from './api.js'\nconst route = useRoute()\nconst loading = ref(false)\nconst post = ref(null)\nconst error = ref(null)\n// watch the params of the route to fetch the data again\nwatch(() => route.params.id, fetchData, { immediate: true })\nasync function fetchData(id) {\nerror.value = post.value = null\nloading.value = true\ntry {\n// replace `getPost` with your data fetching util / API wrapper\npost.value = await getPost(id)\n} catch (err) {\nerror.value = err.toString()\n} finally {\nloading.value = false\n}\n}\n</script>\n<template>\n<div class=\"post\">\n<div v-if=\"loading\" class=\"loading\">Loading...</div>\n<div v-if=\"error\" class=\"error\">{{ error }}</div>\n<div v-if=\"post\" class=\"content\">\n<h2>{{ post.title }}</h2>\n<p>{{ post.body }}</p>\n</div>\n</div>\n</template>\n<script>\nimport { getPost } from './api.js'\nexport default {\ndata() {\nreturn {\nloading: false,\npost: null,\nerror: null,\n}\n},\ncreated() {\n// watch the params of the route to fetch the data again\nthis.$watch(\n() => this.$route.params.id,\nthis.fetchData,\n// fetch the data when the view is created and the data is\n// already being observed\n{ immediate: true }\n)\n},\nmethods: {\nasync fetchData(id) {\nthis.error = this.post = null\nthis.loading = true\ntry {\n// replace `getPost` with your data fetching util / API wrapper\nthis.post = await getPost(id)\n} catch (err) {\nthis.error = err.toString()\n} finally {\nthis.loading = false\n}\n},\n},\n}\n</script>\nFetching Before Navigation\nWith this approach we fetch the data before actually navigating to the new route. We can perform the data fetching in the beforeRouteEnter\nguard in the incoming component, and only call next\nwhen the fetch is complete. The callback passed to next\nwill be called after the component is mounted:\nexport default {\ndata() {\nreturn {\npost: null,\nerror: null,\n}\n},\nasync beforeRouteEnter(to, from, next) {\ntry {\nconst post = await getPost(to.params.id)\n// `setPost` is a method defined below\nnext(vm => vm.setPost(post))\n} catch (err) {\n// `setError` is a method defined below\nnext(vm => vm.setError(err))\n}\n},\n// when route changes and this component is already rendered,\n// the logic will be slightly different.\nbeforeRouteUpdate(to, from) {\nthis.post = null\ngetPost(to.params.id).then(this.setPost).catch(this.setError)\n},\nmethods: {\nsetPost(post) {\nthis.post = post\n},\nsetError(err) {\nthis.error = err.toString()\n}\n}\n}\nThe user will stay on the previous view while the resource is being fetched for the incoming view. It is therefore recommended to display a progress bar or some kind of indicator while the data is being fetched. If the data fetch fails, it's also necessary to display some kind of global warning message.",
    "metadata": {
      "source": "https://router.vuejs.org/guide/advanced/data-fetching",
      "title": "Data Fetching | Vue Router"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nThe Vue Instance\nCreating a Vue Instance\nEvery Vue application starts by creating a new Vue instance with the Vue\nfunction:\n|\nAlthough not strictly associated with the MVVM pattern, Vue’s design was partly inspired by it. As a convention, we often use the variable vm\n(short for ViewModel) to refer to our Vue instance.\nWhen you create a Vue instance, you pass in an options object. The majority of this guide describes how you can use these options to create your desired behavior. For reference, you can also browse the full list of options in the API reference.\nA Vue application consists of a root Vue instance created with new Vue\n, optionally organized into a tree of nested, reusable components. For example, a todo app’s component tree might look like this:\n|\nWe’ll talk about the component system in detail later. For now, just know that all Vue components are also Vue instances, and so accept the same options object (except for a few root-specific options).\nData and Methods\nWhen a Vue instance is created, it adds all the properties found in its data\nobject to Vue’s reactivity system. When the values of those properties change, the view will “react”, updating to match the new values.\n|\nWhen this data changes, the view will re-render. It should be noted that properties in data\nare only reactive if they existed when the instance was created. That means if you add a new property, like:\n|\nThen changes to b\nwill not trigger any view updates. If you know you’ll need a property later, but it starts out empty or non-existent, you’ll need to set some initial value. For example:\n|\nThe only exception to this being the use of Object.freeze()\n, which prevents existing properties from being changed, which also means the reactivity system can’t track changes.\n|\n|\nIn addition to data properties, Vue instances expose a number of useful instance properties and methods. These are prefixed with $\nto differentiate them from user-defined properties. For example:\n|\nIn the future, you can consult the API reference for a full list of instance properties and methods.\nInstance Lifecycle Hooks\nEach Vue instance goes through a series of initialization steps when it’s created - for example, it needs to set up data observation, compile the template, mount the instance to the DOM, and update the DOM when data changes. Along the way, it also runs functions called lifecycle hooks, giving users the opportunity to add their own code at specific stages.\nFor example, the created\nhook can be used to run code after an instance is created:\n|\nThere are also other hooks which will be called at different stages of the instance’s lifecycle, such as mounted\n, updated\n, and destroyed\n. All lifecycle hooks are called with their this\ncontext pointing to the Vue instance invoking it.\nDon’t use arrow functions on an options property or callback, such as created: () => console.log(this.a)\nor vm.$watch('a', newValue => this.myMethod())\n. Since an arrow function doesn’t have a this\n, this\nwill be treated as any other variable and lexically looked up through parent scopes until found, often resulting in errors such as Uncaught TypeError: Cannot read property of undefined\nor Uncaught TypeError: this.myMethod is not a function\n.\nLifecycle Diagram\nBelow is a diagram for the instance lifecycle. You don’t need to fully understand everything going on right now, but as you learn and build more, it will be a useful reference.",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/instance",
      "title": "The Vue Instance — Vue.js"
    }
  },
  {
    "page_content": "Become a Sponsor\nGuide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nBecome a Sponsor\nRouting\nOfficial Router\nFor most Single Page Applications, it’s recommended to use the officially-supported vue-router library. For more details, see vue-router’s documentation.\nSimple Routing From Scratch\nIf you only need very simple routing and do not wish to involve a full-featured router library, you can do so by dynamically rendering a page-level component like this:\n|\nCombined with the HTML5 History API, you can build a very basic but fully-functional client-side router. To see that in practice, check out this example app.\nIntegrating 3rd-Party Routers\nIf there’s a 3rd-party router you prefer to use, such as Page.js or Director, integration is similarly easy. Here’s a complete example using Page.js.\nCaught a mistake or want to contribute to the documentation?\nEdit this on GitHub!\nDeployed on\nNetlify .",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/routing",
      "title": "Routing — Vue.js"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nFilters\nVue.js allows you to define filters that can be used to apply common text formatting. Filters are usable in two places: mustache interpolations and v-bind\nexpressions (the latter supported in 2.1.0+). Filters should be appended to the end of the JavaScript expression, denoted by the “pipe” symbol:\n|\nYou can define local filters in a component’s options:\n|\nor define a filter globally before creating the Vue instance:\n|\nWhen the global filter has the same name as the local filter, the local filter will be preferred.\nBelow is an example of our capitalize\nfilter being used:\n{{ message | capitalize }}\nThe filter’s function always receives the expression’s value (the result of the former chain) as its first argument. In the above example, the capitalize\nfilter function will receive the value of message\nas its argument.\nFilters can be chained:\n|\nIn this case, filterA\n, defined with a single argument, will receive the value of message\n, and then the filterB\nfunction will be called with the result of filterA\npassed into filterB\n‘s single argument.\nFilters are JavaScript functions, therefore they can take arguments:\n|\nHere filterA\nis defined as a function taking three arguments. The value of message\nwill be passed into the first argument. The plain string 'arg1'\nwill be passed into the filterA\nas its second argument, and the value of expression arg2\nwill be evaluated and passed in as the third argument.",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/filters",
      "title": "Filters — Vue.js"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nIntroduction\nWhat is Vue.js?\nVue (pronounced /vjuː/, like view) is a progressive framework for building user interfaces. Unlike other monolithic frameworks, Vue is designed from the ground up to be incrementally adoptable. The core library is focused on the view layer only, and is easy to pick up and integrate with other libraries or existing projects. On the other hand, Vue is also perfectly capable of powering sophisticated Single-Page Applications when used in combination with modern tooling and supporting libraries.\nIf you’d like to learn more about Vue before diving in, we created a video walking through the core principles and a sample project.\nIf you are an experienced frontend developer and want to know how Vue compares to other libraries/frameworks, check out the Comparison with Other Frameworks.\nGetting Started\nThe official guide assumes intermediate level knowledge of HTML, CSS, and JavaScript. If you are totally new to frontend development, it might not be the best idea to jump right into a framework as your first step - grasp the basics then come back! Prior experience with other frameworks helps, but is not required.\nThe easiest way to try out Vue.js is using the Hello World example. Feel free to open it in another tab and follow along as we go through some basic examples. Or, you can create an index.html\nfile and include Vue with:\n|\nor:\n|\nThe Installation page provides more options of installing Vue. Note: We do not recommend that beginners start with vue-cli\n, especially if you are not yet familiar with Node.js-based build tools.\nIf you prefer something more interactive, you can also check out this tutorial series on Scrimba, which gives you a mix of screencast and code playground that you can pause and play around with anytime.\nDeclarative Rendering\nAt the core of Vue.js is a system that enables us to declaratively render data to the DOM using straightforward template syntax:\n|\n|\nWe have already created our very first Vue app! This looks pretty similar to rendering a string template, but Vue has done a lot of work under the hood. The data and the DOM are now linked, and everything is now reactive. How do we know? Open your browser’s JavaScript console (right now, on this page) and set app.message\nto a different value. You should see the rendered example above update accordingly.\nNote that we no longer have to interact with the HTML directly. A Vue app attaches itself to a single DOM element (#app\nin our case) then fully controls it. The HTML is our entry point, but everything else happens within the newly created Vue instance.\nIn addition to text interpolation, we can also bind element attributes like this:\n|\n|\nHere we are encountering something new. The v-bind\nattribute you are seeing is called a directive. Directives are prefixed with v-\nto indicate that they are special attributes provided by Vue, and as you may have guessed, they apply special reactive behavior to the rendered DOM. Here, it is basically saying “keep this element’s title\nattribute up-to-date with the message\nproperty on the Vue instance.”\nIf you open up your JavaScript console again and enter app2.message = 'some new message'\n, you’ll once again see that the bound HTML - in this case the title\nattribute - has been updated.\nConditionals and Loops\nIt’s easy to toggle the presence of an element, too:\n|\n|\nGo ahead and enter app3.seen = false\nin the console. You should see the message disappear.\nThis example demonstrates that we can bind data to not only text and attributes, but also the structure of the DOM. Moreover, Vue also provides a powerful transition effect system that can automatically apply transition effects when elements are inserted/updated/removed by Vue.\nThere are quite a few other directives, each with its own special functionality. For example, the v-for\ndirective can be used for displaying a list of items using the data from an Array:\n|\n|\n- {{ todo.text }}\nIn the console, enter app4.todos.push({ text: 'New item' })\n. You should see a new item appended to the list.\nHandling User Input\nTo let users interact with your app, we can use the v-on\ndirective to attach event listeners that invoke methods on our Vue instances:\n|\n|\n{{ message }}\nNote that in this method we update the state of our app without touching the DOM - all DOM manipulations are handled by Vue, and the code you write is focused on the underlying logic.\nVue also provides the v-model\ndirective that makes two-way binding between form input and app state a breeze:\n|\n|\n{{ message }}\nComposing with Components\nThe component system is another important concept in Vue, because it’s an abstraction that allows us to build large-scale applications composed of small, self-contained, and often reusable components. If we think about it, almost any type of application interface can be abstracted into a tree of components:\nIn Vue, a component is essentially a Vue instance with pre-defined options. Registering a component in Vue is straightforward:\n|\nNow you can compose it in another component’s template:\n|\nBut this would render the same text for every todo, which is not super interesting. We should be able to pass data from the parent scope into child components. Let’s modify the component definition to make it accept a prop:\n|\nNow we can pass the todo into each repeated component using v-bind\n:\n|\n|\nThis is a contrived example, but we have managed to separate our app into two smaller units, and the child is reasonably well-decoupled from the parent via the props interface. We can now further improve our <todo-item>\ncomponent with more complex template and logic without affecting the parent app.\nIn a large application, it is necessary to divide the whole app into components to make development manageable. We will talk a lot more about components later in the guide, but here’s an (imaginary) example of what an app’s template might look like with components:\n|\nRelation to Custom Elements\nYou may have noticed that Vue components are very similar to Custom Elements, which are part of the Web Components Spec. That’s because Vue’s component syntax is loosely modeled after the spec. For example, Vue components implement the Slot API and the is\nspecial attribute. However, there are a few key differences:\nThe Web Components Spec has been finalized, but is not natively implemented in every browser. Safari 10.1+, Chrome 54+ and Firefox 63+ natively support web components. In comparison, Vue components don’t require any polyfills and work consistently in all supported browsers (IE9 and above). When needed, Vue components can also be wrapped inside a native custom element.\nVue components provide important features that are not available in plain custom elements, most notably cross-component data flow, custom event communication and build tool integrations.\nAlthough Vue doesn’t use custom elements internally, it has great interoperability when it comes to consuming or distributing as custom elements. Vue CLI also supports building Vue components that register themselves as native custom elements.\nReady for More?\nWe’ve briefly introduced the most basic features of Vue.js core - the rest of this guide will cover them and other advanced features with much finer details, so make sure to read through it all!\nVideo by Vue Mastery. Watch Vue Mastery’s free Intro to Vue course.",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/",
      "title": "Introduction — Vue.js"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nPlugins\nPlugins usually add global-level functionality to Vue. There is no strictly defined scope for a plugin - there are typically several types of plugins:\nAdd some global methods or properties. e.g. vue-custom-element\nAdd one or more global assets: directives/filters/transitions etc. e.g. vue-touch\nAdd some component options by global mixin. e.g. vue-router\nAdd some Vue instance methods by attaching them to Vue.prototype.\nA library that provides an API of its own, while at the same time injecting some combination of the above. e.g. vue-router\nUsing a Plugin\nUse plugins by calling the Vue.use()\nglobal method. This has to be done before you start your app by calling new Vue()\n:\n|\nYou can optionally pass in some options:\n|\nVue.use\nautomatically prevents you from using the same plugin more than once, so calling it multiple times on the same plugin will install the plugin only once.\nSome plugins provided by Vue.js official plugins such as vue-router\nautomatically calls Vue.use()\nif Vue\nis available as a global variable. However in a module environment such as CommonJS, you always need to call Vue.use()\nexplicitly:\n|\nCheckout awesome-vue for a huge collection of community-contributed plugins and libraries.\nWriting a Plugin\nA Vue.js plugin should expose an install\nmethod. The method will be called with the Vue\nconstructor as the first argument, along with possible options:\n|",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/plugins",
      "title": "Plugins — Vue.js"
    }
  },
  {
    "page_content": "RouterView slot\nThe RouterView component exposes a slot that can be used to render the route component:\n<router-view v-slot=\"{ Component }\">\n<component :is=\"Component\" />\n</router-view>\nThe code above is equivalent to using <router-view />\nwithout the slot, but the slot provides extra flexibility when we want to work with other features.\nKeepAlive & Transition\nWhen working with the KeepAlive component, we would usually want it to keep the route components alive, not the RouterView itself. We can achieve that by putting the KeepAlive inside the slot:\n<router-view v-slot=\"{ Component }\">\n<keep-alive>\n<component :is=\"Component\" />\n</keep-alive>\n</router-view>\nSimilarly, the slot allows us to use a Transition component to transition between route components:\n<router-view v-slot=\"{ Component }\">\n<transition>\n<component :is=\"Component\" />\n</transition>\n</router-view>\nWe can also use KeepAlive inside a Transition:\n<router-view v-slot=\"{ Component }\">\n<transition>\n<keep-alive>\n<component :is=\"Component\" />\n</keep-alive>\n</transition>\n</router-view>\nFor more information about using RouterView with the Transition component, see the Transitions guide.\nPassing props and slots\nWe can use the slot to pass props or slots to the route component:\n<router-view v-slot=\"{ Component }\">\n<component :is=\"Component\" some-prop=\"a value\">\n<p>Some slotted content</p>\n</component>\n</router-view>\nIn practice, this usually isn't something you would want to do, as the route components would all need to use the same props and slots. See Passing Props to Route Components for other ways to pass props.\nTemplate refs\nUsing the slot allows us to put a template ref directly on the route component:\n<router-view v-slot=\"{ Component }\">\n<component :is=\"Component\" ref=\"mainContent\" />\n</router-view>\nIf we put the ref on the <router-view>\ninstead then the ref would be populated with the RouterView instance, rather than the route component.",
    "metadata": {
      "source": "https://router.vuejs.org/guide/advanced/router-view-slot",
      "title": "RouterView slot | Vue Router"
    }
  },
  {
    "page_content": "Programmatic Navigation\nAside from using <router-link>\nto create anchor tags for declarative navigation, we can do this programmatically using the router's instance methods.\nNavigate to a different location\nNote: The examples below refer to the router instance as router\n. Inside a component, you can access the router using the $router\nproperty, e.g. this.$router.push(...)\n. If you're using the Composition API, the router is accessible by calling useRouter()\n.\nTo navigate to a different URL, use router.push\n. This method pushes a new entry into the history stack, so when the user clicks the browser back button they will be taken to the previous URL.\nThis is the method called internally when you click a <router-link>\n, so clicking <router-link :to=\"...\">\nis the equivalent of calling router.push(...)\n.\nDeclarative | Programmatic |\n---|---|\n<router-link :to=\"...\"> | router.push(...) |\nThe argument can be a string path, or a location descriptor object. Examples:\n// literal string path\nrouter.push('/users/eduardo')\n// object with path\nrouter.push({ path: '/users/eduardo' })\n// named route with params to let the router build the url\nrouter.push({ name: 'user', params: { username: 'eduardo' } })\n// with query, resulting in /register?plan=private\nrouter.push({ path: '/register', query: { plan: 'private' } })\n// with hash, resulting in /about#team\nrouter.push({ path: '/about', hash: '#team' })\nNote: params\nare ignored if a path\nis provided, which is not the case for query\n, as shown in the example above. Instead, you need to provide the name\nof the route or manually specify the whole path\nwith any parameter:\nconst username = 'eduardo'\n// we can manually build the url but we will have to handle the encoding ourselves\nrouter.push(`/user/${username}`) // -> /user/eduardo\n// same as\nrouter.push({ path: `/user/${username}` }) // -> /user/eduardo\n// if possible use `name` and `params` to benefit from automatic URL encoding\nrouter.push({ name: 'user', params: { username } }) // -> /user/eduardo\n// `params` cannot be used alongside `path`\nrouter.push({ path: '/user', params: { username } }) // -> /user\nWhen specifying params\n, make sure to either provide a string\nor number\n(or an array of these for repeatable params). Any other type (like objects, booleans, etc) will be automatically stringified. For optional params, you can provide an empty string (\"\"\n) or null\nas the value to remove it.\nSince the prop to\naccepts the same kind of object as router.push\n, the exact same rules apply to both of them.\nrouter.push\nand all the other navigation methods return a Promise that allows us to wait till the navigation is finished and to know if it succeeded or failed. We will talk more about that in Navigation Handling.\nReplace current location\nIt acts like router.push\n, the only difference is that it navigates without pushing a new history entry, as its name suggests - it replaces the current entry.\nDeclarative | Programmatic |\n---|---|\n<router-link :to=\"...\" replace> | router.replace(...) |\nIt's also possible to directly add a property replace: true\nto the to\nargument that is passed to router.push\n:\nrouter.push({ path: '/home', replace: true })\n// equivalent to\nrouter.replace({ path: '/home' })\nTraverse history\nThis method takes a single integer as parameter that indicates by how many steps to go forward or go backward in the history stack, similar to window.history.go(n)\n.\nExamples\n// go forward by one record, the same as router.forward()\nrouter.go(1)\n// go back by one record, the same as router.back()\nrouter.go(-1)\n// go forward by 3 records\nrouter.go(3)\n// fails silently if there aren't that many records\nrouter.go(-100)\nrouter.go(100)\nHistory Manipulation\nYou may have noticed that router.push\n, router.replace\nand router.go\nare counterparts of window.history.pushState\n, window.history.replaceState\nand window.history.go\n, and they do imitate the window.history\nAPIs.\nTherefore, if you are already familiar with Browser History APIs, manipulating history will feel familiar when using Vue Router.\nIt is worth mentioning that Vue Router navigation methods (push\n, replace\n, go\n) work consistently no matter the history\noption passed when creating the router instance.",
    "metadata": {
      "source": "https://router.vuejs.org/guide/essentials/navigation",
      "title": "Programmatic Navigation | Vue Router"
    }
  },
  {
    "page_content": "Routes' Matching Syntax\nMost applications will use static routes like /about\nand dynamic routes like /users/:userId\nlike we just saw in Dynamic Route Matching, but Vue Router has much more to offer!\nTIP\nFor the sake of simplicity, all route records are omitting the component\nproperty to focus on the path\nvalue.\nCustom regex in params\nWhen defining a param like :userId\n, we internally use the following regex ([^/]+)\n(at least one character that isn't a slash /\n) to extract params from URLs. This works well unless you need to differentiate two routes based on the param content. Imagine two routes /:orderId\nand /:productName\n, both would match the exact same URLs, so we need a way to differentiate them. The easiest way would be to add a static section to the path that differentiates them:\nconst routes = [\n// matches /o/3549\n{ path: '/o/:orderId' },\n// matches /p/books\n{ path: '/p/:productName' },\n]\nBut in some scenarios, we don't want to add that static section /o\nor /p\n. However, orderId\nis always a number while productName\ncan be anything so we can specify a custom regex for a param in parentheses:\nconst routes = [\n// /:orderId -> matches only numbers\n{ path: '/:orderId(\\\\d+)' },\n// /:productName -> matches anything else\n{ path: '/:productName' },\n]\nNow, going to /25\nwill match /:orderId\nwhile going to anything else will match /:productName\n. The order of the routes\narray doesn't even matter!\nTIP\nMake sure to escape backslashes (\\\n) like we did with \\d\n(becomes \\\\d\n) to actually pass the backslash character in a string in JavaScript.\nRepeatable params\nIf you need to match routes with multiple sections like /first/second/third\n, you should mark a param as repeatable with *\n(0 or more) and +\n(1 or more):\nconst routes = [\n// /:chapters -> matches /one, /one/two, /one/two/three, etc\n{ path: '/:chapters+' },\n// /:chapters -> matches /, /one, /one/two, /one/two/three, etc\n{ path: '/:chapters*' },\n]\nThis will give you an array of params instead of a string and will also require you to pass an array when using named routes:\n// given { path: '/:chapters*', name: 'chapters' },\nrouter.resolve({ name: 'chapters', params: { chapters: [] } }).href\n// produces /\nrouter.resolve({ name: 'chapters', params: { chapters: ['a', 'b'] } }).href\n// produces /a/b\n// given { path: '/:chapters+', name: 'chapters' },\nrouter.resolve({ name: 'chapters', params: { chapters: [] } }).href\n// throws an Error because `chapters` is empty\nThese can also be combined with a custom regex by adding them after the closing parentheses:\nconst routes = [\n// only match numbers\n// matches /1, /1/2, etc\n{ path: '/:chapters(\\\\d+)+' },\n// matches /, /1, /1/2, etc\n{ path: '/:chapters(\\\\d+)*' },\n]\nSensitive and strict route options\nBy default, all routes are case-insensitive and match routes with or without a trailing slash. e.g. a route /users\nmatches /users\n, /users/\n, and even /Users/\n. This behavior can be configured with the strict\nand sensitive\noptions, they can be set both at a router and route level:\nconst router = createRouter({\nhistory: createWebHistory(),\nroutes: [\n// will match /users/posva but not:\n// - /users/posva/ because of strict: true\n// - /Users/posva because of sensitive: true\n{ path: '/users/:id', sensitive: true },\n// will match /users, /Users, and /users/42 but not /users/ or /users/42/\n{ path: '/users/:id?' },\n],\nstrict: true, // applies to all routes\n})\nOptional parameters\nYou can also mark a parameter as optional by using the ?\nmodifier (0 or 1):\nconst routes = [\n// will match /users and /users/posva\n{ path: '/users/:userId?' },\n// will match /users and /users/42\n{ path: '/users/:userId(\\\\d+)?' },\n]\nNote that *\ntechnically also marks a parameter as optional but ?\nparameters cannot be repeated.\nIf the route segment contains more than just an optional parameter, it won't match a path without the trailing slash. For example:\n/users/:uid?-:name?\nwon't match/users\n, only/users/-\nor even/users/-/\n/users/:uid(\\\\d+)?:name?\nwon't match/users\n, only/users/\n,/users/2\n,/users/2/\n, etc\nYou can play around with the matching syntax in the playground\nDebugging\nIf you need to dig how your routes are transformed into a regex to understand why a route isn't being matched or, to report a bug, you can use the path ranker tool. It supports sharing your routes through the URL.",
    "metadata": {
      "source": "https://router.vuejs.org/guide/essentials/route-matching-syntax",
      "title": "Routes' Matching Syntax | Vue Router"
    }
  },
  {
    "page_content": "Dynamic Routing\nAdding routes to your router is usually done via the routes\noption but in some situations, you might want to add or remove routes while the application is already running. Applications with extensible interfaces like Vue CLI UI can use this to make the application grow.\nAdding routes\nDynamic routing is achieved mainly via two functions: router.addRoute()\nand router.removeRoute()\n. They only register a new route, meaning that if the newly added route matches the current location, it would require you to manually navigate with router.push()\nor router.replace()\nto display that new route. Let's take a look at an example:\nImagine having the following router with one single route:\nconst router = createRouter({\nhistory: createWebHistory(),\nroutes: [{ path: '/:articleName', component: Article }],\n})\nGoing to any page like /about\n, /store\n, or /3-tricks-to-improve-your-routing-code\nends up rendering the Article\ncomponent. If we are on /about\nand we add a new route:\nrouter.addRoute({ path: '/about', component: About })\nThe page will still show the Article\ncomponent. We need to manually call router.replace()\nto change the current location and overwrite where we were (instead of pushing a new entry, ending up in the same location twice in our history):\nrouter.addRoute({ path: '/about', component: About })\n// we could also use this.$route or useRoute()\nrouter.replace(router.currentRoute.value.fullPath)\nRemember you can await router.replace()\nif you need to wait for the new route to be displayed.\nAdding routes inside navigation guards\nIf you decide to add or remove routes inside of a navigation guard, you should not call router.replace()\nbut trigger a redirection by returning the new location:\nrouter.beforeEach(to => {\nif (!hasNecessaryRoute(to)) {\nrouter.addRoute(generateRoute(to))\n// trigger a redirection\nreturn to.fullPath\n}\n})\nThe example above assumes two things: first, the newly added route record will match the to\nlocation, effectively resulting in a different location from the one we were trying to access. Second, hasNecessaryRoute()\nreturns false\nafter adding the new route to avoid an infinite redirection.\nBecause we are redirecting, we are replacing the ongoing navigation, effectively behaving like the example shown before. In real world scenarios, adding is more likely to happen outside of navigation guards, e.g. when a view component mounts, it register new routes.\nRemoving routes\nThere are few different ways to remove existing routes:\nBy adding a route with a conflicting name. If you add a route that has the same name as an existing route, it will remove the route first and then add the route:\njsrouter.addRoute({ path: '/about', name: 'about', component: About }) // this will remove the previously added route because they have // the same name and names are unique across all routes router.addRoute({ path: '/other', name: 'about', component: Other })\nBy calling the callback returned by\nrouter.addRoute()\n:jsconst removeRoute = router.addRoute(routeRecord) removeRoute() // removes the route if it exists\nThis is useful when the routes do not have a name\nBy using\nrouter.removeRoute()\nto remove a route by its name:jsrouter.addRoute({ path: '/about', name: 'about', component: About }) // remove the route router.removeRoute('about')\nNote you can use\nSymbol\ns for names in routes if you wish to use this function but want to avoid conflicts in names.\nWhenever a route is removed, all of its aliases and children are removed with it.\nAdding nested routes\nTo add nested routes to an existing route, you can pass the name of the route as its first parameter to router.addRoute()\n. This will effectively add the route as if it was added through children\n:\nrouter.addRoute({ name: 'admin', path: '/admin', component: Admin })\nrouter.addRoute('admin', { path: 'settings', component: AdminSettings })\nThis is equivalent to:\nrouter.addRoute({\nname: 'admin',\npath: '/admin',\ncomponent: Admin,\nchildren: [{ path: 'settings', component: AdminSettings }],\n})\nLooking at existing routes\nVue Router gives you two functions to look at existing routes:\nrouter.hasRoute()\n: check if a route exists.router.getRoutes()\n: get an array with all the route records.",
    "metadata": {
      "source": "https://router.vuejs.org/guide/advanced/dynamic-routing",
      "title": "Dynamic Routing | Vue Router"
    }
  },
  {
    "page_content": "Extending RouterLink\nThe RouterLink component exposes enough props\nto suffice most basic applications but it doesn't try to cover every possible use case and you will likely find yourself using v-slot\nfor some advanced cases. In most medium to large sized applications, it's worth creating one if not multiple custom RouterLink components to reuse them across your application. Some examples are Links in a Navigation Menu, handling external links, adding an inactive-class\n, etc.\nLet's extend RouterLink to handle external links as well and adding a custom inactive-class\nin an AppLink.vue\nfile:\n<script setup>\nimport { computed } from 'vue'\nimport { RouterLink } from 'vue-router'\ndefineOptions({\ninheritAttrs: false,\n})\nconst props = defineProps({\n// add @ts-ignore if using TypeScript\n...RouterLink.props,\ninactiveClass: String,\n})\nconst isExternalLink = computed(() => {\nreturn typeof props.to === 'string' && props.to.startsWith('http')\n})\n</script>\n<template>\n<a v-if=\"isExternalLink\" v-bind=\"$attrs\" :href=\"to\" target=\"_blank\">\n<slot />\n</a>\n<router-link\nv-else\nv-bind=\"$props\"\ncustom\nv-slot=\"{ isActive, href, navigate }\"\n>\n<a\nv-bind=\"$attrs\"\n:href=\"href\"\n@click=\"navigate\"\n:class=\"isActive ? activeClass : inactiveClass\"\n>\n<slot />\n</a>\n</router-link>\n</template>\n<script>\nimport { RouterLink } from 'vue-router'\nexport default {\nname: 'AppLink',\ninheritAttrs: false,\nprops: {\n// add @ts-ignore if using TypeScript\n...RouterLink.props,\ninactiveClass: String,\n},\ncomputed: {\nisExternalLink() {\nreturn typeof this.to === 'string' && this.to.startsWith('http')\n},\n},\n}\n</script>\n<template>\n<a v-if=\"isExternalLink\" v-bind=\"$attrs\" :href=\"to\" target=\"_blank\">\n<slot />\n</a>\n<router-link\nv-else\nv-bind=\"$props\"\ncustom\nv-slot=\"{ isActive, href, navigate }\"\n>\n<a\nv-bind=\"$attrs\"\n:href=\"href\"\n@click=\"navigate\"\n:class=\"isActive ? activeClass : inactiveClass\"\n>\n<slot />\n</a>\n</router-link>\n</template>\nIf you prefer using a render function or create computed\nproperties, you can use the useLink\nfrom the Composition API:\nimport { RouterLink, useLink } from 'vue-router'\nexport default {\nname: 'AppLink',\nprops: {\n// add @ts-ignore if using TypeScript\n...RouterLink.props,\ninactiveClass: String,\n},\nsetup(props) {\n// `props` contains `to` and any other prop that can be passed to <router-link>\nconst { navigate, href, route, isActive, isExactActive } = useLink(props)\n// profit!\nreturn { isExternalLink }\n},\n}\nIn practice, you might want to use your AppLink\ncomponent for different parts of your application. e.g. using Tailwind CSS, you could create a NavLink.vue\ncomponent with all the classes:\n<template>\n<AppLink\nv-bind=\"$attrs\"\nclass=\"inline-flex items-center px-1 pt-1 border-b-2 border-transparent text-sm font-medium leading-5 text-gray-500 hover:text-gray-700 hover:border-gray-300 focus:outline-none focus:text-gray-700 focus:border-gray-300 transition duration-150 ease-in-out\"\nactive-class=\"border-indigo-500 text-gray-900 focus:border-indigo-700\"\ninactive-class=\"text-gray-500 hover:text-gray-700 hover:border-gray-300 focus:text-gray-700 focus:border-gray-300\"\n>\n<slot />\n</AppLink>\n</template>",
    "metadata": {
      "source": "https://router.vuejs.org/guide/advanced/extending-router-link",
      "title": "Extending RouterLink | Vue Router"
    }
  },
  {
    "page_content": "Named Views\nSometimes you need to display multiple views at the same time instead of nesting them, e.g. creating a layout with a sidebar\nview and a main\nview. This is where named views come in handy. Instead of having one single outlet in your view, you can have multiple and give each of them a name. A router-view\nwithout a name will be given default\nas its name.\n<router-view class=\"view left-sidebar\" name=\"LeftSidebar\" />\n<router-view class=\"view main-content\" />\n<router-view class=\"view right-sidebar\" name=\"RightSidebar\" />\nA view is rendered by using a component, therefore multiple views require multiple components for the same route. Make sure to use the components\n(with an s) option:\nconst router = createRouter({\nhistory: createWebHashHistory(),\nroutes: [\n{\npath: '/',\ncomponents: {\ndefault: Home,\n// short for LeftSidebar: LeftSidebar\nLeftSidebar,\n// they match the `name` attribute on `<router-view>`\nRightSidebar,\n},\n},\n],\n})\nA working demo of this example can be found here.\nNested Named Views\nIt is possible to create complex layouts using named views with nested views. When doing so, you will also need to give nested router-view\na name. Let's take a Settings panel example:\n/settings/emails /settings/profile\n+-----------------------------------+ +------------------------------+\n| UserSettings | | UserSettings |\n| +-----+-------------------------+ | | +-----+--------------------+ |\n| | Nav | UserEmailsSubscriptions | | +------------> | | Nav | UserProfile | |\n| | +-------------------------+ | | | +--------------------+ |\n| | | | | | | | UserProfilePreview | |\n| +-----+-------------------------+ | | +-----+--------------------+ |\n+-----------------------------------+ +------------------------------+\nNav\nis just a regular componentUserSettings\nis the parent view componentUserEmailsSubscriptions\n,UserProfile\n,UserProfilePreview\nare nested view components\nNote: Let's forget about how the HTML/CSS should look like to represent such layout and focus on the components used.\nThe <template>\nsection for UserSettings\ncomponent in the above layout would look something like this:\n<!-- UserSettings.vue -->\n<div>\n<h1>User Settings</h1>\n<NavBar />\n<router-view />\n<router-view name=\"helper\" />\n</div>\nThen you can achieve the layout above with this route configuration:\n{\npath: '/settings',\n// You could also have named views at the top\ncomponent: UserSettings,\nchildren: [{\npath: 'emails',\ncomponent: UserEmailsSubscriptions\n}, {\npath: 'profile',\ncomponents: {\ndefault: UserProfile,\nhelper: UserProfilePreview\n}\n}]\n}\nA working demo of this example can be found here.",
    "metadata": {
      "source": "https://router.vuejs.org/guide/essentials/named-views",
      "title": "Named Views | Vue Router"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nHandling Edge Cases\nThis page assumes you’ve already read the Components Basics. Read that first if you are new to components.\nAll the features on this page document the handling of edge cases, meaning unusual situations that sometimes require bending Vue’s rules a little. Note however, that they all have disadvantages or situations where they could be dangerous. These are noted in each case, so keep them in mind when deciding to use each feature.\nElement & Component Access\nIn most cases, it’s best to avoid reaching into other component instances or manually manipulating DOM elements. There are cases, however, when it can be appropriate.\nAccessing the Root Instance\nIn every subcomponent of a new Vue\ninstance, this root instance can be accessed with the $root\nproperty. For example, in this root instance:\n|\nAll subcomponents will now be able to access this instance and use it as a global store:\n|\nThis can be convenient for demos or very small apps with a handful of components. However, the pattern does not scale well to medium or large-scale applications, so we strongly recommend using Vuex to manage state in most cases.\nAccessing the Parent Component Instance\nSimilar to $root\n, the $parent\nproperty can be used to access the parent instance from a child. This can be tempting to reach for as a lazy alternative to passing data with a prop.\nIn most cases, reaching into the parent makes your application more difficult to debug and understand, especially if you mutate data in the parent. When looking at that component later, it will be very difficult to figure out where that mutation came from.\nThere are cases however, particularly shared component libraries, when this might be appropriate. For example, in abstract components that interact with JavaScript APIs instead of rendering HTML, like these hypothetical Google Maps components:\n|\nThe <google-map>\ncomponent might define a map\nproperty that all subcomponents need access to. In this case <google-map-markers>\nmight want to access that map with something like this.$parent.getMap\n, in order to add a set of markers to it. You can see this pattern in action here.\nKeep in mind, however, that components built with this pattern are still inherently fragile. For example, imagine we add a new <google-map-region>\ncomponent and when <google-map-markers>\nappears within that, it should only render markers that fall within that region:\n|\nThen inside <google-map-markers>\nyou might find yourself reaching for a hack like this:\n|\nThis has quickly gotten out of hand. That’s why to provide context information to descendant components arbitrarily deep, we instead recommend dependency injection.\nAccessing Child Component Instances & Child Elements\nDespite the existence of props and events, sometimes you might still need to directly access a child component in JavaScript. To achieve this you can assign a reference ID to the child component using the ref\nattribute. For example:\n|\nNow in the component where you’ve defined this ref\n, you can use:\n|\nto access the <base-input>\ninstance. This may be useful when you want to, for example, programmatically focus this input from a parent. In that case, the <base-input>\ncomponent may similarly use a ref\nto provide access to specific elements inside it, such as:\n|\nAnd even define methods for use by the parent:\n|\nThus allowing the parent component to focus the input inside <base-input>\nwith:\n|\nWhen ref\nis used together with v-for\n, the ref you get will be an array containing the child components mirroring the data source.\n$refs\nare only populated after the component has been rendered, and they are not reactive. It is only meant as an escape hatch for direct child manipulation - you should avoid accessing $refs\nfrom within templates or computed properties.\nDependency Injection\nEarlier, when we described Accessing the Parent Component Instance, we showed an example like this:\n|\nIn this component, all descendants of <google-map>\nneeded access to a getMap\nmethod, in order to know which map to interact with. Unfortunately, using the $parent\nproperty didn’t scale well to more deeply nested components. That’s where dependency injection can be useful, using two new instance options: provide\nand inject\n.\nThe provide\noptions allows us to specify the data/methods we want to provide to descendant components. In this case, that’s the getMap\nmethod inside <google-map>\n:\n|\nThen in any descendants, we can use the inject\noption to receive specific properties we’d like to add to that instance:\n|\nYou can see the full example here. The advantage over using $parent\nis that we can access getMap\nin any descendant component, without exposing the entire instance of <google-map>\n. This allows us to more safely keep developing that component, without fear that we might change/remove something that a child component is relying on. The interface between these components remains clearly defined, just as with props\n.\nIn fact, you can think of dependency injection as sort of “long-range props”, except:\n- ancestor components don’t need to know which descendants use the properties it provides\n- descendant components don’t need to know where injected properties are coming from\nHowever, there are downsides to dependency injection. It couples components in your application to the way they’re currently organized, making refactoring more difficult. Provided properties are also not reactive. This is by design, because using them to create a central data store scales just as poorly as using $root\nfor the same purpose. If the properties you want to share are specific to your app, rather than generic, or if you ever want to update provided data inside ancestors, then that’s a good sign that you probably need a real state management solution like Vuex instead.\nLearn more about dependency injection in the API doc.\nProgrammatic Event Listeners\nSo far, you’ve seen uses of $emit\n, listened to with v-on\n, but Vue instances also offer other methods in its events interface. We can:\n- Listen for an event with\n$on(eventName, eventHandler)\n- Listen for an event only once with\n$once(eventName, eventHandler)\n- Stop listening for an event with\n$off(eventName, eventHandler)\nYou normally won’t have to use these, but they’re available for cases when you need to manually listen for events on a component instance. They can also be useful as a code organization tool. For example, you may often see this pattern for integrating a 3rd-party library:\n|\nThis has two potential issues:\n- It requires saving the\npicker\nto the component instance, when it’s possible that only lifecycle hooks need access to it. This isn’t terrible, but it could be considered clutter. - Our setup code is kept separate from our cleanup code, making it more difficult to programmatically clean up anything we set up.\nYou could resolve both issues with a programmatic listener:\n|\nUsing this strategy, we could even use Pikaday with several input elements, with each new instance automatically cleaning up after itself:\n|\nSee this example for the full code. Note, however, that if you find yourself having to do a lot of setup and cleanup within a single component, the best solution will usually be to create more modular components. In this case, we’d recommend creating a reusable <input-datepicker>\ncomponent.\nTo learn more about programmatic listeners, check out the API for Events Instance Methods.\nNote that Vue’s event system is different from the browser’s EventTarget API. Though they work similarly, $emit\n, $on\n, and $off\nare not aliases for dispatchEvent\n, addEventListener\n, and removeEventListener\n.\nCircular References\nRecursive Components\nComponents can recursively invoke themselves in their own template. However, they can only do so with the name\noption:\n|\nWhen you register a component globally using Vue.component\n, the global ID is automatically set as the component’s name\noption.\n|\nIf you’re not careful, recursive components can also lead to infinite loops:\n|\nA component like the above will result in a “max stack size exceeded” error, so make sure recursive invocation is conditional (i.e. uses a v-if\nthat will eventually be false\n).\nCircular References Between Components\nLet’s say you’re building a file directory tree, like in Finder or File Explorer. You might have a tree-folder\ncomponent with this template:\n|\nThen a tree-folder-contents\ncomponent with this template:\n|\nWhen you look closely, you’ll see that these components will actually be each other’s descendant and ancestor in the render tree - a paradox! When registering components globally with Vue.component\n, this paradox is resolved for you automatically. If that’s you, you can stop reading here.\nHowever, if you’re requiring/importing components using a module system, e.g. via Webpack or Browserify, you’ll get an error:\n|\nTo explain what’s happening, let’s call our components A and B. The module system sees that it needs A, but first A needs B, but B needs A, but A needs B, etc. It’s stuck in a loop, not knowing how to fully resolve either component without first resolving the other. To fix this, we need to give the module system a point at which it can say, “A needs B eventually, but there’s no need to resolve B first.”\nIn our case, let’s make that point the tree-folder\ncomponent. We know the child that creates the paradox is the tree-folder-contents\ncomponent, so we’ll wait until the beforeCreate\nlifecycle hook to register it:\n|\nOr alternatively, you could use Webpack’s asynchronous import\nwhen you register the component locally:\n|\nProblem solved!\nAlternate Template Definitions\nInline Templates\nWhen the inline-template\nspecial attribute is present on a child component, the component will use its inner content as its template, rather than treating it as distributed content. This allows more flexible template-authoring.\n|\nYour inline template needs to be defined inside the DOM element to which Vue is attached.\nHowever, inline-template\nmakes the scope of your templates harder to reason about. As a best practice, prefer defining templates inside the component using the template\noption or in a <template>\nelement in a .vue\nfile.\nX-Templates\nAnother way to define templates is inside of a script element with the type text/x-template\n, then referencing the template by an id. For example:\n|\n|\nYour x-template needs to be defined outside the DOM element to which Vue is attached.\nThese can be useful for demos with large templates or in extremely small applications, but should otherwise be avoided, because they separate templates from the rest of the component definition.\nControlling Updates\nThanks to Vue’s Reactivity system, it always knows when to update (if you use it correctly). There are edge cases, however, when you might want to force an update, despite the fact that no reactive data has changed. Then there are other cases when you might want to prevent unnecessary updates.\nForcing an Update\nIf you find yourself needing to force an update in Vue, in 99.99% of cases, you’ve made a mistake somewhere.\nYou may not have accounted for change detection caveats with arrays or objects, or you may be relying on state that isn’t tracked by Vue’s reactivity system, e.g. with data\n.\nHowever, if you’ve ruled out the above and find yourself in this extremely rare situation of having to manually force an update, you can do so with $forceUpdate\n.\nCheap Static Components with v-once\nRendering plain HTML elements is very fast in Vue, but sometimes you might have a component that contains a lot of static content. In these cases, you can ensure that it’s only evaluated once and then cached by adding the v-once\ndirective to the root element, like this:\n|\nOnce again, try not to overuse this pattern. While convenient in those rare cases when you have to render a lot of static content, it’s simply not necessary unless you actually notice slow rendering – plus, it could cause a lot of confusion later. For example, imagine another developer who’s not familiar with v-once\nor simply misses it in the template. They might spend hours trying to figure out why the template isn’t updating correctly.",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/components-edge-cases",
      "title": "Handling Edge Cases — Vue.js"
    }
  },
  {
    "page_content": "Vue Router and the Composition API\nThe introduction of Vue's Composition API opened up new possibilities, but to be able to get the full potential out of Vue Router, we will need to use a few new functions to replace access to this\nand in-component navigation guards.\nAccessing the Router and current Route inside setup\nBecause we don't have access to this\ninside of setup\n, we cannot directly access this.$router\nor this.$route\n. Instead, we use the useRouter\nand useRoute\ncomposables:\n<script setup>\nimport { useRouter, useRoute } from 'vue-router'\nconst router = useRouter()\nconst route = useRoute()\nfunction pushWithQuery(query) {\nrouter.push({\nname: 'search',\nquery: {\n...route.query,\n...query,\n},\n})\n}\n</script>\nThe route\nobject is a reactive object. In most scenarios, you should avoid watching the whole route\nobject. Instead, you can directly watch the properties you are expecting to change:\n<script setup>\nimport { useRoute } from 'vue-router'\nimport { ref, watch } from 'vue'\nconst route = useRoute()\nconst userData = ref()\n// fetch the user information when params change\nwatch(\n() => route.params.id,\nasync newId => {\nuserData.value = await fetchUser(newId)\n}\n)\n</script>\nNote we still have access to $router\nand $route\nin templates, so there's no need to use useRouter\nor useRoute\nif we only need those objects in the template.\nNavigation Guards\nVue Router exposes update and leave guards as Composition API functions:\n<script setup>\nimport { onBeforeRouteLeave, onBeforeRouteUpdate } from 'vue-router'\nimport { ref } from 'vue'\n// same as beforeRouteLeave option but with no access to `this`\nonBeforeRouteLeave((to, from) => {\nconst answer = window.confirm(\n'Do you really want to leave? you have unsaved changes!'\n)\n// cancel the navigation and stay on the same page\nif (!answer) return false\n})\nconst userData = ref()\n// same as beforeRouteUpdate option but with no access to `this`\nonBeforeRouteUpdate(async (to, from) => {\n// only fetch the user if the id changed as maybe only the query or the hash changed\nif (to.params.id !== from.params.id) {\nuserData.value = await fetchUser(to.params.id)\n}\n})\n</script>\nComposition API guards can also be used in any component rendered by <router-view>\n, they don't have to be used directly on the route component like in-component guards.\nuseLink\nVue Router exposes the internal behavior of RouterLink as a composable. It accepts a reactive object like the props of RouterLink\nand exposes low-level properties to build your own RouterLink\ncomponent or generate custom links:\n<script setup>\nimport { RouterLink, useLink } from 'vue-router'\nimport { computed } from 'vue'\nconst props = defineProps({\n// add @ts-ignore if using TypeScript\n...RouterLink.props,\ninactiveClass: String,\n})\nconst {\n// the resolved route object\nroute,\n// the href to use in a link\nhref,\n// boolean ref indicating if the link is active\nisActive,\n// boolean ref indicating if the link is exactly active\nisExactActive,\n// function to navigate to the link\nnavigate\n} = useLink(props)\nconst isExternalLink = computed(\n() => typeof props.to === 'string' && props.to.startsWith('http')\n)\n</script>\nNote that the RouterLink's v-slot\ngives access to the same properties as the useLink\ncomposable.",
    "metadata": {
      "source": "https://router.vuejs.org/guide/advanced/composition-api",
      "title": "Vue Router and the Composition API | Vue Router"
    }
  },
  {
    "page_content": "Different History modes\nThe history\noption when creating the router instance allows us to choose among different history modes.\nHash Mode\nThe hash history mode is created with createWebHashHistory()\n:\nimport { createRouter, createWebHashHistory } from 'vue-router'\nconst router = createRouter({\nhistory: createWebHashHistory(),\nroutes: [\n//...\n],\n})\nIt uses a hash character (#\n) before the actual URL that is internally passed. Because this section of the URL is never sent to the server, it doesn't require any special treatment on the server level. It does however have a bad impact in SEO. If that's a concern for you, use the HTML5 history mode.\nHTML5 Mode\nThe HTML5 mode is created with createWebHistory()\nand is the recommended mode:\nimport { createRouter, createWebHistory } from 'vue-router'\nconst router = createRouter({\nhistory: createWebHistory(),\nroutes: [\n//...\n],\n})\nWhen using createWebHistory()\n, the URL will look \"normal,\" e.g. https://example.com/user/id\n. Beautiful!\nHere comes a problem, though: Since our app is a single page client side app, without a proper server configuration, the users will get a 404 error if they access https://example.com/user/id\ndirectly in their browser. Now that's ugly.\nNot to worry: To fix the issue, all you need to do is add a simple catch-all fallback route to your server. If the URL doesn't match any static assets, it should serve the same index.html\npage that your app lives in. Beautiful, again!\nMemory mode\nThe memory history mode doesn't assume a browser environment and therefore doesn't interact with the URL nor automatically triggers the initial navigation. This makes it perfect for Node environment and SSR. It is created with createMemoryHistory()\nand requires you to push the initial navigation after calling app.use(router)\n.\nimport { createRouter, createMemoryHistory } from 'vue-router'\nconst router = createRouter({\nhistory: createMemoryHistory(),\nroutes: [\n//...\n],\n})\nWhile it's not recommended, you can use this mode inside Browser applications but note there will be no history, meaning you won't be able to go back or forward.\nExample Server Configurations\nNote: The following examples assume you are serving your app from the root folder. If you deploy to a subfolder, you should use the publicPath\noption of Vue CLI and the related base\nproperty of the router. You also need to adjust the examples below to use the subfolder instead of the root folder (e.g. replacing RewriteBase /\nwith RewriteBase /name-of-your-subfolder/\n).\nApache\n<IfModule mod_negotiation.c>\nOptions -MultiViews\n</IfModule>\n<IfModule mod_rewrite.c>\nRewriteEngine On\nRewriteBase /\nRewriteRule ^index\\.html$ - [L]\nRewriteCond %{REQUEST_FILENAME} !-f\nRewriteCond %{REQUEST_FILENAME} !-d\nRewriteRule . /index.html [L]\n</IfModule>\nInstead of mod_rewrite\n, you could also use FallbackResource\n.\nnginx\nlocation / {\ntry_files $uri $uri/ /index.html;\n}\nNative Node.js\nconst http = require('http')\nconst fs = require('fs')\nconst httpPort = 80\nhttp\n.createServer((req, res) => {\nfs.readFile('index.html', 'utf-8', (err, content) => {\nif (err) {\nconsole.log('We cannot open \"index.html\" file.')\n}\nres.writeHead(200, {\n'Content-Type': 'text/html; charset=utf-8',\n})\nres.end(content)\n})\n})\n.listen(httpPort, () => {\nconsole.log('Server listening on: http://localhost:%s', httpPort)\n})\nExpress with Node.js\nFor Node.js/Express, consider using connect-history-api-fallback middleware.\nInternet Information Services (IIS)\n- Install IIS UrlRewrite\n- Create a\nweb.config\nfile in the root directory of your site with the following:\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<configuration>\n<system.webServer>\n<rewrite>\n<rules>\n<rule name=\"Handle History Mode and custom 404/500\" stopProcessing=\"true\">\n<match url=\"(.*)\" />\n<conditions logicalGrouping=\"MatchAll\">\n<add input=\"{REQUEST_FILENAME}\" matchType=\"IsFile\" negate=\"true\" />\n<add input=\"{REQUEST_FILENAME}\" matchType=\"IsDirectory\" negate=\"true\" />\n</conditions>\n<action type=\"Rewrite\" url=\"/\" />\n</rule>\n</rules>\n</rewrite>\n</system.webServer>\n</configuration>\nCaddy v2\ntry_files {path} /\nCaddy v1\nrewrite {\nregexp .*\nto {path} /\n}\nFirebase hosting\nAdd this to your firebase.json\n:\n{\n\"hosting\": {\n\"public\": \"dist\",\n\"rewrites\": [\n{\n\"source\": \"**\",\n\"destination\": \"/index.html\"\n}\n]\n}\n}\nNetlify\nCreate a _redirects\nfile that is included with your deployed files:\n/* /index.html 200\nIn vue-cli, nuxt, and vite projects, this file usually goes under a folder named static\nor public\n.\nYou can read more about the syntax on Netlify documentation. You can also create a netlify.toml\nto combine redirections with other Netlify features.\nVercel\nCreate a vercel.json\nfile under the root directory of your project with the following:\n{\n\"rewrites\": [{ \"source\": \"/:path*\", \"destination\": \"/index.html\" }]\n}\nCaveat\nThere is a caveat to this: Your server will no longer report 404 errors as all not-found paths now serve up your index.html\nfile. To get around the issue, you should implement a catch-all route within your Vue app to show a 404 page:\nconst router = createRouter({\nhistory: createWebHistory(),\nroutes: [{ path: '/:pathMatch(.*)', component: NotFoundComponent }],\n})\nAlternatively, if you are using a Node.js server, you can implement the fallback by using the router on the server side to match the incoming URL and respond with 404 if no route is matched. Check out the Vue server side rendering documentation for more information.",
    "metadata": {
      "source": "https://router.vuejs.org/guide/essentials/history-mode",
      "title": "Different History modes | Vue Router"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nProduction Deployment\nMost of the tips below are enabled by default if you are using Vue CLI. This section is only relevant if you are using a custom build setup.\nTurn on Production Mode\nDuring development, Vue provides a lot of warnings to help you with common errors and pitfalls. However, these warning strings become useless in production and bloat your app’s payload size. In addition, some of these warning checks have small runtime costs that can be avoided in production mode.\nWithout Build Tools\nIf you are using the full build, i.e. directly including Vue via a script tag without a build tool, make sure to use the minified version (vue.min.js\n) for production. Both versions can be found in the Installation guide.\nWith Build Tools\nWhen using a build tool like Webpack or Browserify, the production mode will be determined by process.env.NODE_ENV\ninside Vue’s source code, and it will be in development mode by default. Both build tools provide ways to overwrite this variable to enable Vue’s production mode, and warnings will be stripped by minifiers during the build. All vue-cli\ntemplates have these pre-configured for you, but it would be beneficial to know how it is done:\nWebpack\nIn Webpack 4+, you can use the mode\noption:\n|\nBut in Webpack 3 and earlier, you’ll need to use DefinePlugin:\n|\nBrowserify\nRun your bundling command with the actual\nNODE_ENV\nenvironment variable set to\"production\"\n. This tellsvueify\nto avoid including hot-reload and development related code.Apply a global envify transform to your bundle. This allows the minifier to strip out all the warnings in Vue’s source code wrapped in env variable conditional blocks. For example:\nNODE_ENV=production browserify -g envify -e main.js | uglifyjs -c -m > build.js\nOr, using envify with Gulp:\n// Use the envify custom module to specify environment variables\nvar envify = require('envify/custom')\nbrowserify(browserifyOptions)\n.transform(vueify)\n.transform(\n// Required in order to process node_modules files\n{ global: true },\nenvify({ NODE_ENV: 'production' })\n)\n.bundle()Or, using envify with Grunt and grunt-browserify:\n// Use the envify custom module to specify environment variables\nvar envify = require('envify/custom')\nbrowserify: {\ndist: {\noptions: {\n// Function to deviate from grunt-browserify's default order\nconfigure: b => b\n.transform('vueify')\n.transform(\n// Required in order to process node_modules files\n{ global: true },\nenvify({ NODE_ENV: 'production' })\n)\n.bundle()\n}\n}\n}\nRollup\n|\nPre-Compiling Templates\nWhen using in-DOM templates or in-JavaScript template strings, the template-to-render-function compilation is performed on the fly. This is usually fast enough in most cases, but is best avoided if your application is performance-sensitive.\nThe easiest way to pre-compile templates is using Single-File Components - the associated build setups automatically performs pre-compilation for you, so the built code contains the already compiled render functions instead of raw template strings.\nIf you are using Webpack, and prefer separating JavaScript and template files, you can use vue-template-loader, which also transforms the template files into JavaScript render functions during the build step.\nExtracting Component CSS\nWhen using Single-File Components, the CSS inside components are injected dynamically as <style>\ntags via JavaScript. This has a small runtime cost, and if you are using server-side rendering it will cause a “flash of unstyled content”. Extracting the CSS across all components into the same file will avoid these issues, and also result in better CSS minification and caching.\nRefer to the respective build tool documentations to see how it’s done:\n- Webpack + vue-loader (the\nvue-cli\nwebpack template has this pre-configured) - Browserify + vueify\n- Rollup + rollup-plugin-vue\nTracking Runtime Errors\nIf a runtime error occurs during a component’s render, it will be passed to the global Vue.config.errorHandler\nconfig function if it has been set. It might be a good idea to leverage this hook together with an error-tracking service like Sentry, which provides an official integration for Vue.",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/deployment",
      "title": "Production Deployment — Vue.js"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nProps\nThis page assumes you’ve already read the Components Basics. Read that first if you are new to components.\nProp Casing (camelCase vs kebab-case)\nHTML attribute names are case-insensitive, so browsers will interpret any uppercase characters as lowercase. That means when you’re using in-DOM templates, camelCased prop names need to use their kebab-cased (hyphen-delimited) equivalents:\n|\n|\nAgain, if you’re using string templates, this limitation does not apply.\nProp Types\nSo far, we’ve only seen props listed as an array of strings:\n|\nUsually though, you’ll want every prop to be a specific type of value. In these cases, you can list props as an object, where the properties’ names and values contain the prop names and types, respectively:\n|\nThis not only documents your component, but will also warn users in the browser’s JavaScript console if they pass the wrong type. You’ll learn much more about type checks and other prop validations further down this page.\nPassing Static or Dynamic Props\nSo far, you’ve seen props passed a static value, like in:\n|\nYou’ve also seen props assigned dynamically with v-bind\n, such as in:\n|\nIn the two examples above, we happen to pass string values, but any type of value can actually be passed to a prop.\nPassing a Number\n|\nPassing a Boolean\n|\nPassing an Array\n|\nPassing an Object\n|\nPassing the Properties of an Object\nIf you want to pass all the properties of an object as props, you can use v-bind\nwithout an argument (v-bind\ninstead of v-bind:prop-name\n). For example, given a post\nobject:\n|\nThe following template:\n|\nWill be equivalent to:\n|\nOne-Way Data Flow\nAll props form a one-way-down binding between the child property and the parent one: when the parent property updates, it will flow down to the child, but not the other way around. This prevents child components from accidentally mutating the parent’s state, which can make your app’s data flow harder to understand.\nIn addition, every time the parent component is updated, all props in the child component will be refreshed with the latest value. This means you should not attempt to mutate a prop inside a child component. If you do, Vue will warn you in the console.\nThere are usually two cases where it’s tempting to mutate a prop:\nThe prop is used to pass in an initial value; the child component wants to use it as a local data property afterwards. In this case, it’s best to define a local data property that uses the prop as its initial value:\nprops: ['initialCounter'],\ndata: function () {\nreturn {\ncounter: this.initialCounter\n}\n}The prop is passed in as a raw value that needs to be transformed. In this case, it’s best to define a computed property using the prop’s value:\nprops: ['size'],\ncomputed: {\nnormalizedSize: function () {\nreturn this.size.trim().toLowerCase()\n}\n}\nNote that objects and arrays in JavaScript are passed by reference, so if the prop is an array or object, mutating the object or array itself inside the child component will affect parent state.\nProp Validation\nComponents can specify requirements for their props, such as the types you’ve already seen. If a requirement isn’t met, Vue will warn you in the browser’s JavaScript console. This is especially useful when developing a component that’s intended to be used by others.\nTo specify prop validations, you can provide an object with validation requirements to the value of props\n, instead of an array of strings. For example:\n|\nWhen prop validation fails, Vue will produce a console warning (if using the development build).\nNote that props are validated before a component instance is created, so instance properties (e.g. data\n, computed\n, etc) will not be available inside default\nor validator\nfunctions.\nType Checks\nThe type\ncan be one of the following native constructors:\n- String\n- Number\n- Boolean\n- Array\n- Object\n- Date\n- Function\n- Symbol\nIn addition, type\ncan also be a custom constructor function and the assertion will be made with an instanceof\ncheck. For example, given the following constructor function exists:\n|\nYou could use:\n|\nto validate that the value of the author\nprop was created with new Person\n.\nNon-Prop Attributes\nA non-prop attribute is an attribute that is passed to a component, but does not have a corresponding prop defined.\nWhile explicitly defined props are preferred for passing information to a child component, authors of component libraries can’t always foresee the contexts in which their components might be used. That’s why components can accept arbitrary attributes, which are added to the component’s root element.\nFor example, imagine we’re using a 3rd-party bootstrap-date-input\ncomponent with a Bootstrap plugin that requires a data-date-picker\nattribute on the input\n. We can add this attribute to our component instance:\n|\nAnd the data-date-picker=\"activated\"\nattribute will automatically be added to the root element of bootstrap-date-input\n.\nReplacing/Merging with Existing Attributes\nImagine this is the template for bootstrap-date-input\n:\n|\nTo specify a theme for our date picker plugin, we might need to add a specific class, like this:\n|\nIn this case, two different values for class\nare defined:\nform-control\n, which is set by the component in its templatedate-picker-theme-dark\n, which is passed to the component by its parent\nFor most attributes, the value provided to the component will replace the value set by the component. So for example, passing type=\"text\"\nwill replace type=\"date\"\nand probably break it! Fortunately, the class\nand style\nattributes are a little smarter, so both values are merged, making the final value: form-control date-picker-theme-dark\n.\nDisabling Attribute Inheritance\nIf you do not want the root element of a component to inherit attributes, you can set inheritAttrs: false\nin the component’s options. For example:\n|\nThis can be especially useful in combination with the $attrs\ninstance property, which contains the attribute names and values passed to a component, such as:\n|\nWith inheritAttrs: false\nand $attrs\n, you can manually decide which element you want to forward attributes to, which is often desirable for base components:\n|\nNote that inheritAttrs: false\noption does not affect style\nand class\nbindings.\nThis pattern allows you to use base components more like raw HTML elements, without having to care about which element is actually at its root:\n|",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/components-props",
      "title": "Props — Vue.js"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nDynamic & Async Components\nThis page assumes you’ve already read the Components Basics. Read that first if you are new to components.\nkeep-alive\nwith Dynamic Components\nEarlier, we used the is\nattribute to switch between components in a tabbed interface:\n|\nWhen switching between these components though, you’ll sometimes want to maintain their state or avoid re-rendering for performance reasons. For example, when expanding our tabbed interface a little:\nYou’ll notice that if you select a post, switch to the Archive tab, then switch back to Posts, it’s no longer showing the post you selected. That’s because each time you switch to a new tab, Vue creates a new instance of the currentTabComponent\n.\nRecreating dynamic components is normally useful behavior, but in this case, we’d really like those tab component instances to be cached once they’re created for the first time. To solve this problem, we can wrap our dynamic component with a <keep-alive>\nelement:\n|\nCheck out the result below:\nNow the Posts tab maintains its state (the selected post) even when it’s not rendered. See this example for the complete code.\nNote that <keep-alive>\nrequires the components being switched between to all have names, either using the name\noption on a component, or through local/global registration.\nCheck out more details on <keep-alive>\nin the API reference.\nAsync Components\nIn large applications, we may need to divide the app into smaller chunks and only load a component from the server when it’s needed. To make that easier, Vue allows you to define your component as a factory function that asynchronously resolves your component definition. Vue will only trigger the factory function when the component needs to be rendered and will cache the result for future re-renders. For example:\n|\nAs you can see, the factory function receives a resolve\ncallback, which should be called when you have retrieved your component definition from the server. You can also call reject(reason)\nto indicate the load has failed. The setTimeout\nhere is for demonstration; how to retrieve the component is up to you. One recommended approach is to use async components together with Webpack’s code-splitting feature:\n|\nYou can also return a Promise\nin the factory function, so with Webpack 2 and ES2015 syntax you can make use of dynamic imports:\n|\nWhen using local registration, you can also directly provide a function that returns a Promise\n:\n|\nIf you’re a Browserify user that would like to use async components, its creator has unfortunately made it clear that async loading “is not something that Browserify will ever support.” Officially, at least. The Browserify community has found some workarounds, which may be helpful for existing and complex applications. For all other scenarios, we recommend using Webpack for built-in, first-class async support.\nHandling Loading State\nNew in 2.3.0+\nThe async component factory can also return an object of the following format:\n|\nNote that you must use Vue Router 2.4.0+ if you wish to use the above syntax for route components.",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/components-dynamic-async",
      "title": "Dynamic & Async Components — Vue.js"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nMigration from Vuex 0.6.x to 1.0\nVuex 2.0 is released, but this guide only covers the migration to 1.0? Is that a typo? Also, it looks like Vuex 1.0 and 2.0 were released simultaneously. What’s going on? Which one should I use and what’s compatible with Vue 2.0?\nBoth Vuex 1.0 and 2.0:\n- fully support both Vue 1.0 and 2.0\n- will be maintained for the foreseeable future\nThey have slightly different target users however.\nVuex 2.0 is a radical redesign and simplification of the API, for those who are starting new projects or want to be on the cutting edge of client-side state management. It is not covered by this migration guide, so you should check out the Vuex 2.0 docs if you’d like to learn more about it.\nVuex 1.0 is mostly backwards-compatible, so requires very few changes to upgrade. It is recommended for those with large existing codebases or who want the smoothest possible upgrade path to Vue 2.0. This guide is dedicated to facilitating that process, but only includes migration notes. For the complete usage guide, see the Vuex 1.0 docs.\nstore.watch\nwith String Property Path replaced\nstore.watch\nnow only accept functions. So for example, you would have to replace:\n|\nwith:\n|\nThis gives you more complete control over the reactive properties you’d like to watch.\nUpgrade Path\nRun the migration helper on your codebase to find examples of store.watch\nwith a string as the first argument.\nStore’s Event Emitter removed\nThe store instance no longer exposes the event emitter interface (on\n, off\n, emit\n). If you were previously using the store as a global event bus, see this section for migration instructions.\nInstead of using this interface to watch events emitted by the store itself (e.g. store.on('mutation', callback)\n), a new method store.subscribe\nis introduced. Typical usage inside a plugin would be:\n|\nSee example the plugins docs for more info.\nUpgrade Path\nRun the migration helper on your codebase to find examples of store.on\n, store.off\n, and store.emit\n.\nMiddlewares replaced\nMiddlewares are replaced by plugins. A plugin is a function that receives the store as the only argument, and can listen to the mutation event on the store:\n|\nFor more details, see the plugins docs.\nUpgrade Path\nRun the migration helper on your codebase to find examples of the middlewares\noption on a store.",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/migration-vuex",
      "title": "Migration from Vuex 0.6.x to 1.0 — Vue.js"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nTypeScript Support\nVue CLI provides built-in TypeScript tooling support.\nOfficial Declaration in NPM Packages\nA static type system can help prevent many potential runtime errors, especially as applications grow. That’s why Vue ships with official type declarations for TypeScript - not only in Vue core, but also for vue-router and vuex as well.\nSince these are published on NPM, and the latest TypeScript knows how to resolve type declarations in NPM packages, this means when installed via NPM, you don’t need any additional tooling to use TypeScript with Vue.\nRecommended Configuration\n|\nNote that you have to include strict: true\n(or at least noImplicitThis: true\nwhich is a part of strict\nflag) to leverage type checking of this\nin component methods otherwise it is always treated as any\ntype.\nSee TypeScript compiler options docs for more details.\nDevelopment Tooling\nProject Creation\nVue CLI 3 can generate new projects that use TypeScript. To get started:\n|\nEditor Support\nFor developing Vue applications with TypeScript, we strongly recommend using Visual Studio Code, which provides great out-of-the-box support for TypeScript. If you are using single-file components (SFCs), get the awesome Vetur extension, which provides TypeScript inference inside SFCs and many other great features.\nWebStorm also provides out-of-the-box support for both TypeScript and Vue.\nBasic Usage\nTo let TypeScript properly infer types inside Vue component options, you need to define components with Vue.component\nor Vue.extend\n:\n|\nClass-Style Vue Components\nIf you prefer a class-based API when declaring components, you can use the officially maintained vue-class-component decorator:\n|\nAugmenting Types for Use with Plugins\nPlugins may add to Vue’s global/instance properties and component options. In these cases, type declarations are needed to make plugins compile in TypeScript. Fortunately, there’s a TypeScript feature to augment existing types called module augmentation.\nFor example, to declare an instance property $myProperty\nwith type string\n:\n|\nAfter including the above code as a declaration file (like my-property.d.ts\n) in your project, you can use $myProperty\non a Vue instance.\n|\nYou can also declare additional global properties and component options:\n|\nThe above declarations allow the following code to be compiled:\n|\nAnnotating Return Types\nBecause of the circular nature of Vue’s declaration files, TypeScript may have difficulties inferring the types of certain methods. For this reason, you may need to annotate the return type on methods like render\nand those in computed\n.\n|\nIf you find type inference or member completion isn’t working, annotating certain methods may help address these problems. Using the --noImplicitAny\noption will help find many of these unannotated methods.\nAnnotating Props\n|\nIf you find validator not getting type inference or member completion isn’t working, annotating the argument with the expected type may help address these problems.",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/typescript",
      "title": "TypeScript Support — Vue.js"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nCustom Events\nThis page assumes you’ve already read the Components Basics. Read that first if you are new to components.\nEvent Names\nUnlike components and props, event names don’t provide any automatic case transformation. Instead, the name of an emitted event must exactly match the name used to listen to that event. For example, if emitting a camelCased event name:\n|\nListening to the kebab-cased version will have no effect:\n|\nUnlike components and props, event names will never be used as variable or property names in JavaScript, so there’s no reason to use camelCase or PascalCase. Additionally, v-on\nevent listeners inside DOM templates will be automatically transformed to lowercase (due to HTML’s case-insensitivity), so v-on:myEvent\nwould become v-on:myevent\n– making myEvent\nimpossible to listen to.\nFor these reasons, we recommend you always use kebab-case for event names.\nCustomizing Component v-model\nNew in 2.2.0+\nBy default, v-model\non a component uses value\nas the prop and input\nas the event, but some input types such as checkboxes and radio buttons may want to use the value\nattribute for a different purpose. Using the model\noption can avoid a conflict in such cases:\n|\nNow when using v-model\non this component:\n|\nthe value of lovingVue\nwill be passed to the checked\nprop. The lovingVue\nproperty will then be updated when <base-checkbox>\nemits a change\nevent with a new value.\nNote that you still have to declare the checked\nprop in the component’s props\noption.\nBinding Native Events to Components\nThere may be times when you want to listen directly to a native event on the root element of a component. In these cases, you can use the .native\nmodifier for v-on\n:\n|\nThis can be useful sometimes, but it’s not a good idea when you’re trying to listen on a very specific element, like an <input>\n. For example, the <base-input>\ncomponent above might refactor so that the root element is actually a <label>\nelement:\n|\nIn that case, the .native\nlistener in the parent would silently break. There would be no errors, but the onFocus\nhandler wouldn’t be called when we expected it to.\nTo solve this problem, Vue provides a $listeners\nproperty containing an object of listeners being used on the component. For example:\n|\nUsing the $listeners\nproperty, you can forward all event listeners on the component to a specific child element with v-on=\"$listeners\"\n. For elements like <input>\n, that you also want to work with v-model\n, it’s often useful to create a new computed property for listeners, like inputListeners\nbelow:\n|\nNow the <base-input>\ncomponent is a fully transparent wrapper, meaning it can be used exactly like a normal <input>\nelement: all the same attributes and listeners will work, without the .native\nmodifier.\n.sync\nModifier\nNew in 2.3.0+\nIn some cases, we may need “two-way binding” for a prop. Unfortunately, true two-way binding can create maintenance issues, because child components can mutate the parent without the source of that mutation being obvious in both the parent and the child.\nThat’s why instead, we recommend emitting events in the pattern of update:myPropName\n. For example, in a hypothetical component with a title\nprop, we could communicate the intent of assigning a new value with:\n|\nThen the parent can listen to that event and update a local data property, if it wants to. For example:\n|\nFor convenience, we offer a shorthand for this pattern with the .sync\nmodifier:\n|\nNote that v-bind\nwith the .sync\nmodifier does not work with expressions (e.g. v-bind:title.sync=”doc.title + ‘!’”\nis invalid). Instead, you must only provide the name of the property you want to bind, similar to v-model\n.\nThe .sync\nmodifier can also be used with v-bind\nwhen using an object to set multiple props at once:\n|\nThis passes each property in the doc\nobject (e.g. title\n) as an individual prop, then adds v-on\nupdate listeners for each one.\nUsing v-bind.sync\nwith a literal object, such as in v-bind.sync=”{ title: doc.title }”\n, will not work, because there are too many edge cases to consider in parsing a complex expression like this.",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/components-custom-events",
      "title": "Custom Events — Vue.js"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nTemplate Syntax\nVue.js uses an HTML-based template syntax that allows you to declaratively bind the rendered DOM to the underlying Vue instance’s data. All Vue.js templates are valid HTML that can be parsed by spec-compliant browsers and HTML parsers.\nUnder the hood, Vue compiles the templates into Virtual DOM render functions. Combined with the reactivity system, Vue is able to intelligently figure out the minimal number of components to re-render and apply the minimal amount of DOM manipulations when the app state changes.\nIf you are familiar with Virtual DOM concepts and prefer the raw power of JavaScript, you can also directly write render functions instead of templates, with optional JSX support.\nInterpolations\nText\nThe most basic form of data binding is text interpolation using the “Mustache” syntax (double curly braces):\n|\nThe mustache tag will be replaced with the value of the msg\nproperty on the corresponding data object. It will also be updated whenever the data object’s msg\nproperty changes.\nYou can also perform one-time interpolations that do not update on data change by using the v-once directive, but keep in mind this will also affect any other bindings on the same node:\n|\nRaw HTML\nThe double mustaches interprets the data as plain text, not HTML. In order to output real HTML, you will need to use the v-html\ndirective:\n|\nUsing mustaches: {{ rawHtml }}\nUsing v-html directive:\nThe contents of the span\nwill be replaced with the value of the rawHtml\nproperty, interpreted as plain HTML - data bindings are ignored. Note that you cannot use v-html\nto compose template partials, because Vue is not a string-based templating engine. Instead, components are preferred as the fundamental unit for UI reuse and composition.\nDynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to XSS vulnerabilities. Only use HTML interpolation on trusted content and never on user-provided content.\nAttributes\nMustaches cannot be used inside HTML attributes. Instead, use a v-bind\ndirective:\n|\nIn the case of boolean attributes, where their mere existence implies true\n, v-bind\nworks a little differently. In this example:\n|\nIf isButtonDisabled\nhas the value of null\n, undefined\n, or false\n, the disabled\nattribute will not even be included in the rendered <button>\nelement.\nUsing JavaScript Expressions\nSo far we’ve only been binding to simple property keys in our templates. But Vue.js actually supports the full power of JavaScript expressions inside all data bindings:\n|\nThese expressions will be evaluated as JavaScript in the data scope of the owner Vue instance. One restriction is that each binding can only contain one single expression, so the following will NOT work:\n|\nTemplate expressions are sandboxed and only have access to a whitelist of globals such as Math\nand Date\n. You should not attempt to access user-defined globals in template expressions.\nDirectives\nDirectives are special attributes with the v-\nprefix. Directive attribute values are expected to be a single JavaScript expression (with the exception of v-for\n, which will be discussed later). A directive’s job is to reactively apply side effects to the DOM when the value of its expression changes. Let’s review the example we saw in the introduction:\n|\nHere, the v-if\ndirective would remove/insert the <p>\nelement based on the truthiness of the value of the expression seen\n.\nArguments\nSome directives can take an “argument”, denoted by a colon after the directive name. For example, the v-bind\ndirective is used to reactively update an HTML attribute:\n|\nHere href\nis the argument, which tells the v-bind\ndirective to bind the element’s href\nattribute to the value of the expression url\n.\nAnother example is the v-on\ndirective, which listens to DOM events:\n|\nHere the argument is the event name to listen to. We will talk about event handling in more detail too.\nDynamic Arguments\nNew in 2.6.0+\nStarting in version 2.6.0, it is also possible to use a JavaScript expression in a directive argument by wrapping it with square brackets:\n|\nHere attributeName\nwill be dynamically evaluated as a JavaScript expression, and its evaluated value will be used as the final value for the argument. For example, if your Vue instance has a data property, attributeName\n, whose value is \"href\"\n, then this binding will be equivalent to v-bind:href\n.\nSimilarly, you can use dynamic arguments to bind a handler to a dynamic event name:\n|\nIn this example, when eventName\n‘s value is \"focus\"\n, v-on:[eventName]\nwill be equivalent to v-on:focus\n.\nDynamic Argument Value Constraints\nDynamic arguments are expected to evaluate to a string, with the exception of null\n. The special value null\ncan be used to explicitly remove the binding. Any other non-string value will trigger a warning.\nDynamic Argument Expression Constraints\nDynamic argument expressions have some syntax constraints because certain characters, such as spaces and quotes, are invalid inside HTML attribute names. For example, the following is invalid:\n|\nThe workaround is to either use expressions without spaces or quotes, or replace the complex expression with a computed property.\nWhen using in-DOM templates (i.e., templates written directly in an HTML file), you should also avoid naming keys with uppercase characters, as browsers will coerce attribute names into lowercase:\n|\nModifiers\nModifiers are special postfixes denoted by a dot, which indicate that a directive should be bound in some special way. For example, the .prevent\nmodifier tells the v-on\ndirective to call event.preventDefault()\non the triggered event:\n|\nYou’ll see other examples of modifiers later, for v-on\nand for v-model\n, when we explore those features.\nShorthands\nThe v-\nprefix serves as a visual cue for identifying Vue-specific attributes in your templates. This is useful when you are using Vue.js to apply dynamic behavior to some existing markup, but can feel verbose for some frequently used directives. At the same time, the need for the v-\nprefix becomes less important when you are building a SPA, where Vue manages every template. Therefore, Vue provides special shorthands for two of the most often used directives, v-bind\nand v-on\n:\nv-bind\nShorthand\n|\nv-on\nShorthand\n|\nThey may look a bit different from normal HTML, but :\nand @\nare valid characters for attribute names and all Vue-supported browsers can parse it correctly. In addition, they do not appear in the final rendered markup. The shorthand syntax is totally optional, but you will likely appreciate it when you learn more about its usage later.",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/syntax",
      "title": "Template Syntax — Vue.js"
    }
  },
  {
    "page_content": "Become a Sponsor\nGuide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nBecome a Sponsor\nMeet the Team\nActive Core Team Members\nFailed to get your location.\nThe development of Vue and its ecosystem is guided by an international team, some of whom have chosen to be featured below.\nThe core team has been sorted by their distance from you.\nCore Team Emeriti\nHere we honor some no-longer-active core team members who have made valuable contributions in the past.\nCommunity Partners\nFailed to get your location.\nSome members of the Vue community have so enriched it, that they deserve special mention. We've developed a more intimate relationship with these key partners, often coordinating with them on upcoming features and news.\nThe community partners have been sorted by their distance from you.\nCaught a mistake or want to contribute to the documentation?\nEdit this on GitHub!\nDeployed on\nNetlify .",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/team",
      "title": "Meet the Team — Vue.js"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nJoin the Vue.js Community!\nVue’s community is growing incredibly fast and if you’re reading this, there’s a good chance you’re ready to join it. So… welcome!\nNow we’ll answer both what the community can do for you and what you can do for the community.\nResources\nCode of Conduct\nOur Code of Conduct is a guide to make it easier to enrich all of us and the technical communities in which we participate.\nGet Support\n- Forum: The best place to ask questions and get answers about Vue and its ecosystem.\n- Chat: A place for Vue devs to meet and chat in real time.\n- Meetups: Want to find local Vue.js enthusiasts like yourself? Interested in becoming a community leader? We have the help and support you need right here!\n- GitHub: If you have a bug to report or feature to request, that’s what the GitHub issues are for. We also welcome pull requests!\nExplore the Ecosystem\n- The Awesome Vue Page: See what other awesome resources have been published by other awesome people.\n- The “Show and Tell” Subforum: Another great place to check out what others have built with and for the growing Vue ecosystem.\nWhat You Can Do\nContribute Code\nAs with any project, there are rules to contributing. To ensure that we can help you or accept your pull request as quickly as possible, please read the contributing guide.\nAfter that, you’ll be ready to contribute to Vue’s core repositories:\n- vue: the core library\n- vuex: Flux-inspired state management\n- vue-router: a routing system for SPAs\n…as well as many smaller official companion libraries.\nShare (and Build) Your Experience\nApart from answering questions and sharing resources in the forum and chat, there are a few other less obvious ways to share and expand what you know:\n- Develop learning materials. It’s often said that the best way to learn is to teach. If there’s something interesting you’re doing with Vue, strengthen your expertise by writing a blog post, developing a workshop, or even publishing a gist that you share on social media.\n- Watch a repo you care about. This will send you notifications whenever there’s activity in that repository, giving you insider knowledge about ongoing discussions and upcoming features. It’s a fantastic way to build expertise so that you’re eventually able to help address issues and pull requests.\nTranslate Docs\nVue has already spread across the globe, with even the core team in at least half a dozen timezones. The forum includes 7 languages and counting and many of our docs have actively-maintained translations. We’re very proud of Vue’s international reach, but we can do even better.\nI hope that right now, you’re reading this sentence in your preferred language. If not, would you like to help us get there?\nIf so, please feel free to fork the repo for these docs or for any other officially maintained documentation, then start translating. Once you’ve made some progress, open an issue or pull request in the main repo and we’ll put out a call for more contributors to help you out.\nBecome a Community Leader\nThere’s a lot you can do to help Vue grow in your community:\n- Present at your local meetup. Whether it’s giving a talk or running a workshop, you can bring a lot of value to your community by helping both new and experienced Vue developers continue to grow.\n- Start your own meetup. If there’s not already a Vue meetup in your area, you can start your own! Use the resources at events.vuejs.org to help you succeed!\n- Help meetup organizers. There can never be too much help when it comes to running an event, so offer a hand to help out local organizers to help make every event a success.\nIf you have any questions on how you can get more involved with your local Vue community, reach out at @Vuejs_Events!",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/join",
      "title": "Join the Vue.js Community! — Vue.js"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nComponent Registration\nThis page assumes you’ve already read the Components Basics. Read that first if you are new to components.\nComponent Names\nWhen registering a component, it will always be given a name. For example, in the global registration we’ve seen so far:\n|\nThe component’s name is the first argument of Vue.component\n.\nThe name you give a component may depend on where you intend to use it. When using a component directly in the DOM (as opposed to in a string template or single-file component), we strongly recommend following the W3C rules for custom tag names (all-lowercase, must contain a hyphen). This helps you avoid conflicts with current and future HTML elements.\nYou can see other recommendations for component names in the Style Guide.\nName Casing\nYou have two options when defining component names:\nWith kebab-case\n|\nWhen defining a component with kebab-case, you must also use kebab-case when referencing its custom element, such as in <my-component-name>\n.\nWith PascalCase\n|\nWhen defining a component with PascalCase, you can use either case when referencing its custom element. That means both <my-component-name>\nand <MyComponentName>\nare acceptable. Note, however, that only kebab-case names are valid directly in the DOM (i.e. non-string templates).\nGlobal Registration\nSo far, we’ve only created components using Vue.component\n:\n|\nThese components are globally registered. That means they can be used in the template of any root Vue instance (new Vue\n) created after registration. For example:\n|\n|\nThis even applies to all subcomponents, meaning all three of these components will also be available inside each other.\nLocal Registration\nGlobal registration often isn’t ideal. For example, if you’re using a build system like Webpack, globally registering all components means that even if you stop using a component, it could still be included in your final build. This unnecessarily increases the amount of JavaScript your users have to download.\nIn these cases, you can define your components as plain JavaScript objects:\n|\nThen define the components you’d like to use in a components\noption:\n|\nFor each property in the components\nobject, the key will be the name of the custom element, while the value will contain the options object for the component.\nNote that locally registered components are not also available in subcomponents. For example, if you wanted ComponentA\nto be available in ComponentB\n, you’d have to use:\n|\nOr if you’re using ES2015 modules, such as through Babel and Webpack, that might look more like:\n|\nNote that in ES2015+, placing a variable name like ComponentA\ninside an object is shorthand for ComponentA: ComponentA\n, meaning the name of the variable is both:\n- the custom element name to use in the template, and\n- the name of the variable containing the component options\nModule Systems\nIf you’re not using a module system with import\n/require\n, you can probably skip this section for now. If you are, we have some special instructions and tips just for you.\nLocal Registration in a Module System\nIf you’re still here, then it’s likely you’re using a module system, such as with Babel and Webpack. In these cases, we recommend creating a components\ndirectory, with each component in its own file.\nThen you’ll need to import each component you’d like to use, before you locally register it. For example, in a hypothetical ComponentB.js\nor ComponentB.vue\nfile:\n|\nNow both ComponentA\nand ComponentC\ncan be used inside ComponentB\n‘s template.\nAutomatic Global Registration of Base Components\nMany of your components will be relatively generic, possibly only wrapping an element like an input or a button. We sometimes refer to these as base components and they tend to be used very frequently across your components.\nThe result is that many components may include long lists of base components:\n|\nJust to support relatively little markup in a template:\n|\nFortunately, if you’re using Webpack (or Vue CLI 3+, which uses Webpack internally), you can use require.context\nto globally register only these very common base components. Here’s an example of the code you might use to globally import base components in your app’s entry file (e.g. src/main.js\n):\n|\nRemember that global registration must take place before the root Vue instance is created (with new Vue\n). Here’s an example of this pattern in a real project context.",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/components-registration",
      "title": "Component Registration — Vue.js"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nMigration to Vue 2.7\nVue 2.7 is the latest minor version of Vue 2. It provides built-in support for the Composition API.\nDespite Vue 3 now being the default version, we understand that there are still many users who have to stay on Vue 2 due to dependency compatibility, browser support requirements, or simply not enough bandwidth to upgrade. In Vue 2.7, we have backported some of the most important features from Vue 3 so that Vue 2 users can benefit from them as well.\nBackported Features\n- Composition API\n- SFC\n<script setup>\n- SFC CSS v-bind\nIn addition, the following APIs are also supported:\ndefineComponent()\nwith improved type inference (compared toVue.extend\n)h()\n,useSlot()\n,useAttrs()\n,useCssModules()\nset()\n,del()\nandnextTick()\nare also provided as named exports in ESM builds.The\nemits\noption is also supported, but only for type-checking purposes (does not affect runtime behavior)2.7 also supports using ESNext syntax in template expressions. When using a build system, the compiled template render function will go through the same loaders / plugins configured for normal JavaScript. This means if you have configured Babel for\n.js\nfiles, it will also apply to the expressions in your SFC templates.\nNotes on API exposure\nIn ESM builds, these APIs are provided as named exports (and named exports only):\nimport Vue, { ref } from \"vue\";\nVue.ref; // undefined, use named export insteadIn UMD and CJS builds, these APIs are exposed as properties on the global\nVue\nobject.When bundling with CJS builds externalized, bundlers should be able to handle ESM interop when externalizing CJS builds.\nBehavior Differences from Vue 3\nThe Composition API is backported using Vue 2’s getter/setter-based reactivity system to ensure browser compatibility. This means there are some important behavior differences from Vue 3’s proxy-based system:\nAll Vue 2 change detection caveats still apply.\nreactive()\n,ref()\n, andshallowReactive()\nwill directly convert original objects instead of creating proxies. This means:// true in 2.7, false in 3.x\nreactive(foo) === foo;readonly()\ndoes create a separate object, but it won’t track newly added properties and does not work on arrays.Avoid using arrays as root values in\nreactive()\nbecause without property access the array’s mutation won’t be tracked (this will result in a warning).Reactivity APIs ignore properties with symbol keys.\nIn addition, the following features are explicitly NOT ported:\n- ❌\ncreateApp()\n(Vue 2 doesn’t have isolated app scope) - ❌ Top-level\nawait\nin<script setup>\n(Vue 2 does not support async component initialization) - ❌ TypeScript syntax in template expressions (incompatible w/ Vue 2 parser)\n- ❌ Reactivity transform (still experimental)\n- ❌\nexpose\noption is not supported for options components (butdefineExpose()\nis supported in<script setup>\n).\nUpgrade Guide\nVue CLI / webpack\nUpgrade local\n@vue/cli-xxx\ndependencies the latest version in your major version range (if applicable):~4.5.18\nfor v4~5.0.6\nfor v5\nUpgrade\nvue\nto^2.7.0\n. You can also removevue-template-compiler\nfrom the dependencies - it is no longer needed in 2.7.Note: if you are using\n@vue/test-utils\n, you will need to keepvue-template-compiler\nin the dependencies because test utils rely on some APIs only exposed in this package.Check your package manager lockfile to ensure the following dependencies meet the version requirements. They may be transitive dependencies not listed in\npackage.json\n.vue-loader\n:^15.10.0\nvue-demi\n:^0.13.1\nIf not, you will need to remove\nnode_modules\nand the lockfile and perform a fresh install to ensure they are bumped to the latest version.If you were previously using\n@vue/composition-api\n, update imports from it tovue\ninstead. Note that some APIs exported by the plugin, e.g.createApp\n, are not ported in 2.7.Update\neslint-plugin-vue\nto latest version (9+) if you run into unused variable lint errors when using<script setup>\n.The SFC compiler for 2.7 now uses PostCSS 8 (upgraded from 7). PostCSS 8 should be backwards compatible with most plugins, but the upgrade may cause issues if you were previously using a custom PostCSS plugin that can only work with PostCSS 7. In such cases, you will need to upgrade the relevant plugins to their PostCSS 8 compatible versions.\nVite\n2.7 support for Vite is provided via a new plugin: @vitejs/plugin-vue2. This new plugin requires Vue 2.7 or above and supersedes the existing vite-plugin-vue2.\nNote that the new plugin does not handle Vue-specific JSX / TSX transform, which is intentional. Vue 2 JSX / TSX transform for Vite is handled in a separate, dedicated plugin: @vitejs/plugin-vue2-jsx.\nVolar Compatibility\n2.7 ships improved type definitions so it is no longer necessary to install @vue/runtime-dom\njust for Volar template type inference support. All you need now is the following config in tsconfig.json\n:\n|\nDevtools Support\nVue Devtools 6.2.0 has added support for inspecting 2.7 Composition API state, but the extensions may still need a few days to go through review on respective publishing platforms.\nImplications of the 2.7 Release\nAs stated before, 2.7 is the final minor release of Vue 2.x. After this release, Vue 2 has entered LTS (long-term support) which lasts for 18 months from now, and will no longer receive new features.\nThis means Vue 2 will reach End of Life on December 31st, 2023. We believe this should provide plenty of time for most of the ecosystem to migrate over to Vue 3. However, we also understand that there could be teams or projects that cannot upgrade by this timeline while still need to fullfil security and compliance requirements. If your team expects to be using Vue 2 beyond end of 2023, make sure to plan head and understand your options: learn more about Vue 2 LTS and Extended Support.",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/migration-vue-2-7",
      "title": "Migration to Vue 2.7 — Vue.js"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nRender Functions & JSX\nBasics\nVue recommends using templates to build your HTML in the vast majority of cases. There are situations however, where you really need the full programmatic power of JavaScript. That’s where you can use the render function, a closer-to-the-compiler alternative to templates.\nLet’s dive into a simple example where a render\nfunction would be practical. Say you want to generate anchored headings:\n|\nFor the HTML above, you decide you want this component interface:\n|\nWhen you get started with a component that only generates a heading based on the level\nprop, you quickly arrive at this:\n|\n|\nThat template doesn’t feel great. It’s not only verbose, but we’re duplicating <slot></slot>\nfor every heading level and will have to do the same when we add the anchor element.\nWhile templates work great for most components, it’s clear that this isn’t one of them. So let’s try rewriting it with a render\nfunction:\n|\nMuch simpler! Sort of. The code is shorter, but also requires greater familiarity with Vue instance properties. In this case, you have to know that when you pass children without a v-slot\ndirective into a component, like the Hello world!\ninside of anchored-heading\n, those children are stored on the component instance at $slots.default\n. If you haven’t already, it’s recommended to read through the instance properties API before diving into render functions.\nNodes, Trees, and the Virtual DOM\nBefore we dive into render functions, it’s important to know a little about how browsers work. Take this HTML for example:\n|\nWhen a browser reads this code, it builds a tree of “DOM nodes” to help it keep track of everything, just as you might build a family tree to keep track of your extended family.\nThe tree of DOM nodes for the HTML above looks like this:\nEvery element is a node. Every piece of text is a node. Even comments are nodes! A node is just a piece of the page. And as in a family tree, each node can have children (i.e. each piece can contain other pieces).\nUpdating all these nodes efficiently can be difficult, but thankfully, you never have to do it manually. Instead, you tell Vue what HTML you want on the page, in a template:\n|\nOr a render function:\n|\nAnd in both cases, Vue automatically keeps the page updated, even when blogTitle\nchanges.\nThe Virtual DOM\nVue accomplishes this by building a virtual DOM to keep track of the changes it needs to make to the real DOM. Taking a closer look at this line:\n|\nWhat is createElement\nactually returning? It’s not exactly a real DOM element. It could perhaps more accurately be named createNodeDescription\n, as it contains information describing to Vue what kind of node it should render on the page, including descriptions of any child nodes. We call this node description a “virtual node”, usually abbreviated to VNode. “Virtual DOM” is what we call the entire tree of VNodes, built by a tree of Vue components.\ncreateElement\nArguments\nThe next thing you’ll have to become familiar with is how to use template features in the createElement\nfunction. Here are the arguments that createElement\naccepts:\n|\nThe Data Object In-Depth\nOne thing to note: similar to how v-bind:class\nand v-bind:style\nhave special treatment in templates, they have their own top-level fields in VNode data objects. This object also allows you to bind normal HTML attributes as well as DOM properties such as innerHTML\n(this would replace the v-html\ndirective):\n|\nComplete Example\nWith this knowledge, we can now finish the component we started:\n|\nConstraints\nVNodes Must Be Unique\nAll VNodes in the component tree must be unique. That means the following render function is invalid:\n|\nIf you really want to duplicate the same element/component many times, you can do so with a factory function. For example, the following render function is a perfectly valid way of rendering 20 identical paragraphs:\n|\nReplacing Template Features with Plain JavaScript\nv-if\nand v-for\nWherever something can be easily accomplished in plain JavaScript, Vue render functions do not provide a proprietary alternative. For example, in a template using v-if\nand v-for\n:\n|\nThis could be rewritten with JavaScript’s if\n/else\nand map\nin a render function:\n|\nv-model\nThere is no direct v-model\ncounterpart in render functions - you will have to implement the logic yourself:\n|\nThis is the cost of going lower-level, but it also gives you much more control over the interaction details compared to v-model\n.\nEvent & Key Modifiers\nFor the .passive\n, .capture\nand .once\nevent modifiers, Vue offers prefixes that can be used with on\n:\nModifier(s) | Prefix |\n---|---|\n.passive |\n& |\n.capture |\n! |\n.once |\n~ |\n.capture.once or.once.capture |\n~! |\nFor example:\n|\nFor all other event and key modifiers, no proprietary prefix is necessary, because you can use event methods in the handler:\nModifier(s) | Equivalent in Handler |\n---|---|\n.stop |\nevent.stopPropagation() |\n.prevent |\nevent.preventDefault() |\n.self |\nif (event.target !== event.currentTarget) return |\nKeys:.enter , .13 |\nif (event.keyCode !== 13) return (change 13 to another key code for other key modifiers) |\nModifiers Keys:.ctrl , .alt , .shift , .meta |\nif (!event.ctrlKey) return (change ctrlKey to altKey , shiftKey , or metaKey , respectively) |\nHere’s an example with all of these modifiers used together:\n|\nSlots\nYou can access static slot contents as Arrays of VNodes from this.$slots\n:\n|\nAnd access scoped slots as functions that return VNodes from this.$scopedSlots\n:\n|\nTo pass scoped slots to a child component using render functions, use the scopedSlots\nfield in VNode data:\n|\nJSX\nIf you’re writing a lot of render\nfunctions, it might feel painful to write something like this:\n|\nEspecially when the template version is so simple in comparison:\n|\nThat’s why there’s a Babel plugin to use JSX with Vue, getting us back to a syntax that’s closer to templates:\n|\nAliasing createElement\nto h\nis a common convention you’ll see in the Vue ecosystem and is actually required for JSX. Starting with version 3.4.0 of the Babel plugin for Vue, we automatically inject const h = this.$createElement\nin any method and getter (not functions or arrow functions), declared in ES2015 syntax that has JSX, so you can drop the (h)\nparameter. With prior versions of the plugin, your app would throw an error if h\nwas not available in the scope.\nFor more on how JSX maps to JavaScript, see the usage docs.\nFunctional Components\nThe anchored heading component we created earlier is relatively simple. It doesn’t manage any state, watch any state passed to it, and it has no lifecycle methods. Really, it’s only a function with some props.\nIn cases like this, we can mark components as functional\n, which means that they’re stateless (no reactive data) and instanceless (no this\ncontext). A functional component looks like this:\n|\nNote: in versions before 2.3.0, the\nprops\noption is required if you wish to accept props in a functional component. In 2.3.0+ you can omit theprops\noption and all attributes found on the component node will be implicitly extracted as props.The reference will be HTMLElement when used with functional components because they’re stateless and instanceless.\nIn 2.5.0+, if you are using single-file components, template-based functional components can be declared with:\n|\nEverything the component needs is passed through context\n, which is an object containing:\nprops\n: An object of the provided propschildren\n: An array of the VNode childrenslots\n: A function returning a slots objectscopedSlots\n: (2.6.0+) An object that exposes passed-in scoped slots. Also exposes normal slots as functions.data\n: The entire data object, passed to the component as the 2nd argument ofcreateElement\nparent\n: A reference to the parent componentlisteners\n: (2.3.0+) An object containing parent-registered event listeners. This is an alias todata.on\ninjections\n: (2.3.0+) if using theinject\noption, this will contain resolved injections.\nAfter adding functional: true\n, updating the render function of our anchored heading component would require adding the context\nargument, updating this.$slots.default\nto context.children\n, then updating this.level\nto context.props.level\n.\nSince functional components are just functions, they’re much cheaper to render.\nThey’re also very useful as wrapper components. For example, when you need to:\n- Programmatically choose one of several other components to delegate to\n- Manipulate children, props, or data before passing them on to a child component\nHere’s an example of a smart-list\ncomponent that delegates to more specific components, depending on the props passed to it:\n|\nPassing Attributes and Events to Child Elements/Components\nOn normal components, attributes not defined as props are automatically added to the root element of the component, replacing or intelligently merging with any existing attributes of the same name.\nFunctional components, however, require you to explicitly define this behavior:\n|\nBy passing context.data\nas the second argument to createElement\n, we are passing down any attributes or event listeners used on my-functional-button\n. It’s so transparent, in fact, that events don’t even require the .native\nmodifier.\nIf you are using template-based functional components, you will also have to manually add attributes and listeners. Since we have access to the individual context contents, we can use data.attrs\nto pass along any HTML attributes and listeners\n(the alias for data.on\n) to pass along any event listeners.\n|\nslots()\nvs children\nYou may wonder why we need both slots()\nand children\n. Wouldn’t slots().default\nbe the same as children\n? In some cases, yes - but what if you have a functional component with the following children?\n|\nFor this component, children\nwill give you both paragraphs, slots().default\nwill give you only the second, and slots().foo\nwill give you only the first. Having both children\nand slots()\ntherefore allows you to choose whether this component knows about a slot system or perhaps delegates that responsibility to another component by passing along children\n.\nTemplate Compilation\nYou may be interested to know that Vue’s templates actually compile to render functions. This is an implementation detail you usually don’t need to know about, but if you’d like to see how specific template features are compiled, you may find it interesting. Below is a little demo using Vue.compile\nto live-compile a template string:",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/render-function",
      "title": "Render Functions & JSX — Vue.js"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nComponents Basics\nBase Example\nHere’s an example of a Vue component:\n|\nComponents are reusable Vue instances with a name: in this case, <button-counter>\n. We can use this component as a custom element inside a root Vue instance created with new Vue\n:\n|\n|\nSince components are reusable Vue instances, they accept the same options as new Vue\n, such as data\n, computed\n, watch\n, methods\n, and lifecycle hooks. The only exceptions are a few root-specific options like el\n.\nReusing Components\nComponents can be reused as many times as you want:\n|\nNotice that when clicking on the buttons, each one maintains its own, separate count\n. That’s because each time you use a component, a new instance of it is created.\ndata\nMust Be a Function\nWhen we defined the <button-counter>\ncomponent, you may have noticed that data\nwasn’t directly provided an object, like this:\n|\nInstead, a component’s data\noption must be a function, so that each instance can maintain an independent copy of the returned data object:\n|\nIf Vue didn’t have this rule, clicking on one button would affect the data of all other instances, like below:\nOrganizing Components\nIt’s common for an app to be organized into a tree of nested components:\nFor example, you might have components for a header, sidebar, and content area, each typically containing other components for navigation links, blog posts, etc.\nTo use these components in templates, they must be registered so that Vue knows about them. There are two types of component registration: global and local. So far, we’ve only registered components globally, using Vue.component\n:\n|\nGlobally registered components can be used in the template of any root Vue instance (new Vue\n) created afterwards – and even inside all subcomponents of that Vue instance’s component tree.\nThat’s all you need to know about registration for now, but once you’ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Component Registration.\nPassing Data to Child Components with Props\nEarlier, we mentioned creating a component for blog posts. The problem is, that component won’t be useful unless you can pass data to it, such as the title and content of the specific post we want to display. That’s where props come in.\nProps are custom attributes you can register on a component. When a value is passed to a prop attribute, it becomes a property on that component instance. To pass a title to our blog post component, we can include it in the list of props this component accepts, using a props\noption:\n|\nA component can have as many props as you’d like and by default, any value can be passed to any prop. In the template above, you’ll see that we can access this value on the component instance, just like with data\n.\nOnce a prop is registered, you can pass data to it as a custom attribute, like this:\n|\nIn a typical app, however, you’ll likely have an array of posts in data\n:\n|\nThen want to render a component for each one:\n|\nAbove, you’ll see that we can use v-bind\nto dynamically pass props. This is especially useful when you don’t know the exact content you’re going to render ahead of time, like when fetching posts from an API.\nThat’s all you need to know about props for now, but once you’ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Props.\nA Single Root Element\nWhen building out a <blog-post>\ncomponent, your template will eventually contain more than just the title:\n|\nAt the very least, you’ll want to include the post’s content:\n|\nIf you try this in your template, however, Vue will show an error, explaining that every component must have a single root element. You can fix this error by wrapping the template in a parent element, such as:\n|\nAs our component grows, it’s likely we’ll not only need the title and content of a post, but also the published date, comments, and more. Defining a prop for each related piece of information could become very annoying:\n|\nSo this might be a good time to refactor the <blog-post>\ncomponent to accept a single post\nprop instead:\n|\n|\nThe above example and some future ones use JavaScript’s template literal to make multi-line templates more readable. These are not supported by Internet Explorer (IE), so if you must support IE and are not transpiling (e.g. with Babel or TypeScript), use newline escapes instead.\nNow, whenever a new property is added to post\nobjects, it will automatically be available inside <blog-post>\n.\nListening to Child Components Events\nAs we develop our <blog-post>\ncomponent, some features may require communicating back up to the parent. For example, we may decide to include an accessibility feature to enlarge the text of blog posts, while leaving the rest of the page its default size:\nIn the parent, we can support this feature by adding a postFontSize\ndata property:\n|\nWhich can be used in the template to control the font size of all blog posts:\n|\nNow let’s add a button to enlarge the text right before the content of every post:\n|\nThe problem is, this button doesn’t do anything:\n|\nWhen we click on the button, we need to communicate to the parent that it should enlarge the text of all posts. Fortunately, Vue instances provide a custom events system to solve this problem. The parent can choose to listen to any event on the child component instance with v-on\n, just as we would with a native DOM event:\n|\nThen the child component can emit an event on itself by calling the built-in $emit\nmethod, passing the name of the event:\n|\nThanks to the v-on:enlarge-text=\"postFontSize += 0.1\"\nlistener, the parent will receive the event and update postFontSize\nvalue.\nEmitting a Value With an Event\nIt’s sometimes useful to emit a specific value with an event. For example, we may want the <blog-post>\ncomponent to be in charge of how much to enlarge the text by. In those cases, we can use $emit\n‘s 2nd parameter to provide this value:\n|\nThen when we listen to the event in the parent, we can access the emitted event’s value with $event\n:\n|\nOr, if the event handler is a method:\n|\nThen the value will be passed as the first parameter of that method:\n|\nUsing v-model\non Components\nCustom events can also be used to create custom inputs that work with v-model\n. Remember that:\n|\ndoes the same thing as:\n|\nWhen used on a component, v-model\ninstead does this:\n|\nFor this to actually work though, the <input>\ninside the component must:\n- Bind the\nvalue\nattribute to avalue\nprop - On\ninput\n, emit its own custominput\nevent with the new value\nHere’s that in action:\n|\nNow v-model\nshould work perfectly with this component:\n|\nThat’s all you need to know about custom component events for now, but once you’ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Custom Events.\nContent Distribution with Slots\nJust like with HTML elements, it’s often useful to be able to pass content to a component, like this:\n|\nWhich might render something like:\nFortunately, this task is made very simple by Vue’s custom <slot>\nelement:\n|\nAs you’ll see above, we just add the slot where we want it to go – and that’s it. We’re done!\nThat’s all you need to know about slots for now, but once you’ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Slots.\nDynamic Components\nSometimes, it’s useful to dynamically switch between components, like in a tabbed interface:\nThe above is made possible by Vue’s <component>\nelement with the is\nspecial attribute:\n|\nIn the example above, currentTabComponent\ncan contain either:\n- the name of a registered component, or\n- a component’s options object\nSee this example to experiment with the full code, or this version for an example binding to a component’s options object, instead of its registered name.\nKeep in mind that this attribute can be used with regular HTML elements, however they will be treated as components, which means all attributes will be bound as DOM attributes. For some properties such as value\nto work as you would expect, you will need to bind them using the .prop\nmodifier.\nThat’s all you need to know about dynamic components for now, but once you’ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Dynamic & Async Components.\nDOM Template Parsing Caveats\nSome HTML elements, such as <ul>\n, <ol>\n, <table>\nand <select>\nhave restrictions on what elements can appear inside them, and some elements such as <li>\n, <tr>\n, and <option>\ncan only appear inside certain other elements.\nThis will lead to issues when using components with elements that have such restrictions. For example:\n|\nThe custom component <blog-post-row>\nwill be hoisted out as invalid content, causing errors in the eventual rendered output. Fortunately, the is\nspecial attribute offers a workaround:\n|\nIt should be noted that this limitation does not apply if you are using string templates from one of the following sources:\n- String templates (e.g.\ntemplate: '...'\n) - Single-file (\n.vue\n) components <script type=\"text/x-template\">\nThat’s all you need to know about DOM template parsing caveats for now – and actually, the end of Vue’s Essentials. Congratulations! There’s still more to learn, but first, we recommend taking a break to play with Vue yourself and build something fun.\nOnce you feel comfortable with the knowledge you’ve just digested, we recommend coming back to read the full guide on Dynamic & Async Components, as well as the other pages in the Components In-Depth section of the sidebar.",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/components",
      "title": "Components Basics — Vue.js"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nServer-Side Rendering\nThe Complete SSR Guide\nWe have created a standalone guide for creating server-rendered Vue applications. This is a very in-depth guide for those who are already familiar with client-side Vue development, server-side Node.js development and webpack. Check it out at v2.ssr.vuejs.org.\nNuxt.js\nProperly configuring all the discussed aspects of a production-ready server-rendered app can be a daunting task. Luckily, there is an excellent community project that aims to make all of this easier: Nuxt.js. Nuxt.js is a higher-level framework built on top of the Vue ecosystem which provides an extremely streamlined development experience for writing universal Vue applications. Better yet, you can even use it as a static site generator (with pages authored as single-file Vue components)! We highly recommend giving it a try.\nQuasar Framework SSR + PWA\nQuasar Framework will generate an SSR app (with optional PWA handoff) that leverages its best-in-class build system, sensible configuration and developer extensibility to make designing and building your idea a breeze. With over one hundred specific “Material Design 2.0”-compliant components, you can decide which ones to execute on the server, which are available in the browser - and even manage the <meta>\ntags of your site. Quasar is a node.js and webpack based development environment that supercharges and streamlines rapid development of SPA, PWA, SSR, Electron, Capacitor and Cordova apps - all from one codebase.",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/ssr",
      "title": "Server-Side Rendering — Vue.js"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nState Management\nOfficial Flux-Like Implementation\nLarge applications can often grow in complexity, due to multiple pieces of state scattered across many components and the interactions between them. To solve this problem, Vue offers vuex: our own Elm-inspired state management library. It even integrates into vue-devtools, providing zero-setup access to time travel debugging.\nInformation for React Developers\nIf you’re coming from React, you may be wondering how vuex compares to redux, the most popular Flux implementation in that ecosystem. Redux is actually view-layer agnostic, so it can easily be used with Vue via simple bindings. Vuex is different in that it knows it’s in a Vue app. This allows it to better integrate with Vue, offering a more intuitive API and improved development experience.\nSimple State Management from Scratch\nIt is often overlooked that the source of truth in Vue applications is the raw data\nobject - a Vue instance only proxies access to it. Therefore, if you have a piece of state that should be shared by multiple instances, you can share it by identity:\n|\nNow whenever sourceOfTruth\nis mutated, both vmA\nand vmB\nwill update their views automatically. Subcomponents within each of these instances would also have access via this.$root.$data\n. We have a single source of truth now, but debugging would be a nightmare. Any piece of data could be changed by any part of our app at any time, without leaving a trace.\nTo help solve this problem, we can adopt a store pattern:\n|\nNotice all actions that mutate the store’s state are put inside the store itself. This type of centralized state management makes it easier to understand what type of mutations could happen and how they are triggered. Now when something goes wrong, we’ll also have a log of what happened leading up to the bug.\nIn addition, each instance/component can still own and manage its own private state:\n|\nIt’s important to note that you should never replace the original state object in your actions - the components and the store need to share reference to the same object in order for mutations to be observed.\nAs we continue developing the convention where components are never allowed to directly mutate state that belongs to a store, but should instead dispatch events that notify the store to perform actions, we eventually arrive at the Flux architecture. The benefit of this convention is we can record all state mutations happening to the store and implement advanced debugging helpers such as mutation logs, snapshots, and history re-rolls / time travel.\nThis brings us full circle back to vuex, so if you’ve read this far it’s probably time to try it out!",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/state-management",
      "title": "State Management — Vue.js"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nComputed Properties and Watchers\nComputed Properties\nIn-template expressions are very convenient, but they are meant for simple operations. Putting too much logic in your templates can make them bloated and hard to maintain. For example:\n|\nAt this point, the template is no longer simple and declarative. You have to look at it for a second before realizing that it displays message\nin reverse. The problem is made worse when you want to include the reversed message in your template more than once.\nThat’s why for any complex logic, you should use a computed property.\nBasic Example\n|\n|\nResult:\nOriginal message: \"{{ message }}\"\nComputed reversed message: \"{{ reversedMessage }}\"\nHere we have declared a computed property reversedMessage\n. The function we provided will be used as the getter function for the property vm.reversedMessage\n:\n|\nYou can open the console and play with the example vm yourself. The value of vm.reversedMessage\nis always dependent on the value of vm.message\n.\nYou can data-bind to computed properties in templates just like a normal property. Vue is aware that vm.reversedMessage\ndepends on vm.message\n, so it will update any bindings that depend on vm.reversedMessage\nwhen vm.message\nchanges. And the best part is that we’ve created this dependency relationship declaratively: the computed getter function has no side effects, which makes it easier to test and understand.\nComputed Caching vs Methods\nYou may have noticed we can achieve the same result by invoking a method in the expression:\n|\n|\nInstead of a computed property, we can define the same function as a method. For the end result, the two approaches are indeed exactly the same. However, the difference is that computed properties are cached based on their reactive dependencies. A computed property will only re-evaluate when some of its reactive dependencies have changed. This means as long as message\nhas not changed, multiple access to the reversedMessage\ncomputed property will immediately return the previously computed result without having to run the function again.\nThis also means the following computed property will never update, because Date.now()\nis not a reactive dependency:\n|\nIn comparison, a method invocation will always run the function whenever a re-render happens.\nWhy do we need caching? Imagine we have an expensive computed property A, which requires looping through a huge Array and doing a lot of computations. Then we may have other computed properties that in turn depend on A. Without caching, we would be executing A’s getter many more times than necessary! In cases where you do not want caching, use a method instead.\nComputed vs Watched Property\nVue does provide a more generic way to observe and react to data changes on a Vue instance: watch properties. When you have some data that needs to change based on some other data, it is tempting to overuse watch\n- especially if you are coming from an AngularJS background. However, it is often a better idea to use a computed property rather than an imperative watch\ncallback. Consider this example:\n|\n|\nThe above code is imperative and repetitive. Compare it with a computed property version:\n|\nMuch better, isn’t it?\nComputed Setter\nComputed properties are by default getter-only, but you can also provide a setter when you need it:\n|\nNow when you run vm.fullName = 'John Doe'\n, the setter will be invoked and vm.firstName\nand vm.lastName\nwill be updated accordingly.\nWatchers\nWhile computed properties are more appropriate in most cases, there are times when a custom watcher is necessary. That’s why Vue provides a more generic way to react to data changes through the watch\noption. This is most useful when you want to perform asynchronous or expensive operations in response to changing data.\nFor example:\n|\n|\nResult:\nAsk a yes/no question:\n{{ answer }}\nIn this case, using the watch\noption allows us to perform an asynchronous operation (accessing an API), limit how often we perform that operation, and set intermediary states until we get a final answer. None of that would be possible with a computed property.\nIn addition to the watch\noption, you can also use the imperative vm.$watch API.",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/computed",
      "title": "Computed Properties and Watchers — Vue.js"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nClass and Style Bindings\nA common need for data binding is manipulating an element’s class list and its inline styles. Since they are both attributes, we can use v-bind\nto handle them: we only need to calculate a final string with our expressions. However, meddling with string concatenation is annoying and error-prone. For this reason, Vue provides special enhancements when v-bind\nis used with class\nand style\n. In addition to strings, the expressions can also evaluate to objects or arrays.\nBinding HTML Classes\nObject Syntax\nWe can pass an object to v-bind:class\nto dynamically toggle classes:\n|\nThe above syntax means the presence of the active\nclass will be determined by the truthiness of the data property isActive\n.\nYou can have multiple classes toggled by having more fields in the object. In addition, the v-bind:class\ndirective can also co-exist with the plain class\nattribute. So given the following template:\n|\nAnd the following data:\n|\nIt will render:\n|\nWhen isActive\nor hasError\nchanges, the class list will be updated accordingly. For example, if hasError\nbecomes true\n, the class list will become \"static active text-danger\"\n.\nThe bound object doesn’t have to be inline:\n|\n|\nThis will render the same result. We can also bind to a computed property that returns an object. This is a common and powerful pattern:\n|\n|\nArray Syntax\nWe can pass an array to v-bind:class\nto apply a list of classes:\n|\n|\nWhich will render:\n|\nIf you would like to also toggle a class in the list conditionally, you can do it with a ternary expression:\n|\nThis will always apply errorClass\n, but will only apply activeClass\nwhen isActive\nis truthy.\nHowever, this can be a bit verbose if you have multiple conditional classes. That’s why it’s also possible to use the object syntax inside array syntax:\n|\nWith Components\nThis section assumes knowledge of Vue Components. Feel free to skip it and come back later.\nWhen you use the class\nattribute on a custom component, those classes will be added to the component’s root element. Existing classes on this element will not be overwritten.\nFor example, if you declare this component:\n|\nThen add some classes when using it:\n|\nThe rendered HTML will be:\n|\nThe same is true for class bindings:\n|\nWhen isActive\nis truthy, the rendered HTML will be:\n|\nBinding Inline Styles\nObject Syntax\nThe object syntax for v-bind:style\nis pretty straightforward - it looks almost like CSS, except it’s a JavaScript object. You can use either camelCase or kebab-case (use quotes with kebab-case) for the CSS property names:\n|\n|\nIt is often a good idea to bind to a style object directly so that the template is cleaner:\n|\n|\nAgain, the object syntax is often used in conjunction with computed properties that return objects.\nArray Syntax\nThe array syntax for v-bind:style\nallows you to apply multiple style objects to the same element:\n|\nAuto-prefixing\nWhen you use a CSS property that requires vendor prefixes in v-bind:style\n, for example transform\n, Vue will automatically detect and add appropriate prefixes to the applied styles.\nMultiple Values\n2.3.0+\nStarting in 2.3.0+ you can provide an array of multiple (prefixed) values to a style property, for example:\n|\nThis will only render the last value in the array which the browser supports. In this example, it will render display: flex\nfor browsers that support the unprefixed version of flexbox.",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/class-and-style",
      "title": "Class and Style Bindings — Vue.js"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nSingle File Components\nIntroduction\nIn many Vue projects, global components will be defined using Vue.component\n, followed by new Vue({ el: '#container' })\nto target a container element in the body of every page.\nThis can work very well for small to medium-sized projects, where JavaScript is only used to enhance certain views. In more complex projects however, or when your frontend is entirely driven by JavaScript, these disadvantages become apparent:\n- Global definitions force unique names for every component\n- String templates lack syntax highlighting and require ugly slashes for multiline HTML\n- No CSS support means that while HTML and JavaScript are modularized into components, CSS is conspicuously left out\n- No build step restricts us to HTML and ES5 JavaScript, rather than preprocessors like Pug (formerly Jade) and Babel\nAll of these are solved by single-file components with a .vue\nextension, made possible with build tools such as Webpack or Browserify.\nHere’s an example of a file we’ll call Hello.vue\n:\nNow we get:\nAs promised, we can also use preprocessors such as Pug, Babel (with ES2015 modules), and Stylus for cleaner and more feature-rich components.\nThese specific languages are only examples. You could as easily use Bublé, TypeScript, SCSS, PostCSS - or whatever other preprocessors that help you be productive. If using Webpack with vue-loader\n, it also has first-class support for CSS Modules.\nWhat About Separation of Concerns?\nOne important thing to note is that separation of concerns is not equal to separation of file types. In modern UI development, we have found that instead of dividing the codebase into three huge layers that interweave with one another, it makes much more sense to divide them into loosely-coupled components and compose them. Inside a component, its template, logic and styles are inherently coupled, and collocating them actually makes the component more cohesive and maintainable.\nEven if you don’t like the idea of Single-File Components, you can still leverage its hot-reloading and pre-compilation features by separating your JavaScript and CSS into separate files:\n|\nGetting Started\nExample Sandbox\nIf you want to dive right in and start playing with single-file components, check out this simple todo app on CodeSandbox.\nFor Users New to Module Build Systems in JavaScript\nWith .vue\ncomponents, we’re entering the realm of advanced JavaScript applications. That means learning to use a few additional tools if you haven’t already:\nNode Package Manager (NPM): Read the Getting Started guide section about how to get packages from the registry.\nModern JavaScript with ES2015/16: Read through Babel’s Learn ES2015 guide. You don’t have to memorize every feature right now, but keep this page as a reference you can come back to.\nAfter you’ve taken a day to dive into these resources, we recommend checking out Vue CLI 3. Follow the instructions and you should have a Vue project with .vue\ncomponents, ES2015, Webpack and hot-reloading in no time!\nFor Advanced Users\nThe CLI takes care of most of the tooling configurations for you, but also allows fine-grained customization through its own config options.\nIn case you prefer setting up your own build setup from scratch, you will need to manually configure webpack with vue-loader. To learn more about webpack itself, check out their official docs and Webpack Academy.",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/single-file-components",
      "title": "Single File Components — Vue.js"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nState Transitions\nVue’s transition system offers many simple ways to animate entering, leaving, and lists, but what about animating your data itself? For example:\n- numbers and calculations\n- colors displayed\n- the positions of SVG nodes\n- the sizes and other properties of elements\nAll of these are either already stored as raw numbers or can be converted into numbers. Once we do that, we can animate these state changes using 3rd-party libraries to tween state, in combination with Vue’s reactivity and component systems.\nAnimating State with Watchers\nWatchers allow us to animate changes of any numerical property into another property. That may sound complicated in the abstract, so let’s dive into an example using GreenSock:\n|\n|\n{{ animatedNumber }}\nWhen you update the number, the change is animated below the input. This makes for a nice demo, but what about something that isn’t directly stored as a number, like any valid CSS color for example? Here’s how we could accomplish this with Tween.js and Color.js:\n|\n|\n|\nPreview:\n{{ tweenedCSSColor }}\nDynamic State Transitions\nAs with Vue’s transition components, the data backing state transitions can be updated in real time, which is especially useful for prototyping! Even using a simple SVG polygon, you can achieve many effects that would be difficult to conceive of until you’ve played with the variables a little.\nSee this example for the complete code behind the above demo.\nOrganizing Transitions into Components\nManaging many state transitions can quickly increase the complexity of a Vue instance or component. Fortunately, many animations can be extracted out into dedicated child components. Let’s do this with the animated integer from our earlier example:\n|\n|\nWithin child components, we can use any combination of transition strategies that have been covered on this page, along with those offered by Vue’s built-in transition system. Together, there are very few limits to what can be accomplished.\nBringing Designs to Life\nTo animate, by one definition, means to bring to life. Unfortunately, when designers create icons, logos, and mascots, they’re usually delivered as images or static SVGs. So although GitHub’s octocat, Twitter’s bird, and many other logos resemble living creatures, they don’t really seem alive.\nVue can help. Since SVGs are just data, we only need examples of what these creatures look like when excited, thinking, or alarmed. Then Vue can help transition between these states, making your welcome pages, loading indicators, and notifications more emotionally compelling.\nSarah Drasner demonstrates this in the demo below, using a combination of timed and interactivity-driven state changes:\nSee the Pen Vue-controlled Wall-E by Sarah Drasner (@sdras) on CodePen.",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/transitioning-state",
      "title": "State Transitions — Vue.js"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nConditional Rendering\nv-if\nThe directive v-if\nis used to conditionally render a block. The block will only be rendered if the directive’s expression returns a truthy value.\n|\nIt is also possible to add an “else block” with v-else\n:\n|\nConditional Groups with v-if\non <template>\nBecause v-if\nis a directive, it has to be attached to a single element. But what if we want to toggle more than one element? In this case we can use v-if\non a <template>\nelement, which serves as an invisible wrapper. The final rendered result will not include the <template>\nelement.\n|\nv-else\nYou can use the v-else\ndirective to indicate an “else block” for v-if\n:\n|\nA v-else\nelement must immediately follow a v-if\nor a v-else-if\nelement - otherwise it will not be recognized.\nv-else-if\nNew in 2.1.0+\nThe v-else-if\n, as the name suggests, serves as an “else if block” for v-if\n. It can also be chained multiple times:\n|\nSimilar to v-else\n, a v-else-if\nelement must immediately follow a v-if\nor a v-else-if\nelement.\nControlling Reusable Elements with key\nVue tries to render elements as efficiently as possible, often re-using them instead of rendering from scratch. Beyond helping make Vue very fast, this can have some useful advantages. For example, if you allow users to toggle between multiple login types:\n|\nThen switching the loginType\nin the code above will not erase what the user has already entered. Since both templates use the same elements, the <input>\nis not replaced - just its placeholder\n.\nCheck it out for yourself by entering some text in the input, then pressing the toggle button:\nThis isn’t always desirable though, so Vue offers a way for you to say, “These two elements are completely separate - don’t re-use them.” Add a key\nattribute with unique values:\n|\nNow those inputs will be rendered from scratch each time you toggle. See for yourself:\nNote that the <label>\nelements are still efficiently re-used, because they don’t have key\nattributes.\nv-show\nAnother option for conditionally displaying an element is the v-show\ndirective. The usage is largely the same:\n|\nThe difference is that an element with v-show\nwill always be rendered and remain in the DOM; v-show\nonly toggles the display\nCSS property of the element.\nNote that v-show\ndoesn’t support the <template>\nelement, nor does it work with v-else\n.\nv-if\nvs v-show\nv-if\nis “real” conditional rendering because it ensures that event listeners and child components inside the conditional block are properly destroyed and re-created during toggles.\nv-if\nis also lazy: if the condition is false on initial render, it will not do anything - the conditional block won’t be rendered until the condition becomes true for the first time.\nIn comparison, v-show\nis much simpler - the element is always rendered regardless of initial condition, with CSS-based toggling.\nGenerally speaking, v-if\nhas higher toggle costs while v-show\nhas higher initial render costs. So prefer v-show\nif you need to toggle something very often, and prefer v-if\nif the condition is unlikely to change at runtime.\nv-if\nwith v-for\nUsing v-if\nand v-for\ntogether is not recommended. See the style guide for further information.\nWhen used together with v-if\n, v-for\nhas a higher priority than v-if\n. See the list rendering guide for details.",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/conditional",
      "title": "Conditional Rendering — Vue.js"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nReactivity in Depth\nNow it’s time to take a deep dive! One of Vue’s most distinct features is the unobtrusive reactivity system. Models are just plain JavaScript objects. When you modify them, the view updates. It makes state management simple and intuitive, but it’s also important to understand how it works to avoid some common gotchas. In this section, we are going to dig into some of the lower-level details of Vue’s reactivity system.\nHow Changes Are Tracked\nWhen you pass a plain JavaScript object to a Vue instance as its data\noption, Vue will walk through all of its properties and convert them to getter/setters using Object.defineProperty\n. This is an ES5-only and un-shimmable feature, which is why Vue doesn’t support IE8 and below.\nThe getter/setters are invisible to the user, but under the hood they enable Vue to perform dependency-tracking and change-notification when properties are accessed or modified. One caveat is that browser consoles format getter/setters differently when converted data objects are logged, so you may want to install vue-devtools for a more inspection-friendly interface.\nEvery component instance has a corresponding watcher instance, which records any properties “touched” during the component’s render as dependencies. Later on when a dependency’s setter is triggered, it notifies the watcher, which in turn causes the component to re-render.\nChange Detection Caveats\nDue to limitations in JavaScript, there are types of changes that Vue cannot detect. However, there are ways to circumvent them to preserve reactivity.\nFor Objects\nVue cannot detect property addition or deletion. Since Vue performs the getter/setter conversion process during instance initialization, a property must be present in the data\nobject in order for Vue to convert it and make it reactive. For example:\n|\nVue does not allow dynamically adding new root-level reactive properties to an already created instance. However, it’s possible to add reactive properties to a nested object using the Vue.set(object, propertyName, value)\nmethod:\n|\nYou can also use the vm.$set\ninstance method, which is an alias to the global Vue.set\n:\n|\nSometimes you may want to assign a number of properties to an existing object, for example using Object.assign()\nor _.extend()\n. However, new properties added to the object will not trigger changes. In such cases, create a fresh object with properties from both the original object and the mixin object:\n|\nFor Arrays\nVue cannot detect the following changes to an array:\n- When you directly set an item with the index, e.g.\nvm.items[indexOfItem] = newValue\n- When you modify the length of the array, e.g.\nvm.items.length = newLength\nFor example:\n|\nTo overcome caveat 1, both of the following will accomplish the same as vm.items[indexOfItem] = newValue\n, but will also trigger state updates in the reactivity system:\n|\n|\nYou can also use the vm.$set\ninstance method, which is an alias for the global Vue.set\n:\n|\nTo deal with caveat 2, you can use splice\n:\n|\nDeclaring Reactive Properties\nSince Vue doesn’t allow dynamically adding root-level reactive properties, you have to initialize Vue instances by declaring all root-level reactive data properties upfront, even with an empty value:\n|\nIf you don’t declare message\nin the data option, Vue will warn you that the render function is trying to access a property that doesn’t exist.\nThere are technical reasons behind this restriction - it eliminates a class of edge cases in the dependency tracking system, and also makes Vue instances play nicer with type checking systems. But there is also an important consideration in terms of code maintainability: the data\nobject is like the schema for your component’s state. Declaring all reactive properties upfront makes the component code easier to understand when revisited later or read by another developer.\nAsync Update Queue\nIn case you haven’t noticed yet, Vue performs DOM updates asynchronously. Whenever a data change is observed, it will open a queue and buffer all the data changes that happen in the same event loop. If the same watcher is triggered multiple times, it will be pushed into the queue only once. This buffered de-duplication is important in avoiding unnecessary calculations and DOM manipulations. Then, in the next event loop “tick”, Vue flushes the queue and performs the actual (already de-duped) work. Internally Vue tries native Promise.then\n, MutationObserver\n, and setImmediate\nfor the asynchronous queuing and falls back to setTimeout(fn, 0)\n.\nFor example, when you set vm.someData = 'new value'\n, the component will not re-render immediately. It will update in the next “tick”, when the queue is flushed. Most of the time we don’t need to care about this, but it can be tricky when you want to do something that depends on the post-update DOM state. Although Vue.js generally encourages developers to think in a “data-driven” fashion and avoid touching the DOM directly, sometimes it might be necessary to get your hands dirty. In order to wait until Vue.js has finished updating the DOM after a data change, you can use Vue.nextTick(callback)\nimmediately after the data is changed. The callback will be called after the DOM has been updated. For example:\n|\n|\nThere is also the vm.$nextTick()\ninstance method, which is especially handy inside components, because it doesn’t need global Vue\nand its callback’s this\ncontext will be automatically bound to the current Vue instance:\n|\nSince $nextTick()\nreturns a promise, you can achieve the same as the above using the new ES2017 async/await syntax:\n|",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/reactivity",
      "title": "Reactivity in Depth — Vue.js"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nTesting\nIntroduction\nWhen it comes to building reliable applications, tests can play a critical role in an individual or team’s ability to build new features, refactor code, fix bugs, etc. While there are many schools of thought with testing, there are three categories often discussed in the context of web applications:\n- Unit Testing\n- Component Testing\n- End-To-End (E2E) Testing\nThis section aims to provide guidance to navigating the testing ecosystem and choosing the right tools for your Vue application or component library.\nUnit Testing\nIntroduction\nUnit tests allow you to test individual units of code in isolation. The purpose of unit testing is to provide developers with confidence in their code. By writing thorough, meaningful tests, you achieve the confidence that as new features are built or your code is refactored your application will remain functional and stable.\nUnit testing a Vue application does not significantly differ from testing other types of applications.\nChoosing Your Framework\nSince unit testing advice is often framework-agnostic, here are some basic guidelines to keep in mind when evaluating which unit testing tool is best for your application.\nFirst-class error reporting\nWhen tests fail, it is critical that your unit testing framework provides useful errors. This is the job of the assertion library. An assertion with high-quality error messages helps minimize the amount of time it takes to debug the problem. In addition to simply telling you what test is failing, assertion libraries provide context for why a test fails, e.g., what is expected vs what was received.\nSome unit testing frameworks, like Jest, include assertion libraries. Others, like Mocha, require you to install assertion libraries separately (usually Chai).\nActive community and team\nSince the majority of unit testing frameworks are open-source, having a community that is active can be critical to some teams that will be maintaining their tests for a long period of time and needs to ensure that a project will be actively maintained. In addition, having an active community has the benefit of providing more support whenever you run into issues.\nFrameworks\nWhile there are many tools in the ecosystem, here are some common unit testing tools that are being used in the Vue.js ecosystem.\nJest\nJest is a JavaScript test framework that is focused on simplicity. One of its unique features is the ability to take snapshots of tests in order to provide an alternative means of verifying units of your application.\nResources:\nMocha\nMocha is a JavaScript test framework that is focused on being flexible. Because of this flexibility, it allows you to choose different libraries to fulfill other common features such as spying (e.g., Sinon) and assertions (e.g., Chai). Another unique feature of Mocha is that it can also execute tests in the browser in addition to Node.js.\nResources:\nComponent Testing\nIntroduction\nTo test most Vue components, they must be mounted to the DOM (either virtual or real) in order to fully assert that they are working. This is another framework-agnostic concept. As a result, component testing frameworks were created to give users the ability to do this reliably while also providing Vue-specific conveniences such as integrations for Vuex, Vue Router, and other Vue plugins.\nChoosing Your Framework\nThe following section provides guidelines on things to keep in mind when evaluating which component testing framework is best for your application.\nOptimal compatibility with the Vue ecosystem\nIt should be no surprise that one of the first criteria is that a component testing library should have is being as compatible with the Vue ecosystem as possible. While this may seem comprehensive, some key integration areas to keep in mind include single file components (SFCs), Vuex, Vue Router, and any other Vue specific plugins that your application relies on.\nFirst-class error reporting\nWhen tests fail, it is critical that your component testing framework provides useful error logs that help to minimize the amount of time it takes to debug the problem. In addition to simply telling you what test fails, they should also provide context for why a test fails, e.g., what is expected vs what was received.\nRecommendations\nVue Testing Library (@testing-library/vue)\nVue Testing Library is a set of tools focused on testing components without relying on implementation details. Built with accessibility in mind, its approach also makes refactoring a breeze.\nIts guiding principle is that the more tests resemble the way software is used, the more confidence they can provide.\nResources:\nVue Test Utils\nVue Test Utils is the official low-level component testing library that was written to provide users access to Vue specific APIs. If you are new to testing Vue applications, we would recommend using Vue Testing Library, which is an abstraction over Vue Test Utils.\nResources\n- Official Vue Test Utils Documentation\n- Vue Testing Handbook by Lachlan Miller\n- Cookbook: Unit Testing Vue Components\nEnd-to-End (E2E) Testing\nIntroduction\nWhile unit tests provide developers with some degree of confidence, unit and component tests are limited in their abilities to provide holistic coverage of an application when deployed to production. As a result, end-to-end (E2E) tests provide coverage on what is arguably the most important aspect of an application: what happens when users actually use your applications.\nIn other words, E2E tests validate all of the layers in your application. This not only includes your frontend code, but all associated backend services and infrastructure that are more representative of the environment that your users will be in. By testing how user actions impact your application, E2E tests are often the key to higher confidence in whether an application is functioning properly or not.\nChoosing Your Framework\nWhile end-to-end (E2E) testing on the web has gained a negative reputation for unreliable (flaky) tests and slowing down development processes, modern E2E tools have made strides forward to create more reliable, interactive, and useful tests. When choosing an E2E testing framework, the following sections provide some guidance on things to keep in mind when choosing a testing framework for your application.\nCross-browser testing\nOne of the primary benefits that end-to-end (E2E) testing is known for is its ability to test your application across multiple browsers. While it may seem desirable to have 100% cross-browser coverage, it is important to note that cross browser testing has diminishing returns on a team’s resources due the additional time and machine power required to run them consistently. As a result, it is important to be mindful of this trade-off when choosing the amount of cross-browser testing your application needs.\nA recent development in E2E for catching browser-specific issues is using application monitoring and error reporting tools (e.g., Sentry, LogRocket, etc.) for browsers that are not as commonly used (e.g., < IE11, older Safari versions, etc.).\nFaster feedback loops\nOne of the primary problems with end-to-end (E2E) tests and development is that running the entire suite takes a long time. Typically, this is only done in continuous integration and deployment (CI/CD) pipelines. Modern E2E testing frameworks have helped to solve this by adding features like parallelization, which allows for CI/CD pipelines to often run magnitudes faster than before. In addition, when developing locally, the ability to selectively run a single test for the page you are working on while also providing hot reloading of tests can help to boost a developer’s workflow and productivity.\nFirst class debugging experience\nWhile developers have traditionally relied on scanning logs in a terminal window to help determine what went wrong in a test, modern end-to-end (E2E) test frameworks allow developers to leverage tools that they are already familiar with, e.g. browser developer tools.\nVisibility in headless mode\nWhen end-to-end (E2E) tests are run in continuous integration / deployment pipelines, they are often run in headless browsers (i.e., no visible browser is opened for the user to watch). As a result, when errors occur, a critical feature that modern E2E testing frameworks provide 1st class support for is the ability to see snapshots and/or videos of your applications during various testing stages in order to provide insight into why errors are happening. Historically, it was tedious to maintain these integrations.\nRecommendations\nWhile there are many tools in the ecosystem, here are some common end-to-end (E2E) testing frameworks that are being used in the Vue.js ecosystem.\nCypress.io\nCypress.io is a testing framework that aims to enhance developer productivity by enabling developers to reliably test their applications while providing a first class developer experience.\nResources\nNightwatch.js\nNightwatch.js is an end-to-end testing framework that can be used to test web applications and websites, as well as Node.js unit and integration testing.\nResources:\nPuppeteer\nPuppeteer is a Node library that provides a high-level API to control the browser and can pair with other test runners (e.g., Jest) to test your application.\nResources:\nTestCafe\nTestCafe is a Node.js based end-to-end framework that aims to provide easy setup so that developers can focus on creating tests that are easy to write and reliable.\nResources:",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/testing",
      "title": "Testing — Vue.js"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nMixins\nBasics\nMixins are a flexible way to distribute reusable functionalities for Vue components. A mixin object can contain any component options. When a component uses a mixin, all options in the mixin will be “mixed” into the component’s own options.\nExample:\n|\nOption Merging\nWhen a mixin and the component itself contain overlapping options, they will be “merged” using appropriate strategies.\nFor example, data objects undergo a recursive merge, with the component’s data taking priority in cases of conflicts.\n|\nHook functions with the same name are merged into an array so that all of them will be called. Mixin hooks will be called before the component’s own hooks.\n|\nOptions that expect object values, for example methods\n, components\nand directives\n, will be merged into the same object. The component’s options will take priority when there are conflicting keys in these objects:\n|\nNote that the same merge strategies are used in Vue.extend()\n.\nGlobal Mixin\nYou can also apply a mixin globally. Use with caution! Once you apply a mixin globally, it will affect every Vue instance created afterwards. When used properly, this can be used to inject processing logic for custom options:\n|\nUse global mixins sparsely and carefully, because it affects every single Vue instance created, including third party components. In most cases, you should only use it for custom option handling like demonstrated in the example above. It’s also a good idea to ship them as Plugins to avoid duplicate application.\nCustom Option Merge Strategies\nWhen custom options are merged, they use the default strategy which overwrites the existing value. If you want a custom option to be merged using custom logic, you need to attach a function to Vue.config.optionMergeStrategies\n:\n|\nFor most object-based options, you can use the same strategy used by methods\n:\n|\nA more advanced example can be found on Vuex‘s 1.x merging strategy:\n|",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/mixins",
      "title": "Mixins — Vue.js"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nSecurity\nReporting Vulnerabilities\nWhen a vulnerability is reported, it immediately becomes our top concern, with a full-time contributor dropping everything to work on it. To report a vulnerability, please email security@vuejs.org.\nWhile the discovery of new vulnerabilities is rare, we also recommend always using the latest versions of Vue and its official companion libraries to ensure your application remains as secure as possible.\nRule No.1: Never Use Non-trusted Templates\nThe most fundamental security rule when using Vue is never use non-trusted content as your component template. Doing so is equivalent to allowing arbitrary JavaScript execution in your application - and worse, could lead to server breaches if the code is executed during server-side rendering. An example of such usage:\n|\nVue templates are compiled into JavaScript, and expressions inside templates will be executed as part of the rendering process. Although the expressions are evaluated against a specific rendering context, due to the complexity of potential global execution environments, it is impractical for a framework like Vue to completely shield you from potential malicious code execution without incurring unrealistic performance overhead. The most straightforward way to avoid this category of problems altogether is to make sure the contents of your Vue templates are always trusted and entirely controlled by you.\nWhat Vue Does to Protect You\nHTML content\nWhether using templates or render functions, content is automatically escaped. That means in this template:\n|\nif userProvidedString\ncontained:\n|\nthen it would be escaped to the following HTML:\n|\nthus preventing the script injection. This escaping is done using native browser APIs, like textContent\n, so a vulnerability can only exist if the browser itself is vulnerable.\nAttribute bindings\nSimilarly, dynamic attribute bindings are also automatically escaped. That means in this template:\n|\nif userProvidedString\ncontained:\n|\nthen it would be escaped to the following HTML:\n|\nthus preventing the close of the title\nattribute to inject new, arbitrary HTML. This escaping is done using native browser APIs, like setAttribute\n, so a vulnerability can only exist if the browser itself is vulnerable.\nPotential Dangers\nIn any web application, allowing unsanitized, user-provided content to be executed as HTML, CSS, or JavaScript is potentially dangerous, so should be avoided wherever possible. There are times when some risk be acceptable though.\nFor example, services like CodePen and JSFiddle allow user-provided content to be executed, but it’s in a context where this is expected and sandboxed to some extent inside iframes. In the cases when an important feature inherently requires some level of vulnerability, it’s up to your team to weigh the importance of the feature against the worst-case scenarios the vulnerability enables.\nInjecting HTML\nAs you learned earlier, Vue automatically escapes HTML content, preventing you from accidentally injecting executable HTML into your application. However, in cases where you know the HTML is safe, you can explicitly render HTML content:\nUsing a template:\n<div v-html=\"userProvidedHtml\"></div>\nUsing a render function:\nh('div', {\ndomProps: {\ninnerHTML: this.userProvidedHtml\n}\n})Using a render function with JSX:\n<div domPropsInnerHTML={this.userProvidedHtml}></div>\nNote that user-provided HTML can never be considered 100% safe unless it’s in a sandboxed iframe or in a part of the app where only the user who wrote that HTML can ever be exposed to it. Additionally, allowing users to write their own Vue templates brings similar dangers.\nInjecting URLs\nIn a URL like this:\n|\nThere’s a potential security issue if the URL has not been “sanitized” to prevent JavaScript execution using javascript:\n. There are libraries such as sanitize-url to help with this, but note:\nIf you’re ever doing URL sanitization on the frontend, you already have a security issue. User-provided URLs should always be sanitized by your backend before even being saved to a database. Then the problem is avoided for every client connecting to your API, including native mobile apps. Also note that even with sanitized URLs, Vue cannot help you guarantee that they lead to safe destinations.\nInjecting Styles\nLooking at this example:\n|\nlet’s assume that sanitizedUrl\nhas been sanitized, so that it’s definitely a real URL and not JavaScript. With the userProvidedStyles\n, malicious users could still provide CSS to “click jack”, e.g. styling the link into a transparent box over the “Log in” button. Then if https://user-controlled-website.com/\nis built to resemble the login page of your application, they might have just captured a user’s real login information.\nYou may be able to imagine how allowing user-provided content for a <style>\nelement would create an even greater vulnerability, giving that user full control over how to style the entire page. That’s why Vue prevents rendering of style tags inside templates, such as:\n|\nTo keep your users fully safe from click jacking, we recommend only allowing full control over CSS inside a sandboxed iframe. Alternatively, when providing user control through a style binding, we recommend using its object syntax and only allowing users to provide values for specific properties it’s safe for them to control, like this:\n|\nInjecting JavaScript\nWe strongly discourage ever rendering a <script>\nelement with Vue, since templates and render functions should never have side effects. However, this isn’t the only way to include strings that would be evaluated as JavaScript at runtime.\nEvery HTML element has attributes with values accepting strings of JavaScript, such as onclick\n, onfocus\n, and onmouseenter\n. Binding user-provided JavaScript to any of these event attributes is a potential security risk, so should be avoided.\nNote that user-provided JavaScript can never be considered 100% safe unless it’s in a sandboxed iframe or in a part of the app where only the user who wrote that JavaScript can ever be exposed to it.\nSometimes we receive vulnerability reports on how it’s possible to do cross-site scripting (XSS) in Vue templates. In general, we do not consider such cases to be actual vulnerabilities, because there’s no practical way to protect developers from the two scenarios that would allow XSS:\nThe developer is explicitly asking Vue to render user-provided, unsanitized content as Vue templates. This is inherently unsafe and there’s no way for Vue to know the origin.\nThe developer is mounting Vue to an entire HTML page which happens to contain server-rendered and user-provided content. This is fundamentally the same problem as #1, but sometimes devs may do it without realizing. This can lead to possible vulnerabilities where the attacker provides HTML which is safe as plain HTML but unsafe as a Vue template. The best practice is to never mount Vue on nodes that may contain server-rendered and user-provided content.\nBest Practices\nThe general rule is that if you allow unsanitized, user-provided content to be executed (as either HTML, JavaScript, or even CSS), you might be opening yourself up to attacks. This advice actually holds true whether using Vue, another framework, or even no framework.\nBeyond the recommendations made above for Potential Dangers, we also recommend familiarizing yourself with these resources:\nThen use what you learn to also review the source code of your dependencies for potentially dangerous patterns, if any of them include 3rd-party components or otherwise influence what’s rendered to the DOM.\nBackend Coordination\nHTTP security vulnerabilities, such as cross-site request forgery (CSRF/XSRF) and cross-site script inclusion (XSSI), are primarily addressed on the backend, so aren’t a concern of Vue’s. However, it’s still a good idea to communicate with your backend team to learn how to best interact with their API, e.g. by submitting CSRF tokens with form submissions.\nServer-Side Rendering (SSR)\nThere are some additional security concerns when using SSR, so make sure to follow the best practices outlined throughout our SSR documentation to avoid vulnerabilities.",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/security",
      "title": "Security — Vue.js"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nForm Input Bindings\nBasic Usage\nYou can use the v-model\ndirective to create two-way data bindings on form input, textarea, and select elements. It automatically picks the correct way to update the element based on the input type. Although a bit magical, v-model\nis essentially syntax sugar for updating data on user input events, plus special care for some edge cases.\nv-model\nwill ignore the initial value\n, checked\n, or selected\nattributes found on any form elements. It will always treat the Vue instance data as the source of truth. You should declare the initial value on the JavaScript side, inside the data\noption of your component.\nv-model\ninternally uses different properties and emits different events for different input elements:\n- text and textarea elements use\nvalue\nproperty andinput\nevent; - checkboxes and radiobuttons use\nchecked\nproperty andchange\nevent; - select fields use\nvalue\nas a prop andchange\nas an event.\nFor languages that require an IME (Chinese, Japanese, Korean, etc.), you’ll notice that v-model\ndoesn’t get updated during IME composition. If you want to cater to these updates as well, use the input\nevent instead.\nText\n|\nMessage is: {{ message }}\nMultiline text\n|\n{{ message }}\nInterpolation on textareas (<textarea>{{text}}</textarea>\n) won't work. Use v-model\ninstead.\nCheckbox\nSingle checkbox, boolean value:\n|\nMultiple checkboxes, bound to the same Array:\n|\n|\nChecked names: {{ checkedNames }}\nRadio\n|\nPicked: {{ picked }}\nSelect\nSingle select:\n|\n|\nIf the initial value of your v-model\nexpression does not match any of the options, the <select>\nelement will render in an “unselected” state. On iOS, this will prevent the user from being able to select the first item, because iOS does not fire a change\nevent in this case. It is therefore recommended to provide a disabled\noption with an empty value, as demonstrated in the example above.\nMultiple select (bound to Array):\n|\nSelected: {{ selected }}\nDynamic options rendered with v-for\n:\n|\n|\nValue Bindings\nFor radio, checkbox and select options, the v-model\nbinding values are usually static strings (or booleans for checkboxes):\n|\nBut sometimes, we may want to bind the value to a dynamic property on the Vue instance. We can use v-bind\nto achieve that. In addition, using v-bind\nallows us to bind the input value to non-string values.\nCheckbox\n|\n|\nThe true-value\nand false-value\nattributes don’t affect the input’s value\nattribute, because browsers don’t include unchecked boxes in form submissions. To guarantee that one of two values is submitted in a form (i.e. “yes” or “no”), use radio inputs instead.\nRadio\n|\n|\nSelect Options\n|\n|\nModifiers\n.lazy\nBy default, v-model\nsyncs the input with the data after each input\nevent (with the exception of IME composition, as stated above). You can add the lazy\nmodifier to instead sync after change\nevents:\n|\n.number\nIf you want user input to be automatically typecast as a Number, you can add the number\nmodifier to your v-model\nmanaged inputs:\n|\nThis is often useful, because even with type=\"number\"\n, the value of HTML input elements always returns a string. If the value cannot be parsed with parseFloat()\n, then the original value is returned.\n.trim\nIf you want whitespace from user input to be trimmed automatically, you can add the trim\nmodifier to your v-model\n-managed inputs:\n|\nv-model\nwith Components\nIf you’re not yet familiar with Vue’s components, you can skip this for now.\nHTML’s built-in input types won’t always meet your needs. Fortunately, Vue components allow you to build reusable inputs with completely customized behavior. These inputs even work with v-model\n!\nTo learn more, read about custom inputs in the Components guide.",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/forms",
      "title": "Form Input Bindings — Vue.js"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nCustom Directives\nIntro\nIn addition to the default set of directives shipped in core (v-model\nand v-show\n), Vue also allows you to register your own custom directives. Note that in Vue 2.0, the primary form of code reuse and abstraction is components - however there may be cases where you need some low-level DOM access on plain elements, and this is where custom directives would still be useful. An example would be focusing on an input element, like this one:\nWhen the page loads, that element gains focus (note: autofocus\ndoesn’t work on mobile Safari). In fact, if you haven’t clicked on anything else since visiting this page, the input above should be focused now. Now let’s build the directive that accomplishes this:\n|\nIf you want to register a directive locally instead, components also accept a directives\noption:\n|\nThen in a template, you can use the new v-focus\nattribute on any element, like this:\n|\nHook Functions\nA directive definition object can provide several hook functions (all optional):\nbind\n: called only once, when the directive is first bound to the element. This is where you can do one-time setup work.inserted\n: called when the bound element has been inserted into its parent node (this only guarantees parent node presence, not necessarily in-document).update\n: called after the containing component’s VNode has updated, but possibly before its children have updated. The directive’s value may or may not have changed, but you can skip unnecessary updates by comparing the binding’s current and old values (see below on hook arguments).\nWe’ll cover VNodes in more detail later, when we discuss render functions.\ncomponentUpdated\n: called after the containing component’s VNode and the VNodes of its children have updated.unbind\n: called only once, when the directive is unbound from the element.\nWe’ll explore the arguments passed into these hooks (i.e. el\n, binding\n, vnode\n, and oldVnode\n) in the next section.\nDirective Hook Arguments\nDirective hooks are passed these arguments:\nel\n: The element the directive is bound to. This can be used to directly manipulate the DOM.binding\n: An object containing the following properties.name\n: The name of the directive, without thev-\nprefix.value\n: The value passed to the directive. For example inv-my-directive=\"1 + 1\"\n, the value would be2\n.oldValue\n: The previous value, only available inupdate\nandcomponentUpdated\n. It is available whether or not the value has changed.expression\n: The expression of the binding as a string. For example inv-my-directive=\"1 + 1\"\n, the expression would be\"1 + 1\"\n.arg\n: The argument passed to the directive, if any. For example inv-my-directive:foo\n, the arg would be\"foo\"\n.modifiers\n: An object containing modifiers, if any. For example inv-my-directive.foo.bar\n, the modifiers object would be{ foo: true, bar: true }\n.\nvnode\n: The virtual node produced by Vue’s compiler. See the VNode API for full details.oldVnode\n: The previous virtual node, only available in theupdate\nandcomponentUpdated\nhooks.\nApart from el\n, you should treat these arguments as read-only and never modify them. If you need to share information across hooks, it is recommended to do so through element’s dataset.\nAn example of a custom directive using some of these properties:\n|\n|\nDynamic Directive Arguments\nDirective arguments can be dynamic. For example, in v-mydirective:[argument]=\"value\"\n, the argument\ncan be updated based on data properties in our component instance! This makes our custom directives flexible for use throughout our application.\nLet’s say you want to make a custom directive that allows you to pin elements to your page using fixed positioning. We could create a custom directive where the value updates the vertical positioning in pixels, like this:\n|\n|\nThis would pin the element 200px from the top of the page. But what happens if we run into a scenario when we need to pin the element from the left, instead of the top? Here’s where a dynamic argument that can be updated per component instance comes in very handy:\n|\n|\nResult:\nOur custom directive is now flexible enough to support a few different use cases.\nFunction Shorthand\nIn many cases, you may want the same behavior on bind\nand update\n, but don’t care about the other hooks. For example:\n|\nObject Literals\nIf your directive needs multiple values, you can also pass in a JavaScript object literal. Remember, directives can take any valid JavaScript expression.\n|\n|",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/custom-directive",
      "title": "Custom Directives — Vue.js"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nEvent Handling\nListening to Events\nWe can use the v-on\ndirective to listen to DOM events and run some JavaScript when they’re triggered.\nFor example:\n|\n|\nResult:\nThe button above has been clicked {{ counter }} times.\nMethod Event Handlers\nThe logic for many event handlers will be more complex though, so keeping your JavaScript in the value of the v-on\nattribute isn’t feasible. That’s why v-on\ncan also accept the name of a method you’d like to call.\nFor example:\n|\n|\nResult:\nMethods in Inline Handlers\nInstead of binding directly to a method name, we can also use methods in an inline JavaScript statement:\n|\n|\nResult:\nSometimes we also need to access the original DOM event in an inline statement handler. You can pass it into a method using the special $event\nvariable:\n|\n|\nEvent Modifiers\nIt is a very common need to call event.preventDefault()\nor event.stopPropagation()\ninside event handlers. Although we can do this easily inside methods, it would be better if the methods can be purely about data logic rather than having to deal with DOM event details.\nTo address this problem, Vue provides event modifiers for v-on\n. Recall that modifiers are directive postfixes denoted by a dot.\n.stop\n.prevent\n.capture\n.self\n.once\n.passive\n|\nOrder matters when using modifiers because the relevant code is generated in the same order. Therefore using v-on:click.prevent.self\nwill prevent all clicks while v-on:click.self.prevent\nwill only prevent clicks on the element itself.\nNew in 2.1.4+\n|\nUnlike the other modifiers, which are exclusive to native DOM events, the .once\nmodifier can also be used on component events. If you haven’t read about components yet, don’t worry about this for now.\nNew in 2.3.0+\nVue also offers the .passive\nmodifier, corresponding to addEventListener\n‘s passive\noption.\n|\nThe .passive\nmodifier is especially useful for improving performance on mobile devices.\nDon’t use .passive\nand .prevent\ntogether, because .prevent\nwill be ignored and your browser will probably show you a warning. Remember, .passive\ncommunicates to the browser that you don’t want to prevent the event’s default behavior.\nKey Modifiers\nWhen listening for keyboard events, we often need to check for specific keys. Vue allows adding key modifiers for v-on\nwhen listening for key events:\n|\nYou can directly use any valid key names exposed via KeyboardEvent.key\nas modifiers by converting them to kebab-case.\n|\nIn the above example, the handler will only be called if $event.key\nis equal to 'PageDown'\n.\nKey Codes\nThe use of keyCode\nevents is deprecated and may not be supported in new browsers.\nUsing keyCode\nattributes is also permitted:\n|\nVue provides aliases for the most commonly used key codes when necessary for legacy browser support:\n.enter\n.tab\n.delete\n(captures both “Delete” and “Backspace” keys).esc\n.space\n.up\n.down\n.left\n.right\nA few keys (.esc\nand all arrow keys) have inconsistent key\nvalues in IE9, so these built-in aliases should be preferred if you need to support IE9.\nYou can also define custom key modifier aliases via the global config.keyCodes\nobject:\n|\nSystem Modifier Keys\nNew in 2.1.0+\nYou can use the following modifiers to trigger mouse or keyboard event listeners only when the corresponding modifier key is pressed:\n.ctrl\n.alt\n.shift\n.meta\nNote: On Macintosh keyboards, meta is the command key (⌘). On Windows keyboards, meta is the Windows key (⊞). On Sun Microsystems keyboards, meta is marked as a solid diamond (◆). On certain keyboards, specifically MIT and Lisp machine keyboards and successors, such as the Knight keyboard, space-cadet keyboard, meta is labeled “META”. On Symbolics keyboards, meta is labeled “META” or “Meta”.\nFor example:\n|\nNote that modifier keys are different from regular keys and when used with keyup\nevents, they have to be pressed when the event is emitted. In other words, keyup.ctrl\nwill only trigger if you release a key while holding down ctrl\n. It won’t trigger if you release the ctrl\nkey alone. If you do want such behaviour, use the keyCode\nfor ctrl\ninstead: keyup.17\n.\n.exact\nModifier\nNew in 2.5.0+\nThe .exact\nmodifier allows control of the exact combination of system modifiers needed to trigger an event.\n|\nMouse Button Modifiers\nNew in 2.2.0+\n.left\n.right\n.middle\nThese modifiers restrict the handler to events triggered by a specific mouse button.\nWhy Listeners in HTML?\nYou might be concerned that this whole event listening approach violates the good old rules about “separation of concerns”. Rest assured - since all Vue handler functions and expressions are strictly bound to the ViewModel that’s handling the current view, it won’t cause any maintenance difficulty. In fact, there are several benefits in using v-on\n:\nIt’s easier to locate the handler function implementations within your JS code by skimming the HTML template.\nSince you don’t have to manually attach event listeners in JS, your ViewModel code can be pure logic and DOM-free. This makes it easier to test.\nWhen a ViewModel is destroyed, all event listeners are automatically removed. You don’t need to worry about cleaning it up yourself.",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/events",
      "title": "Event Handling — Vue.js"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nList Rendering\nMapping an Array to Elements with v-for\nWe can use the v-for\ndirective to render a list of items based on an array. The v-for\ndirective requires a special syntax in the form of item in items\n, where items\nis the source data array and item\nis an alias for the array element being iterated on:\n|\n|\nResult:\n- {{item.message}}\nInside v-for\nblocks we have full access to parent scope properties. v-for\nalso supports an optional second argument for the index of the current item.\n|\n|\nResult:\n- {{ parentMessage }} - {{ index }} - {{ item.message }}\nYou can also use of\nas the delimiter instead of in\n, so that it is closer to JavaScript’s syntax for iterators:\n|\nv-for\nwith an Object\nYou can also use v-for\nto iterate through the properties of an object.\n|\n|\nResult:\n- {{ value }}\nYou can also provide a second argument for the property’s name (a.k.a. key):\n|\nAnd another for the index:\n|\nWhen iterating over an object, the order is based on the enumeration order of Object.keys()\n, which is not guaranteed to be consistent across JavaScript engine implementations.\nMaintaining State\nWhen Vue is updating a list of elements rendered with v-for\n, by default it uses an “in-place patch” strategy. If the order of the data items has changed, instead of moving the DOM elements to match the order of the items, Vue will patch each element in-place and make sure it reflects what should be rendered at that particular index. This is similar to the behavior of track-by=\"$index\"\nin Vue 1.x.\nThis default mode is efficient, but only suitable when your list render output does not rely on child component state or temporary DOM state (e.g. form input values).\nTo give Vue a hint so that it can track each node’s identity, and thus reuse and reorder existing elements, you need to provide a unique key\nattribute for each item:\n|\nIt is recommended to provide a key\nattribute with v-for\nwhenever possible, unless the iterated DOM content is simple, or you are intentionally relying on the default behavior for performance gains.\nSince it’s a generic mechanism for Vue to identify nodes, the key\nalso has other uses that are not specifically tied to v-for\n, as we will see later in the guide.\nDon’t use non-primitive values like objects and arrays as v-for\nkeys. Use string or numeric values instead.\nFor detailed usage of the key\nattribute, please see the key\nAPI documentation.\nArray Change Detection\nMutation Methods\nVue wraps an observed array’s mutation methods so they will also trigger view updates. The wrapped methods are:\npush()\npop()\nshift()\nunshift()\nsplice()\nsort()\nreverse()\nYou can open the console and play with the previous examples’ items\narray by calling their mutation methods. For example: example1.items.push({ message: 'Baz' })\n.\nReplacing an Array\nMutation methods, as the name suggests, mutate the original array they are called on. In comparison, there are also non-mutating methods, e.g. filter()\n, concat()\nand slice()\n, which do not mutate the original array but always return a new array. When working with non-mutating methods, you can replace the old array with the new one:\n|\nYou might think this will cause Vue to throw away the existing DOM and re-render the entire list - luckily, that is not the case. Vue implements some smart heuristics to maximize DOM element reuse, so replacing an array with another array containing overlapping objects is a very efficient operation.\nCaveats\nDue to limitations in JavaScript, there are types of changes that Vue cannot detect with arrays and objects. These are discussed in the reactivity section.\nDisplaying Filtered/Sorted Results\nSometimes we want to display a filtered or sorted version of an array without actually mutating or resetting the original data. In this case, you can create a computed property that returns the filtered or sorted array.\nFor example:\n|\n|\nIn situations where computed properties are not feasible (e.g. inside nested v-for\nloops), you can use a method:\n|\n|\nv-for\nwith a Range\nv-for\ncan also take an integer. In this case it will repeat the template that many times.\n|\nResult:\nv-for\non a <template>\nSimilar to template v-if\n, you can also use a <template>\ntag with v-for\nto render a block of multiple elements. For example:\n|\nv-for\nwith v-if\nNote that it’s not recommended to use v-if\nand v-for\ntogether. Refer to style guide for details.\nWhen they exist on the same node, v-for\nhas a higher priority than v-if\n. That means the v-if\nwill be run on each iteration of the loop separately. This can be useful when you want to render nodes for only some items, like below:\n|\nThe above only renders the todos that are not complete.\nIf instead, your intent is to conditionally skip execution of the loop, you can place the v-if\non a wrapper element (or <template>\n). For example:\n|\nv-for\nwith a Component\nThis section assumes knowledge of Components. Feel free to skip it and come back later.\nYou can directly use v-for\non a custom component, like any normal element:\n|\nIn 2.2.0+, when using\nv-for\nwith a component, akey\nis now required.\nHowever, this won’t automatically pass any data to the component, because components have isolated scopes of their own. In order to pass the iterated data into the component, we should also use props:\n|\nThe reason for not automatically injecting item\ninto the component is because that makes the component tightly coupled to how v-for\nworks. Being explicit about where its data comes from makes the component reusable in other situations.\nHere’s a complete example of a simple todo list:\n|\nNote the is=\"todo-item\"\nattribute. This is necessary in DOM templates, because only an <li>\nelement is valid inside a <ul>\n. It does the same thing as <todo-item>\n, but works around a potential browser parsing error. See DOM Template Parsing Caveats to learn more.\n|",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/list",
      "title": "List Rendering — Vue.js"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nComparison with Other Frameworks\nThis is definitely the most difficult page in the guide to write, but we do feel it’s important. Odds are, you’ve had problems you tried to solve and you’ve used another library to solve them. You’re here because you want to know if Vue can solve your specific problems better. That’s what we hope to answer for you.\nWe also try very hard to avoid bias. As the core team, we obviously like Vue a lot. There are some problems we think it solves better than anything else out there. If we didn’t believe that, we wouldn’t be working on it. We do want to be fair and accurate though. Where other libraries offer significant advantages, such as React’s vast ecosystem of alternative renderers or Knockout’s browser support back to IE6, we try to list these as well.\nWe’d also like your help keeping this document up-to-date because the JavaScript world moves fast! If you notice an inaccuracy or something that doesn’t seem quite right, please let us know by opening an issue.\nReact\nReact and Vue share many similarities. They both:\n- utilize a virtual DOM\n- provide reactive and composable view components\n- maintain focus in the core library, with concerns such as routing and global state management handled by companion libraries\nBeing so similar in scope, we’ve put more time into fine-tuning this comparison than any other. We want to ensure not only technical accuracy, but also balance. We point out where React outshines Vue, for example in the richness of their ecosystem and abundance of their custom renderers.\nWith that said, it’s inevitable that the comparison would appear biased towards Vue to some React users, as many of the subjects explored are to some extent subjective. We acknowledge the existence of varying technical taste, and this comparison primarily aims to outline the reasons why Vue could potentially be a better fit if your preferences happen to coincide with ours.\nSome of the sections below may also be slightly outdated due to recent updates in React 16+, and we are planning to work with the React community to revamp this section in the near future.\nRuntime Performance\nBoth React and Vue are exceptionally and similarly fast, so speed is unlikely to be a deciding factor in choosing between them. For specific metrics though, check out this 3rd party benchmark, which focuses on raw render/update performance with very simple component trees.\nOptimization Efforts\nIn React, when a component’s state changes, it triggers the re-render of the entire component sub-tree, starting at that component as root. To avoid unnecessary re-renders of child components, you need to either use PureComponent\nor implement shouldComponentUpdate\nwhenever you can. You may also need to use immutable data structures to make your state changes more optimization-friendly. However, in certain cases you may not be able to rely on such optimizations because PureComponent/shouldComponentUpdate\nassumes the entire sub tree’s render output is determined by the props of the current component. If that is not the case, then such optimizations may lead to inconsistent DOM state.\nIn Vue, a component’s dependencies are automatically tracked during its render, so the system knows precisely which components actually need to re-render when state changes. Each component can be considered to have shouldComponentUpdate\nautomatically implemented for you, without the nested component caveats.\nOverall this removes the need for a whole class of performance optimizations from the developer’s plate, and allows them to focus more on building the app itself as it scales.\nHTML & CSS\nIn React, everything is just JavaScript. Not only are HTML structures expressed via JSX, the recent trends also tend to put CSS management inside JavaScript as well. This approach has its own benefits, but also comes with various trade-offs that may not seem worthwhile for every developer.\nVue embraces classic web technologies and builds on top of them. To show you what that means, we’ll dive into some examples.\nJSX vs Templates\nIn React, all components express their UI within render functions using JSX, a declarative XML-like syntax that works within JavaScript.\nRender functions with JSX have a few advantages:\nYou can leverage the power of a full programming language (JavaScript) to build your view. This includes temporary variables, flow controls, and directly referencing JavaScript values in scope.\nThe tooling support (e.g. linting, type checking, editor autocompletion) for JSX is in some ways more advanced than what’s currently available for Vue templates.\nIn Vue, we also have render functions and even support JSX, because sometimes you do need that power. However, as the default experience we offer templates as a simpler alternative. Any valid HTML is also a valid Vue template, and this leads to a few advantages of its own:\nFor many developers who have been working with HTML, templates feel more natural to read and write. The preference itself can be somewhat subjective, but if it makes the developer more productive then the benefit is objective.\nHTML-based templates make it much easier to progressively migrate existing applications to take advantage of Vue’s reactivity features.\nIt also makes it much easier for designers and less experienced developers to parse and contribute to the codebase.\nYou can even use pre-processors such as Pug (formerly known as Jade) to author your Vue templates.\nSome argue that you’d need to learn an extra DSL (Domain-Specific Language) to be able to write templates - we believe this difference is superficial at best. First, JSX doesn’t mean the user doesn’t need to learn anything - it’s additional syntax on top of plain JavaScript, so it can be easy for someone familiar with JavaScript to learn, but saying it’s essentially free is misleading. Similarly, a template is just additional syntax on top of plain HTML and thus has very low learning cost for those who are already familiar with HTML. With the DSL we are also able to help the user get more done with less code (e.g. v-on\nmodifiers). The same task can involve a lot more code when using plain JSX or render functions.\nOn a higher level, we can divide components into two categories: presentational ones and logical ones. We recommend using templates for presentational components and render function / JSX for logical ones. The percentage of these components depends on the type of app you are building, but in general we find presentational ones to be much more common.\nComponent-Scoped CSS\nUnless you spread components out over multiple files (for example with CSS Modules), scoping CSS in React is often done via CSS-in-JS solutions (e.g. styled-components and emotion). This introduces a new component-oriented styling paradigm that is different from the normal CSS authoring process. Additionally, although there is support for extracting CSS into a single stylesheet at build time, it is still common that a runtime will need to be included in the bundle for styling to work properly. While you gain access to the dynamism of JavaScript while constructing your styles, the tradeoff is often increased bundle size and runtime cost.\nIf you are a fan of CSS-in-JS, many of the popular CSS-in-JS libraries support Vue (e.g. styled-components-vue and vue-emotion). The main difference between React and Vue here is that the default method of styling in Vue is through more familiar style\ntags in single-file components.\nSingle-file components give you full access to CSS in the same file as the rest of your component code.\n|\nThe optional scoped\nattribute automatically scopes this CSS to your component by adding a unique attribute (such as data-v-21e5b78\n) to elements and compiling .list-container:hover\nto something like .list-container[data-v-21e5b78]:hover\n.\nLastly, the styling in Vue’s single-file components is very flexible. Through vue-loader, you can use any preprocessor, post-processor, and even deep integration with CSS Modules – all within the <style>\nelement.\nScale\nScaling Up\nFor large applications, both Vue and React offer robust routing solutions. The React community has also been very innovative in terms of state management solutions (e.g. Flux/Redux). These state management patterns and even Redux itself can be easily integrated into Vue applications. In fact, Vue has even taken this model a step further with Vuex, an Elm-inspired state management solution that integrates deeply into Vue that we think offers a superior development experience.\nAnother important difference between these offerings is that Vue’s companion libraries for state management and routing (among other concerns) are all officially supported and kept up-to-date with the core library. React instead chooses to leave these concerns to the community, creating a more fragmented ecosystem. Being more popular though, React’s ecosystem is considerably richer than Vue’s.\nFinally, Vue offers a CLI project generator that makes it trivially easy to start a new project by featuring an interactive project scaffolding wizard. You can even use it for instantly prototyping a component. React is also making strides in this area with create-react-app, but it currently has a few limitations:\n- It does not allow any configuration during project generation, while Vue CLI runs on top of an upgradeable runtime dependency that can be extended via plugins.\n- It only offers a single template that assumes you’re building a single-page application, while Vue offers a wide variety of default options for various purposes and build systems.\n- It cannot generate projects from user-built presets, which can be especially useful for enterprise environments with pre-established conventions.\nIt’s important to note that many of these limitations are intentional design decisions made by the create-react-app team and they do have their advantages. For example, as long as your project’s needs are very simple and you never need to “eject” to customize your build process, you’ll be able to update it as a dependency. You can read more about the differing philosophy here.\nScaling Down\nReact is renowned for its steep learning curve. Before you can really get started, you need to know about JSX and probably ES2015+, since many examples use React’s class syntax. You also have to learn about build systems, because although you could technically use Babel Standalone to live-compile your code in the browser, it’s absolutely not suitable for production.\nWhile Vue scales up just as well as React, it also scales down just as well as jQuery. That’s right - to get started, all you have to do is drop a single script tag into the page:\n|\nThen you can start writing Vue code and even ship the minified version to production without feeling guilty or having to worry about performance problems.\nSince you don’t need to know about JSX, ES2015, or build systems to get started with Vue, it also typically takes developers less than a day reading the guide to learn enough to build non-trivial applications.\nNative Rendering\nReact Native enables you to write native-rendered apps for iOS and Android using the same React component model. This is great in that as a developer, you can apply your knowledge of a framework across multiple platforms. On this front, Vue has an official collaboration with Weex, a cross-platform UI framework created by Alibaba Group and being incubated by the Apache Software Foundation (ASF). Weex allows you to use the same Vue component syntax to author components that can not only be rendered in the browser, but also natively on iOS and Android!\nAt this moment, Weex is still in active development and is not as mature and battle-tested as React Native, but its development is driven by the production needs of the largest e-commerce business in the world, and the Vue team will also actively collaborate with the Weex team to ensure a smooth experience for Vue developers.\nAnother option is NativeScript-Vue, a NativeScript plugin for building truly native applications using Vue.js.\nWith MobX\nMobX has become quite popular in the React community and it actually uses a nearly identical reactivity system to Vue. To a limited extent, the React + MobX workflow can be thought of as a more verbose Vue, so if you’re using that combination and are enjoying it, jumping into Vue is probably the next logical step.\nPreact and Other React-Like Libraries\nReact-like libraries usually try to share as much of their API and ecosystem with React as is feasible. For that reason, the vast majority of comparisons above will also apply to them. The main difference will typically be a reduced ecosystem, often significantly, compared to React. Since these libraries cannot be 100% compatible with everything in the React ecosystem, some tooling and companion libraries may not be usable. Or, even if they appear to work, they could break at any time unless your specific React-like library is officially supported on par with React.\nAngularJS (Angular 1)\nSome of Vue’s syntax will look very similar to AngularJS (e.g. v-if\nvs ng-if\n). This is because there were a lot of things that AngularJS got right and these were an inspiration for Vue very early in its development. There are also many pains that come with AngularJS however, where Vue has attempted to offer a significant improvement.\nComplexity\nVue is much simpler than AngularJS, both in terms of API and design. Learning enough to build non-trivial applications typically takes less than a day, which is not true for AngularJS.\nFlexibility and Modularity\nAngularJS has strong opinions about how your applications should be structured, while Vue is a more flexible, modular solution. While this makes Vue more adaptable to a wide variety of projects, we also recognize that sometimes it’s useful to have some decisions made for you, so that you can just start coding.\nThat’s why we offer a full system for rapid Vue.js development. Vue CLI aims to be the standard tooling baseline for the Vue ecosystem. It ensures the various build tools work smoothly together with sensible defaults so you can focus on writing your app instead of spending hours wrangling with configurations. At the same time, it still offers the flexibility to tweak the configuration of each tool to specific needs.\nData binding\nAngularJS uses two-way binding between scopes, while Vue enforces a one-way data flow between components. This makes the flow of data easier to reason about in non-trivial applications.\nDirectives vs Components\nVue has a clearer separation between directives and components. Directives are meant to encapsulate DOM manipulations only, while components are self-contained units that have their own view and data logic. In AngularJS, directives do everything and components are just a specific kind of directive.\nRuntime Performance\nVue has better performance and is much, much easier to optimize because it doesn’t use dirty checking. AngularJS becomes slow when there are a lot of watchers, because every time anything in the scope changes, all these watchers need to be re-evaluated again. Also, the digest cycle may have to run multiple times to “stabilize” if some watcher triggers another update. AngularJS users often have to resort to esoteric techniques to get around the digest cycle, and in some situations, there’s no way to optimize a scope with many watchers.\nVue doesn’t suffer from this at all because it uses a transparent dependency-tracking observation system with async queueing - all changes trigger independently unless they have explicit dependency relationships.\nInterestingly, there are quite a few similarities in how Angular and Vue are addressing these AngularJS issues.\nAngular (Formerly known as Angular 2)\nWe have a separate section for the new Angular because it really is a completely different framework from AngularJS. For example, it features a first-class component system, many implementation details have been completely rewritten, and the API has also changed quite drastically.\nTypeScript\nAngular essentially requires using TypeScript, given that almost all its documentation and learning resources are TypeScript-based. TypeScript has its benefits - static type checking can be very useful for large-scale applications, and can be a big productivity boost for developers with backgrounds in Java and C#.\nHowever, not everyone wants to use TypeScript. In many smaller-scale use cases, introducing a type system may result in more overhead than productivity gain. In those cases you’d be better off going with Vue instead, since using Angular without TypeScript can be challenging.\nFinally, although not as deeply integrated with TypeScript as Angular is, Vue also offers official typings and official decorator for those who wish to use TypeScript with Vue. We are also actively collaborating with the TypeScript and VSCode teams at Microsoft to improve the TS/IDE experience for Vue + TS users.\nRuntime Performance\nBoth frameworks are exceptionally fast, with very similar metrics on benchmarks. You can browse specific metrics for a more granular comparison, but speed is unlikely to be a deciding factor.\nSize\nRecent versions of Angular, with AOT compilation and tree-shaking, have been able to get its size down considerably. However, a full-featured Vue 2 project with Vuex + Vue Router included (~30KB gzipped) is still significantly lighter than an out-of-the-box, AOT-compiled application generated by angular-cli\n(~65KB gzipped).\nFlexibility\nVue is much less opinionated than Angular, offering official support for a variety of build systems, with no restrictions on how you structure your application. Many developers enjoy this freedom, while some prefer having only one Right Way to build any application.\nLearning Curve\nTo get started with Vue, all you need is familiarity with HTML and ES5 JavaScript (i.e. plain JavaScript). With these basic skills, you can start building non-trivial applications within less than a day of reading the guide.\nAngular’s learning curve is much steeper. The API surface of the framework is huge and as a user you will need to familiarize yourself with a lot more concepts before getting productive. The complexity of Angular is largely due to its design goal of targeting only large, complex applications - but that does make the framework a lot more difficult for less-experienced developers to pick up.\nEmber\nEmber is a full-featured framework that is designed to be highly opinionated. It provides a lot of established conventions and once you are familiar enough with them, it can make you very productive. However, it also means the learning curve is high and flexibility suffers. It’s a trade-off when you try to pick between an opinionated framework and a library with a loosely coupled set of tools that work together. The latter gives you more freedom but also requires you to make more architectural decisions.\nThat said, it would probably make a better comparison between Vue core and Ember’s templating and object model layers:\nVue provides unobtrusive reactivity on plain JavaScript objects and fully automatic computed properties. In Ember, you need to wrap everything in Ember Objects and manually declare dependencies for computed properties.\nVue’s template syntax harnesses the full power of JavaScript expressions, while Handlebars’ expression and helper syntax is intentionally quite limited in comparison.\nPerformance-wise, Vue outperforms Ember by a fair margin, even after the latest Glimmer engine update in Ember 3.x. Vue automatically batches updates, while in Ember you need to manually manage run loops in performance-critical situations.\nKnockout\nKnockout was a pioneer in the MVVM and dependency tracking spaces and its reactivity system is very similar to Vue’s. Its browser support is also very impressive considering everything it does, with support back to IE6! Vue on the other hand only supports IE9+.\nOver time though, Knockout development has slowed and it’s begun to show its age a little. For example, its component system lacks a full set of lifecycle hooks and although it’s a very common use case, the interface for passing children to a component feels a little clunky compared to Vue’s.\nThere also seem to be philosophical differences in the API design which if you’re curious, can be demonstrated by how each handles the creation of a simple todo list. It’s definitely somewhat subjective, but many consider Vue’s API to be less complex and better structured.\nPolymer\nPolymer is another Google-sponsored project and in fact was a source of inspiration for Vue as well. Vue’s components can be loosely compared to Polymer’s custom elements and both provide a very similar development style. The biggest difference is that Polymer is built upon the latest Web Components features and requires non-trivial polyfills to work (with degraded performance) in browsers that don’t support those features natively. In contrast, Vue works without any dependencies or polyfills down to IE9.\nIn Polymer, the team has also made its data-binding system very limited in order to compensate for the performance. For example, the only expressions supported in Polymer templates are boolean negation and single method calls. Its computed property implementation is also not very flexible.\nRiot\nRiot 3.0 provides a similar component-based development model (which is called a “tag” in Riot), with a minimal and beautifully designed API. Riot and Vue probably share a lot in design philosophies. However, despite being a bit heavier than Riot, Vue does offer some significant advantages:\n- Better performance. Riot traverses a DOM tree rather than using a virtual DOM, so suffers from the same performance issues as AngularJS.\n- More mature tooling support. Vue provides official support for webpack and Browserify, while Riot relies on community support for build system integration.",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/comparison",
      "title": "Comparison with Other Frameworks — Vue.js"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nInstallation\nCompatibility Note\nVue does not support IE8 and below, because it uses ECMAScript 5 features that are un-shimmable in IE8. However it supports all ECMAScript 5 compliant browsers.\nSemantic Versioning\nVue follows Semantic Versioning in all its official projects for documented features and behavior. For undocumented behavior or exposed internals, changes are described in release notes.\nRelease Notes\nLatest stable version: 2.7.16\nDetailed release notes for each version are available on GitHub.\nVue Devtools\nWhen using Vue, we recommend also installing the Vue Devtools in your browser, allowing you to inspect and debug your Vue applications in a more user-friendly interface.\nDirect <script>\nInclude\nSimply download and include with a script tag. Vue\nwill be registered as a global variable.\nDon’t use the minified version during development. You will miss out on all the nice warnings for common mistakes!\nDevelopment VersionWith full warnings and debug mode\nProduction VersionWarnings stripped, 37.70KB min+gzip\nCDN\nFor prototyping or learning purposes, you can use the latest version with:\n|\nFor production, we recommend linking to a specific version number and build to avoid unexpected breakage from newer versions:\n|\nIf you are using native ES Modules, there is also an ES Modules compatible build:\n|\nYou can browse the source of the NPM package at cdn.jsdelivr.net/npm/vue.\nVue is also available on unpkg and cdnjs (cdnjs takes some time to sync so the latest release may not be available yet).\nMake sure to read about the different builds of Vue and use the production\nversion in your published site, replacing vue.js\nwith vue.min.js\n. This is a smaller build optimized for speed instead of development experience.\nNPM\nNPM is the recommended installation method when building large scale applications with Vue. It pairs nicely with module bundlers such as Webpack or Browserify. Vue also provides accompanying tools for authoring Single File Components.\n|\nCLI\nVue provides an official CLI for quickly scaffolding ambitious Single Page Applications. It provides batteries-included build setups for a modern frontend workflow. It takes only a few minutes to get up and running with hot-reload, lint-on-save, and production-ready builds. See the Vue CLI docs for more details.\nThe CLI assumes prior knowledge of Node.js and the associated build tools. If you are new to Vue or front-end build tools, we strongly suggest going through the guide without any build tools before using the CLI.\nExplanation of Different Builds\nIn the dist/\ndirectory of the NPM package you will find many different builds of Vue.js. Here’s an overview of the difference between them:\nUMD | CommonJS | ES Module (for bundlers) | ES Module (for browsers) | |\n---|---|---|---|---|\nFull | vue.js | vue.common.js | vue.esm.js | vue.esm.browser.js |\nRuntime-only | vue.runtime.js | vue.runtime.common.js | vue.runtime.esm.js | - |\nFull (production) | vue.min.js | - | - | vue.esm.browser.min.js |\nRuntime-only (production) | vue.runtime.min.js | - | - | - |\nTerms\nFull: builds that contain both the compiler and the runtime.\nCompiler: code that is responsible for compiling template strings into JavaScript render functions.\nRuntime: code that is responsible for creating Vue instances, rendering and patching virtual DOM, etc. Basically everything minus the compiler.\nUMD: UMD builds can be used directly in the browser via a\n<script>\ntag. The default file from jsDelivr CDN at https://cdn.jsdelivr.net/npm/vue@2.7.16 is the Runtime + Compiler UMD build (vue.js\n).CommonJS: CommonJS builds are intended for use with older bundlers like browserify or webpack 1. The default file for these bundlers (\npkg.main\n) is the Runtime only CommonJS build (vue.runtime.common.js\n).ES Module: starting in 2.6 Vue provides two ES Modules (ESM) builds:\nESM for bundlers: intended for use with modern bundlers like webpack 2 or Rollup. ESM format is designed to be statically analyzable so the bundlers can take advantage of that to perform “tree-shaking” and eliminate unused code from your final bundle. The default file for these bundlers (\npkg.module\n) is the Runtime only ES Module build (vue.runtime.esm.js\n).ESM for browsers (2.6+ only): intended for direct imports in modern browsers via\n<script type=\"module\">\n.\nRuntime + Compiler vs. Runtime-only\nIf you need to compile templates on the client (e.g. passing a string to the template\noption, or mounting to an element using its in-DOM HTML as the template), you will need the compiler and thus the full build:\n|\nWhen using vue-loader\nor vueify\n, templates inside *.vue\nfiles are pre-compiled into JavaScript at build time. You don’t really need the compiler in the final bundle, and can therefore use the runtime-only build.\nSince the runtime-only builds are roughly 30% lighter-weight than their full-build counterparts, you should use it whenever you can. If you still wish to use the full build instead, you need to configure an alias in your bundler:\nWebpack\n|\nRollup\n|\nBrowserify\nAdd to your project’s package.json\n:\n|\nParcel\nAdd to your project’s package.json\n:\n|\nDevelopment vs. Production Mode\nDevelopment/production modes are hard-coded for the UMD builds: the un-minified files are for development, and the minified files are for production.\nCommonJS and ES Module builds are intended for bundlers, therefore we don’t provide minified versions for them. You will be responsible for minifying the final bundle yourself.\nCommonJS and ES Module builds also preserve raw checks for process.env.NODE_ENV\nto determine the mode they should run in. You should use appropriate bundler configurations to replace these environment variables in order to control which mode Vue will run in. Replacing process.env.NODE_ENV\nwith string literals also allows minifiers like UglifyJS to completely drop the development-only code blocks, reducing final file size.\nWebpack\nIn Webpack 4+, you can use the mode\noption:\n|\nBut in Webpack 3 and earlier, you’ll need to use DefinePlugin:\n|\nRollup\n|\nBrowserify\nApply a global envify transform to your bundle.\n|\nAlso see Production Deployment Tips.\nCSP environments\nSome environments, such as Google Chrome Apps, enforce Content Security Policy (CSP), which prohibits the use of new Function()\nfor evaluating expressions. The full build depends on this feature to compile templates, so is unusable in these environments.\nOn the other hand, the runtime-only build is fully CSP-compliant. When using the runtime-only build with Webpack + vue-loader or Browserify + vueify, your templates will be precompiled into render\nfunctions which work perfectly in CSP environments.\nDev Build\nImportant: the built files in GitHub’s /dist\nfolder are only checked-in during releases. To use Vue from the latest source code on GitHub, you will have to build it yourself!\n|\nBower\nOnly UMD builds are available from Bower.\n|\nAMD Module Loaders\nAll UMD builds can be used directly as an AMD module.",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/installation",
      "title": "Installation — Vue.js"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nMigration from Vue Router 0.7.x\nOnly Vue Router 2 is compatible with Vue 2, so if you’re updating Vue, you’ll have to update Vue Router as well. That’s why we’ve included details on the migration path here in the main docs. For a complete guide on using the new Vue Router, see the Vue Router docs.\nRouter Initialization\nrouter.start\nreplaced\nThere is no longer a special API to initialize an app with Vue Router. That means instead of:\n|\nYou pass a router property to a Vue instance:\n|\nOr, if you’re using the runtime-only build of Vue:\n|\nUpgrade Path\nRun the migration helper on your codebase to find examples of router.start\nbeing called.\nRoute Definitions\nrouter.map\nreplaced\nRoutes are now defined as an array on a routes\noption at router instantiation. So these routes for example:\n|\nWill instead be defined with:\n|\nThe array syntax allows more predictable route matching, since iterating over an object is not guaranteed to use the same property order across browsers.\nUpgrade Path\nRun the migration helper on your codebase to find examples of router.map\nbeing called.\nrouter.on\nremoved\nIf you need to programmatically generate routes when starting up your app, you can do so by dynamically pushing definitions to a routes array. For example:\n|\nIf you need to add new routes after the router has been instantiated, you can replace the router’s matcher with a new one that includes the route you’d like to add:\n|\nUpgrade Path\nRun the migration helper on your codebase to find examples of router.on\nbeing called.\nrouter.beforeEach\nchanged\nrouter.beforeEach\nnow works asynchronously and takes a next\nfunction as its third argument.\n|\n|\nsubRoutes\nrenamed\nRenamed to children\nfor consistency within Vue and with other routing libraries.\nUpgrade Path\nRun the migration helper on your codebase to find examples of the subRoutes\noption.\nrouter.redirect\nreplaced\nThis is now an option on route definitions. So for example, you will update:\n|\nto a definition like below in your routes\nconfiguration:\n|\nUpgrade Path\nRun the migration helper on your codebase to find examples of router.redirect\nbeing called.\nrouter.alias\nreplaced\nThis is now an option on the definition for the route you’d like to alias to. So for example, you will update:\n|\nto a definition like below in your routes\nconfiguration:\n|\nIf you need multiple aliases, you can also use an array syntax:\n|\nUpgrade Path\nRun the migration helper on your codebase to find examples of router.alias\nbeing called.\nArbitrary Route Properties replaced\nArbitrary route properties must now be scoped under the new meta property, to avoid conflicts with future features. So for example, if you had defined:\n|\nThen you would now update it to:\n|\nThen when later accessing this property on a route, you will still go through meta. For example:\n|\nUpgrade Path\nRun the migration helper on your codebase to find examples of arbitrary route properties not scoped under meta.\n[] Syntax for Arrays in Queries removed\nWhen passing arrays to query parameters the QueryString syntax is no longer /foo?users[]=Tom&users[]=Jerry\n, instead, the new syntax is /foo?users=Tom&users=Jerry\n. Internally, $route.query.users\nwill still be an Array, but if there’s only one parameter in the query: /foo?users=Tom\n, when directly accessing this route, there’s no way for the router to know if we were expecting users\nto be an Array. Because of this, consider adding a computed property and replacing every reference of $route.query.users\nwith it:\n|\nRoute Matching\nRoute matching now uses path-to-regexp under the hood, making it much more flexible than previously.\nOne or More Named Parameters changed\nThe syntax has changed slightly, so /category/*tags\nfor example, should be updated to /category/:tags+\n.\nUpgrade Path\nRun the migration helper on your codebase to find examples of the obsolete route syntax.\nLinks\nv-link\nreplaced\nThe v-link\ndirective has been replaced with a new <router-link>\ncomponent, as this sort of job is now solely the responsibility of components in Vue 2. That means whenever wherever you have a link like this:\n|\nYou’ll need to update it like this:\n|\nNote that target=\"_blank\"\nis not supported on <router-link>\n, so if you need to open a link in a new tab, you have to use <a>\ninstead.\nUpgrade Path\nRun the migration helper on your codebase to find examples of the v-link\ndirective.\nv-link-active\nreplaced\nThe v-link-active\ndirective has also been replaced by the tag\nattribute on the <router-link>\ncomponent. So for example, you’ll update this:\n|\nto this:\n|\nThe <a>\nwill be the actual link (and will get the correct href), but the active class will be applied to the outer <li>\n.\nUpgrade Path\nRun the migration helper on your codebase to find examples of the v-link-active\ndirective.\nProgrammatic Navigation\nrouter.go\nchanged\nFor consistency with the HTML5 History API, router.go\nis now only used for back/forward navigation, while router.push\nis used to navigate to a specific page.\nUpgrade Path\nRun the migration helper on your codebase to find examples of router.go\nbeing used where router.push\nshould be used instead.\nRouter Options: Modes\nhashbang: false\nremoved\nHashbangs are no longer required for Google to crawl a URL, so they are no longer the default (or even an option) for the hash strategy.\nUpgrade Path\nRun the migration helper on your codebase to find examples of the hashbang: false\noption.\nhistory: true\nreplaced\nAll routing mode options have been condensed into a single mode\noption. Update:\n|\nto:\n|\nUpgrade Path\nRun the migration helper on your codebase to find examples of the history: true\noption.\nabstract: true\nreplaced\nAll routing mode options have been condensed into a single mode\noption. Update:\n|\nto:\n|\nUpgrade Path\nRun the migration helper on your codebase to find examples of the abstract: true\noption.\nRoute Options: Misc\nsaveScrollPosition\nreplaced\nThis has been replaced with a scrollBehavior\noption that accepts a function, so that the scroll behavior is completely customizable - even per route. This opens many new possibilities, but to replicate the old behavior of:\n|\nYou can replace it with:\n|\nUpgrade Path\nRun the migration helper on your codebase to find examples of the saveScrollPosition: true\noption.\nroot\nrenamed\nRenamed to base\nfor consistency with the HTML <base>\nelement.\nUpgrade Path\nRun the migration helper on your codebase to find examples of the root\noption.\ntransitionOnLoad\nremoved\nThis option is no longer necessary now that Vue’s transition system has explicit appear\ntransition control.\nUpgrade Path\nRun the migration helper on your codebase to find examples of the transitionOnLoad: true\noption.\nsuppressTransitionError\nremoved\nRemoved due to hooks simplification. If you really must suppress transition errors, you can use try\n…catch\ninstead.\nUpgrade Path\nRun the migration helper on your codebase to find examples of the suppressTransitionError: true\noption.\nRoute Hooks\nactivate\nreplaced\nUse beforeRouteEnter\nin the component instead.\nUpgrade Path\nRun the migration helper on your codebase to find examples of the activate\nhook.\ncanActivate\nreplaced\nUse beforeEnter\nin the route instead.\nUpgrade Path\nRun the migration helper on your codebase to find examples of the canActivate\nhook.\ndeactivate\nremoved\nUse the component’s beforeDestroy\nor destroyed\nhooks instead.\nUpgrade Path\nRun the migration helper on your codebase to find examples of the deactivate\nhook.\ncanDeactivate\nreplaced\nUse beforeRouteLeave\nin the component instead.\nUpgrade Path\nRun the migration helper on your codebase to find examples of the canDeactivate\nhook.\ncanReuse: false\nremoved\nThere’s no longer a use case for this in the new Vue Router.\nUpgrade Path\nRun the migration helper on your codebase to find examples of the canReuse: false\noption.\ndata\nreplaced\nThe $route\nproperty is now reactive, so you can use a watcher to react to route changes, like this:\n|\nUpgrade Path\nRun the migration helper on your codebase to find examples of the data\nhook.\n$loadingRouteData\nremoved\nDefine your own property (e.g. isLoading\n), then update the loading state in a watcher on the route. For example, if fetching data with axios:\n|\nUpgrade Path\nRun the migration helper on your codebase to find examples of the $loadingRouteData\nmeta property.",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/migration-vue-router",
      "title": "Migration from Vue Router 0.7.x — Vue.js"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nEnter/Leave & List Transitions\nOverview\nVue provides a variety of ways to apply transition effects when items are inserted, updated, or removed from the DOM. This includes tools to:\n- automatically apply classes for CSS transitions and animations\n- integrate 3rd-party CSS animation libraries, such as Animate.css\n- use JavaScript to directly manipulate the DOM during transition hooks\n- integrate 3rd-party JavaScript animation libraries, such as Velocity.js\nOn this page, we’ll only cover entering, leaving, and list transitions, but you can see the next section for managing state transitions.\nTransitioning Single Elements/Components\nVue provides a transition\nwrapper component, allowing you to add entering/leaving transitions for any element or component in the following contexts:\n- Conditional rendering (using\nv-if\n) - Conditional display (using\nv-show\n) - Dynamic components\n- Component root nodes\nThis is what an example looks like in action:\n|\n|\n|\nhello\nWhen an element wrapped in a transition\ncomponent is inserted or removed, this is what happens:\nVue will automatically sniff whether the target element has CSS transitions or animations applied. If it does, CSS transition classes will be added/removed at appropriate timings.\nIf the transition component provided JavaScript hooks, these hooks will be called at appropriate timings.\nIf no CSS transitions/animations are detected and no JavaScript hooks are provided, the DOM operations for insertion and/or removal will be executed immediately on next frame (Note: this is a browser animation frame, different from Vue’s concept of\nnextTick\n).\nTransition Classes\nThere are six classes applied for enter/leave transitions.\nv-enter\n: Starting state for enter. Added before element is inserted, removed one frame after element is inserted.v-enter-active\n: Active state for enter. Applied during the entire entering phase. Added before element is inserted, removed when transition/animation finishes. This class can be used to define the duration, delay and easing curve for the entering transition.v-enter-to\n: Only available in versions 2.1.8+. Ending state for enter. Added one frame after element is inserted (at the same timev-enter\nis removed), removed when transition/animation finishes.v-leave\n: Starting state for leave. Added immediately when a leaving transition is triggered, removed after one frame.v-leave-active\n: Active state for leave. Applied during the entire leaving phase. Added immediately when leave transition is triggered, removed when the transition/animation finishes. This class can be used to define the duration, delay and easing curve for the leaving transition.v-leave-to\n: Only available in versions 2.1.8+. Ending state for leave. Added one frame after a leaving transition is triggered (at the same timev-leave\nis removed), removed when the transition/animation finishes.\nEach of these classes will be prefixed with the name of the transition. Here the v-\nprefix is the default when you use a <transition>\nelement with no name. If you use <transition name=\"my-transition\">\nfor example, then the v-enter\nclass would instead be my-transition-enter\n.\nv-enter-active\nand v-leave-active\ngive you the ability to specify different easing curves for enter/leave transitions, which you’ll see an example of in the following section.\nCSS Transitions\nOne of the most common transition types uses CSS transitions. Here’s an example:\n|\n|\n|\nhello\nCSS Animations\nCSS animations are applied in the same way as CSS transitions, the difference being that v-enter\nis not removed immediately after the element is inserted, but on an animationend\nevent.\nHere’s an example, omitting prefixed CSS rules for the sake of brevity:\n|\n|\n|\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris facilisis enim libero, at lacinia diam fermentum id. Pellentesque habitant morbi tristique senectus et netus.\nCustom Transition Classes\nYou can also specify custom transition classes by providing the following attributes:\nenter-class\nenter-active-class\nenter-to-class\n(2.1.8+)leave-class\nleave-active-class\nleave-to-class\n(2.1.8+)\nThese will override the conventional class names. This is especially useful when you want to combine Vue’s transition system with an existing CSS animation library, such as Animate.css.\nHere’s an example:\n|\n|\nhello\nUsing Transitions and Animations Together\nVue needs to attach event listeners in order to know when a transition has ended. It can either be transitionend\nor animationend\n, depending on the type of CSS rules applied. If you are only using one or the other, Vue can automatically detect the correct type.\nHowever, in some cases you may want to have both on the same element, for example having a CSS animation triggered by Vue, along with a CSS transition effect on hover. In these cases, you will have to explicitly declare the type you want Vue to care about in a type\nattribute, with a value of either animation\nor transition\n.\nExplicit Transition Durations\nNew in 2.2.0+\nIn most cases, Vue can automatically figure out when the transition has finished. By default, Vue waits for the first transitionend\nor animationend\nevent on the root transition element. However, this may not always be desired - for example, we may have a choreographed transition sequence where some nested inner elements have a delayed transition or a longer transition duration than the root transition element.\nIn such cases you can specify an explicit transition duration (in milliseconds) using the duration\nprop on the <transition>\ncomponent:\n|\nYou can also specify separate values for enter and leave durations:\n|\nJavaScript Hooks\nYou can also define JavaScript hooks in attributes:\n|\n|\nThese hooks can be used in combination with CSS transitions/animations or on their own.\nWhen using JavaScript-only transitions, the done\ncallbacks are required for the enter\nand leave\nhooks. Otherwise, the hooks will be called synchronously and the transition will finish immediately.\nIt’s also a good idea to explicitly add v-bind:css=\"false\"\nfor JavaScript-only transitions so that Vue can skip the CSS detection. This also prevents CSS rules from accidentally interfering with the transition.\nNow let’s dive into an example. Here’s a JavaScript transition using Velocity.js:\n|\n|\nDemo\nTransitions on Initial Render\nIf you also want to apply a transition on the initial render of a node, you can add the appear\nattribute:\n|\nBy default, this will use the transitions specified for entering and leaving. If you’d like however, you can also specify custom CSS classes:\n|\nand custom JavaScript hooks:\n|\nIn the example above, either appear\nattribute or v-on:appear\nhook will cause an appear transition.\nTransitioning Between Elements\nWe discuss transitioning between components later, but you can also transition between raw elements using v-if\n/v-else\n. One of the most common two-element transitions is between a list container and a message describing an empty list:\n|\nThis works well, but there’s one caveat to be aware of:\nWhen toggling between elements that have the same tag name, you must tell Vue that they are distinct elements by giving them unique key\nattributes. Otherwise, Vue’s compiler will only replace the content of the element for efficiency. Even when technically unnecessary though, it’s considered good practice to always key multiple items within a <transition>\ncomponent.\nFor example:\n|\nIn these cases, you can also use the key\nattribute to transition between different states of the same element. Instead of using v-if\nand v-else\n, the above example could be rewritten as:\n|\nIt’s actually possible to transition between any number of elements, either by using multiple v-if\ns or binding a single element to a dynamic property. For example:\n|\nWhich could also be written as:\n|\n|\nTransition Modes\nThere’s still one problem though. Try clicking the button below:\nAs it’s transitioning between the “on” button and the “off” button, both buttons are rendered - one transitioning out while the other transitions in. This is the default behavior of <transition>\n- entering and leaving happens simultaneously.\nSometimes this works great, like when transitioning items are absolutely positioned on top of each other:\nAnd then maybe also translated so that they look like slide transitions:\nSimultaneous entering and leaving transitions aren’t always desirable though, so Vue offers some alternative transition modes:\nin-out\n: New element transitions in first, then when complete, the current element transitions out.out-in\n: Current element transitions out first, then when complete, the new element transitions in.\nNow let’s update the transition for our on/off buttons with out-in\n:\n|\nWith one attribute addition, we’ve fixed that original transition without having to add any special styling.\nThe in-out\nmode isn’t used as often, but can sometimes be useful for a slightly different transition effect. Let’s try combining it with the slide-fade transition we worked on earlier:\nPretty cool, right?\nTransitioning Between Components\nTransitioning between components is even simpler - we don’t even need the key\nattribute. Instead, we wrap a dynamic component:\n|\n|\n|\nList Transitions\nSo far, we’ve managed transitions for:\n- Individual nodes\n- Multiple nodes where only 1 is rendered at a time\nSo what about for when we have a whole list of items we want to render simultaneously, for example with v-for\n? In this case, we’ll use the <transition-group>\ncomponent. Before we dive into an example though, there are a few things that are important to know about this component:\n- Unlike\n<transition>\n, it renders an actual element: a<span>\nby default. You can change the element that’s rendered with thetag\nattribute. - Transition modes are not available, because we are no longer alternating between mutually exclusive elements.\n- Elements inside are always required to have a unique\nkey\nattribute. - CSS transition classes will be applied to inner elements and not to the group/container itself.\nList Entering/Leaving Transitions\nNow let’s dive into an example, transitioning entering and leaving using the same CSS classes we’ve used previously:\n|\n|\n|\nThere’s one problem with this example. When you add or remove an item, the ones around it instantly snap into their new place instead of smoothly transitioning. We’ll fix that later.\nList Move Transitions\nThe <transition-group>\ncomponent has another trick up its sleeve. It can not only animate entering and leaving, but also changes in position. The only new concept you need to know to use this feature is the addition of the v-move\nclass, which is added when items are changing positions. Like the other classes, its prefix will match the value of a provided name\nattribute and you can also manually specify a class with the move-class\nattribute.\nThis class is mostly useful for specifying the transition timing and easing curve, as you’ll see below:\n|\n|\n|\nThis might seem like magic, but under the hood, Vue is using an animation technique called FLIP to smoothly transition elements from their old position to their new position using transforms.\nWe can combine this technique with our previous implementation to animate every possible change to our list!\n|\n|\n|\nOne important note is that these FLIP transitions do not work with elements set to display: inline\n. As an alternative, you can use display: inline-block\nor place elements in a flex context.\nThese FLIP animations are also not limited to a single axis. Items in a multidimensional grid can be transitioned too:\nKeep hitting the shuffle button until you win.\nStaggering List Transitions\nBy communicating with JavaScript transitions through data attributes, it’s also possible to stagger transitions in a list:\n|\n|\nReusable Transitions\nTransitions can be reused through Vue’s component system. To create a reusable transition, all you have to do is place a <transition>\nor <transition-group>\ncomponent at the root, then pass any children into the transition component.\nHere’s an example using a template component:\n|\nAnd functional components are especially well-suited to this task:\n|\nDynamic Transitions\nYes, even transitions in Vue are data-driven! The most basic example of a dynamic transition binds the name\nattribute to a dynamic property.\n|\nThis can be useful when you’ve defined CSS transitions/animations using Vue’s transition class conventions and want to switch between them.\nReally though, any transition attribute can be dynamically bound. And it’s not only attributes. Since event hooks are methods, they have access to any data in the context. That means depending on the state of your component, your JavaScript transitions can behave differently.\n|\n|\nhello\nFinally, the ultimate way of creating dynamic transitions is through components that accept props to change the nature of the transition(s) to be used. It may sound cheesy, but the only limit really is your imagination.",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/transitions",
      "title": "Enter/Leave & List Transitions — Vue.js"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nSlots\nThis page assumes you’ve already read the Components Basics. Read that first if you are new to components.\nIn 2.6.0, we introduced a new unified syntax (the\nv-slot\ndirective) for named and scoped slots. It replaces theslot\nandslot-scope\nattributes, which are now deprecated, but have not been removed and are still documented here. The rationale for introducing the new syntax is described in this RFC.\nSlot Content\nVue implements a content distribution API inspired by the Web Components spec draft, using the <slot>\nelement to serve as distribution outlets for content.\nThis allows you to compose components like this:\n|\nThen in the template for <navigation-link>\n, you might have:\n|\nWhen the component renders, <slot></slot>\nwill be replaced by “Your Profile”. Slots can contain any template code, including HTML:\n|\nOr even other components:\n|\nIf <navigation-link>\n‘s template did not contain a <slot>\nelement, any content provided between its opening and closing tag would be discarded.\nCompilation Scope\nWhen you want to use data inside a slot, such as in:\n|\nThat slot has access to the same instance properties (i.e. the same “scope”) as the rest of the template. The slot does not have access to <navigation-link>\n‘s scope. For example, trying to access url\nwould not work:\n|\nAs a rule, remember that:\nEverything in the parent template is compiled in parent scope; everything in the child template is compiled in the child scope.\nFallback Content\nThere are cases when it’s useful to specify fallback (i.e. default) content for a slot, to be rendered only when no content is provided. For example, in a <submit-button>\ncomponent:\n|\nWe might want the text “Submit” to be rendered inside the <button>\nmost of the time. To make “Submit” the fallback content, we can place it in between the <slot>\ntags:\n|\nNow when we use <submit-button>\nin a parent component, providing no content for the slot:\n|\nwill render the fallback content, “Submit”:\n|\nBut if we provide content:\n|\nThen the provided content will be rendered instead:\n|\nNamed Slots\nUpdated in 2.6.0+. See here for the deprecated syntax using the\nslot\nattribute.\nThere are times when it’s useful to have multiple slots. For example, in a <base-layout>\ncomponent with the following template:\n|\nFor these cases, the <slot>\nelement has a special attribute, name\n, which can be used to define additional slots:\n|\nA <slot>\noutlet without name\nimplicitly has the name “default”.\nTo provide content to named slots, we can use the v-slot\ndirective on a <template>\n, providing the name of the slot as v-slot\n‘s argument:\n|\nNow everything inside the <template>\nelements will be passed to the corresponding slots. Any content not wrapped in a <template>\nusing v-slot\nis assumed to be for the default slot.\nHowever, you can still wrap default slot content in a <template>\nif you wish to be explicit:\n|\nEither way, the rendered HTML will be:\n|\nNote that v-slot\ncan only be added to a <template>\n(with one exception), unlike the deprecated slot\nattribute.\nScoped Slots\nUpdated in 2.6.0+. See here for the deprecated syntax using the\nslot-scope\nattribute.\nSometimes, it’s useful for slot content to have access to data only available in the child component. For example, imagine a <current-user>\ncomponent with the following template:\n|\nWe might want to replace this fallback content to display the user’s first name, instead of last, like this:\n|\nThat won’t work, however, because only the <current-user>\ncomponent has access to the user\nand the content we’re providing is rendered in the parent.\nTo make user\navailable to the slot content in the parent, we can bind user\nas an attribute to the <slot>\nelement:\n|\nAttributes bound to a <slot>\nelement are called slot props. Now, in the parent scope, we can use v-slot\nwith a value to define a name for the slot props we’ve been provided:\n|\nIn this example, we’ve chosen to name the object containing all our slot props slotProps\n, but you can use any name you like.\nAbbreviated Syntax for Lone Default Slots\nIn cases like above, when only the default slot is provided content, the component’s tags can be used as the slot’s template. This allows us to use v-slot\ndirectly on the component:\n|\nThis can be shortened even further. Just as non-specified content is assumed to be for the default slot, v-slot\nwithout an argument is assumed to refer to the default slot:\n|\nNote that the abbreviated syntax for default slot cannot be mixed with named slots, as it would lead to scope ambiguity:\n|\nWhenever there are multiple slots, use the full <template>\nbased syntax for all slots:\n|\nDestructuring Slot Props\nInternally, scoped slots work by wrapping your slot content in a function passed a single argument:\n|\nThat means the value of v-slot\ncan actually accept any valid JavaScript expression that can appear in the argument position of a function definition. So in supported environments (single-file components or modern browsers), you can also use ES2015 destructuring to pull out specific slot props, like so:\n|\nThis can make the template much cleaner, especially when the slot provides many props. It also opens other possibilities, such as renaming props, e.g. user\nto person\n:\n|\nYou can even define fallbacks, to be used in case a slot prop is undefined:\n|\nDynamic Slot Names\nNew in 2.6.0+\nDynamic directive arguments also work on v-slot\n, allowing the definition of dynamic slot names:\n|\nNamed Slots Shorthand\nNew in 2.6.0+\nSimilar to v-on\nand v-bind\n, v-slot\nalso has a shorthand, replacing everything before the argument (v-slot:\n) with the special symbol #\n. For example, v-slot:header\ncan be rewritten as #header\n:\n|\nHowever, just as with other directives, the shorthand is only available when an argument is provided. That means the following syntax is invalid:\n|\nInstead, you must always specify the name of the slot if you wish to use the shorthand:\n|\nOther Examples\nSlot props allow us to turn slots into reusable templates that can render different content based on input props. This is most useful when you are designing a reusable component that encapsulates data logic while allowing the consuming parent component to customize part of its layout.\nFor example, we are implementing a <todo-list>\ncomponent that contains the layout and filtering logic for a list:\n|\nInstead of hard-coding the content for each todo, we can let the parent component take control by making every todo a slot, then binding todo\nas a slot prop:\n|\nNow when we use the <todo-list>\ncomponent, we can optionally define an alternative <template>\nfor todo items, but with access to data from the child:\n|\nHowever, even this barely scratches the surface of what scoped slots are capable of. For real-life, powerful examples of scoped slot usage, we recommend browsing libraries such as Vue Virtual Scroller, Vue Promised, and Portal Vue.\nDeprecated Syntax\nThe\nv-slot\ndirective was introduced in Vue 2.6.0, offering an improved, alternative API to the still-supportedslot\nandslot-scope\nattributes. The full rationale for introducingv-slot\nis described in this RFC. Theslot\nandslot-scope\nattributes will continue to be supported in all future 2.x releases, but are officially deprecated and will eventually be removed in Vue 3.\nNamed Slots with the slot\nAttribute\nDeprecated in 2.6.0+. See here for the new, recommended syntax.\nTo pass content to named slots from the parent, use the special slot\nattribute on <template>\n(using the <base-layout>\ncomponent described here as example):\n|\nOr, the slot\nattribute can also be used directly on a normal element:\n|\nThere can still be one unnamed slot, which is the default slot that serves as a catch-all for any unmatched content. In both examples above, the rendered HTML would be:\n|\nScoped Slots with the slot-scope\nAttribute\nDeprecated in 2.6.0+. See here for the new, recommended syntax.\nTo receive props passed to a slot, the parent component can use <template>\nwith the slot-scope\nattribute (using the <slot-example>\ndescribed here as example):\n|\nHere, slot-scope\ndeclares the received props object as the slotProps\nvariable, and makes it available inside the <template>\nscope. You can name slotProps\nanything you like similar to naming function arguments in JavaScript.\nHere slot=\"default\"\ncan be omitted as it is implied:\n|\nThe slot-scope\nattribute can also be used directly on a non-<template>\nelement (including components):\n|\nThe value of slot-scope\ncan accept any valid JavaScript expression that can appear in the argument position of a function definition. This means in supported environments (single-file components or modern browsers) you can also use ES2015 destructuring in the expression, like so:\n|\nUsing the <todo-list>\ndescribed here as an example, here’s the equivalent usage using slot-scope\n:\n|",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/components-slots",
      "title": "Slots — Vue.js"
    }
  },
  {
    "page_content": "API Documentation / NavigationFailureType\nEnumeration: NavigationFailureType\nEnumeration with all possible types for navigation failures. Can be passed to isNavigationFailure to check for specific failures.\nEnumeration Members\naborted\n• aborted = 4\nAn aborted navigation is a navigation that failed because a navigation guard returned false\nor called next(false)\ncancelled\n• cancelled = 8\nA cancelled navigation is a navigation that failed because a more recent navigation finished started (not necessarily finished).\nduplicated\n• duplicated = 16\nA duplicated navigation is a navigation that failed because it was initiated while already being at the exact same location.",
    "metadata": {
      "source": "https://router.vuejs.org/api/enums/navigationfailuretype",
      "title": "Enumeration: NavigationFailureType | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / RouterScrollBehavior\nInterface: RouterScrollBehavior\nType of the scrollBehavior\noption that can be passed to createRouter\n.\nCallable\nRouterScrollBehavior\n▸ RouterScrollBehavior(to\n, from\n, savedPosition\n): Awaitable\n<false\n| void\n| ScrollPosition\n>\nParameters\nName | Type | Description |\n---|---|---|\nto | RouteLocationNormalizedGeneric | Route location where we are navigating to |\nfrom | RouteLocationNormalizedLoadedGeneric | Route location where we are navigating from |\nsavedPosition | null | _ScrollPositionNormalized | saved position if it exists, null otherwise |\nReturns\nAwaitable\n<false\n| void\n| ScrollPosition\n>",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/routerscrollbehavior",
      "title": "Interface: RouterScrollBehavior | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / RouterLinkProps\nInterface: RouterLinkProps\nHierarchy\nRouterLinkOptions\n↳\nRouterLinkProps\nProperties\nactiveClass\n• Optional\nactiveClass: string\nClass to apply when the link is active\nariaCurrentValue\n• Optional\nariaCurrentValue: \"time\"\n| \"location\"\n| \"page\"\n| \"step\"\n| \"date\"\n| \"true\"\n| \"false\"\nValue passed to the attribute aria-current\nwhen the link is exact active.\nDefault Value\n'page'\ncustom\n• Optional\ncustom: boolean\nWhether RouterLink should not wrap its content in an a\ntag. Useful when using v-slot\nto create a custom RouterLink\nexactActiveClass\n• Optional\nexactActiveClass: string\nClass to apply when the link is exact active\nreplace\n• Optional\nreplace: boolean\nCalls router.replace\ninstead of router.push\n.\nInherited from\nRouterLinkOptions.replace\nto\n• to: string\n| RouteLocationAsRelativeGeneric\n| RouteLocationAsPathGeneric\nRoute Location the link should navigate to when clicked on.\nInherited from\nRouterLinkOptions.to",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/routerlinkprops",
      "title": "Interface: RouterLinkProps | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / RouteLocationOptions\nInterface: RouteLocationOptions\nCommon options for all navigation methods.\nHierarchy\nRouteLocationOptions\n↳\nRouteLocationAsRelativeGeneric\nProperties\nforce\n• Optional\nforce: boolean\nTriggers the navigation even if the location is the same as the current one. Note this will also add a new entry to the history unless replace: true\nis passed.\nreplace\n• Optional\nreplace: boolean\nReplace the entry in the history instead of pushing a new entry\nstate\n• Optional\nstate: HistoryState\nState to save using the History API. This cannot contain any reactive values and some primitives like Symbols are forbidden. More info at https://developer.mozilla.org/en-US/docs/Web/API/History/state",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/routelocationoptions",
      "title": "Interface: RouteLocationOptions | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / RouteLocationAsRelativeGeneric\nInterface: RouteLocationAsRelativeGeneric\nGeneric version of RouteLocationAsRelative. It is used when no RouteMap is provided.\nHierarchy\n↳\nRouteLocationAsRelativeGeneric\nProperties\nforce\n• Optional\nforce: boolean\nTriggers the navigation even if the location is the same as the current one. Note this will also add a new entry to the history unless replace: true\nis passed.\nInherited from\nhash\n• Optional\nhash: string\nInherited from\nname\n• Optional\nname: RouteRecordNameGeneric\nparams\n• Optional\nparams: RouteParamsRawGeneric\npath\n• Optional\npath: undefined\nA relative path to the current location. This property should be removed\nquery\n• Optional\nquery: LocationQueryRaw\nInherited from\nreplace\n• Optional\nreplace: boolean\nReplace the entry in the history instead of pushing a new entry\nInherited from\nstate\n• Optional\nstate: HistoryState\nState to save using the History API. This cannot contain any reactive values and some primitives like Symbols are forbidden. More info at https://developer.mozilla.org/en-US/docs/Web/API/History/state",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/routelocationasrelativegeneric",
      "title": "Interface: RouteLocationAsRelativeGeneric | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / RouteLocationNamedRaw\nInterface: RouteLocationNamedRaw\nRoute Location that can infer the necessary params based on the name.\nHierarchy\n↳\nRouteLocationNamedRaw\nProperties\nforce\n• Optional\nforce: boolean\nTriggers the navigation even if the location is the same as the current one. Note this will also add a new entry to the history unless replace: true\nis passed.\nInherited from\nhash\n• Optional\nhash: string\nInherited from\nname\n• Optional\nname: RouteRecordNameGeneric\nInherited from\nparams\n• Optional\nparams: RouteParamsRawGeneric\nInherited from\npath\n• Optional\npath: undefined\nIgnored path property since we are dealing with a relative location. Only undefined\nis allowed.\nInherited from\nquery\n• Optional\nquery: LocationQueryRaw\nInherited from\nreplace\n• Optional\nreplace: boolean\nReplace the entry in the history instead of pushing a new entry\nInherited from\nstate\n• Optional\nstate: HistoryState\nState to save using the History API. This cannot contain any reactive values and some primitives like Symbols are forbidden. More info at https://developer.mozilla.org/en-US/docs/Web/API/History/state",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/routelocationnamedraw",
      "title": "Interface: RouteLocationNamedRaw | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / RouteRecordMultipleViews\nInterface: RouteRecordMultipleViews\nRoute Record defining multiple named components with the components\noption.\nHierarchy\n↳\nRouteRecordMultipleViews\nProperties\nalias\n• Optional\nalias: string\n| string\n[]\nAliases for the record. Allows defining extra paths that will behave like a copy of the record. Allows having paths shorthands like /users/:id\nand /u/:id\n. All alias\nand path\nvalues must share the same params.\nInherited from\nbeforeEnter\n• Optional\nbeforeEnter: NavigationGuardWithThis\n<undefined\n> | NavigationGuardWithThis\n<undefined\n>[]\nBefore Enter guard specific to this record. Note beforeEnter\nhas no effect if the record has a redirect\nproperty.\nInherited from\nchildren\n• Optional\nchildren: undefined\nArray of nested routes.\nOverrides\ncomponent\n• Optional\ncomponent: undefined\ncomponents\n• components: Record\n<string\n, RawRouteComponent\n>\nComponents to display when the URL matches this route. Allow using named views.\nend\n• Optional\nend: boolean\nShould the RegExp match until the end by appending a $\nto it.\nDefault Value\ntrue\nInherited from\nmeta\n• Optional\nmeta: RouteMeta\nArbitrary data attached to the record.\nInherited from\nname\n• Optional\nname: RouteRecordNameGeneric\nName for the route record. Must be unique.\nInherited from\npath\n• path: string\nPath of the record. Should start with /\nunless the record is the child of another record.\nExample\n`/users/:id` matches `/users/1` as well as `/users/posva`.\nInherited from\nprops\n• Optional\nprops: boolean\n| Record\n<string\n, _RouteRecordProps\n>\nAllow passing down params as props to the component rendered by router-view\n. Should be an object with the same keys as components\nor a boolean to be applied to every component.\nOverrides\nredirect\n• Optional\nredirect: undefined\nWhere to redirect if the route is directly matched. The redirection happens before any navigation guard and triggers a new navigation with the new target location.\nOverrides\nsensitive\n• Optional\nsensitive: boolean\nMakes the RegExp case-sensitive.\nDefault Value\nfalse\nInherited from\nstrict\n• Optional\nstrict: boolean\nWhether to disallow a trailing slash or not.\nDefault Value\nfalse",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/routerecordmultipleviews",
      "title": "Interface: RouteRecordMultipleViews | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / RouteRecordMultipleViewsWithChildren\nInterface: RouteRecordMultipleViewsWithChildren\nRoute Record defining multiple named components with the components\noption and children.\nHierarchy\n↳\nRouteRecordMultipleViewsWithChildren\nProperties\nalias\n• Optional\nalias: string\n| string\n[]\nAliases for the record. Allows defining extra paths that will behave like a copy of the record. Allows having paths shorthands like /users/:id\nand /u/:id\n. All alias\nand path\nvalues must share the same params.\nInherited from\nbeforeEnter\n• Optional\nbeforeEnter: NavigationGuardWithThis\n<undefined\n> | NavigationGuardWithThis\n<undefined\n>[]\nBefore Enter guard specific to this record. Note beforeEnter\nhas no effect if the record has a redirect\nproperty.\nInherited from\nchildren\n• children: RouteRecordRaw\n[]\nArray of nested routes.\nOverrides\ncomponent\n• Optional\ncomponent: undefined\ncomponents\n• Optional\ncomponents: null\n| Record\n<string\n, RawRouteComponent\n>\nComponents to display when the URL matches this route. Allow using named views.\nend\n• Optional\nend: boolean\nShould the RegExp match until the end by appending a $\nto it.\nDefault Value\ntrue\nInherited from\nmeta\n• Optional\nmeta: RouteMeta\nArbitrary data attached to the record.\nInherited from\nname\n• Optional\nname: RouteRecordNameGeneric\nName for the route record. Must be unique.\nInherited from\npath\n• path: string\nPath of the record. Should start with /\nunless the record is the child of another record.\nExample\n`/users/:id` matches `/users/1` as well as `/users/posva`.\nInherited from\nprops\n• Optional\nprops: boolean\n| Record\n<string\n, _RouteRecordProps\n>\nAllow passing down params as props to the component rendered by router-view\n. Should be an object with the same keys as components\nor a boolean to be applied to every component.\nOverrides\nredirect\n• Optional\nredirect: RouteRecordRedirectOption\nWhere to redirect if the route is directly matched. The redirection happens before any navigation guard and triggers a new navigation with the new target location.\nInherited from\nsensitive\n• Optional\nsensitive: boolean\nMakes the RegExp case-sensitive.\nDefault Value\nfalse\nInherited from\nstrict\n• Optional\nstrict: boolean\nWhether to disallow a trailing slash or not.\nDefault Value\nfalse",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/routerecordmultipleviewswithchildren",
      "title": "Interface: RouteRecordMultipleViewsWithChildren | Vue Router"
    }
  },
  {
    "page_content": "Guide\nEssentials\n- Installation\n- Introduction\n- The Vue Instance\n- Template Syntax\n- Computed Properties and Watchers\n- Class and Style Bindings\n- Conditional Rendering\n- List Rendering\n- Event Handling\n- Form Input Bindings\n- Components Basics\nComponents In-Depth\n- Component Registration\n- Props\n- Custom Events\n- Slots\n- Dynamic & Async Components\n- Handling Edge Cases\nTransitions & Animation\n- Enter/Leave & List Transitions\n- State Transitions\nReusability & Composition\n- Mixins\n- Custom Directives\n- Render Functions & JSX\n- Plugins\n- Filters\nTooling\n- Single File Components\n- Testing\n- TypeScript Support\n- Production Deployment\nScaling Up\n- Routing\n- State Management\n- Server-Side Rendering\n- Security\nInternals\n- Reactivity in Depth\nMigrating\n- Migration from Vue 1.x\n- Migration from Vue Router 0.7.x\n- Migration from Vuex 0.6.x to 1.0\n- Migration to Vue 2.7\nMeta\n- Comparison with Other Frameworks\n- Join the Vue.js Community!\n- Meet the Team\nMigration from Vue 1.x\nFAQ\nWoah - this is a super long page! Does that mean 2.0 is completely different, I’ll have to learn the basics all over again, and migrating will be practically impossible?\nI’m glad you asked! The answer is no. About 90% of the API is the same and the core concepts haven’t changed. It’s long because we like to offer very detailed explanations and include a lot of examples. Rest assured, this is not something you have to read from top to bottom!\nWhere should I start in a migration?\nStart by running the migration helper on a current project. We’ve carefully minified and compressed a senior Vue dev into a simple command line interface. Whenever they recognize an obsolete feature, they’ll let you know, offer suggestions, and provide links to more info.\nAfter that, browse through the table of contents for this page in the sidebar. If you see a topic you may be affected by, but the migration helper didn’t catch, check it out.\nIf you have any tests, run them and see what still fails. If you don’t have tests, just open the app in your browser and keep an eye out for warnings or errors as you navigate around.\nBy now, your app should be fully migrated. If you’re still hungry for more though, you can read the rest of this page - or dive in to the new and improved guide from the beginning. Many parts will be skimmable, since you’re already familiar with the core concepts.\nHow long will it take to migrate a Vue 1.x app to 2.0?\nIt depends on a few factors:\nThe size of your app (small to medium-sized apps will probably be less than a day)\nHow many times you get distracted and start playing with a cool new feature. 😉 Not judging, it also happened to us while building 2.0!\nWhich obsolete features you’re using. Most can be upgraded with find-and-replace, but others might take a few minutes. If you’re not currently following best practices, Vue 2.0 will also try harder to force you to. This is a good thing in the long run, but could also mean a significant (though possibly overdue) refactor.\nIf I upgrade to Vue 2, will I also have to upgrade Vuex and Vue Router?\nOnly Vue Router 2 is compatible with Vue 2, so yes, you’ll have to follow the migration path for Vue Router as well. Fortunately, most applications don’t have a lot of router code, so this likely won’t take more than an hour.\nAs for Vuex, even version 0.8 is compatible with Vue 2, so you’re not forced to upgrade. The only reason you may want to upgrade immediately is to take advantage of the new features in Vuex 2, such as modules and reduced boilerplate.\nTemplates\nFragment Instances removed\nEvery component must have exactly one root element. Fragment instances are no longer allowed. If you have a template like this:\n|\nIt’s recommended to wrap the entire contents in a new element, like this:\n|\nUpgrade Path\nRun your end-to-end test suite or app after upgrading and look for console warnings about multiple root elements in a template.\nLifecycle Hooks\nbeforeCompile\nremoved\nUse the created\nhook instead.\nUpgrade Path\nRun the migration helper on your codebase to find all examples of this hook.\ncompiled\nreplaced\nUse the new mounted\nhook instead.\nUpgrade Path\nRun the migration helper on your codebase to find all examples of this hook.\nattached\nremoved\nUse a custom in-DOM check in other hooks. For example, to replace:\n|\nYou could use:\n|\nUpgrade Path\nRun the migration helper on your codebase to find all examples of this hook.\ndetached\nremoved\nUse a custom in-DOM check in other hooks. For example, to replace:\n|\nYou could use:\n|\nUpgrade Path\nRun the migration helper on your codebase to find all examples of this hook.\ninit\nrenamed\nUse the new beforeCreate\nhook instead, which is essentially the same thing. It was renamed for consistency with other lifecycle methods.\nUpgrade Path\nRun the migration helper on your codebase to find all examples of this hook.\nready\nreplaced\nUse the new mounted\nhook instead. It should be noted though that with mounted\n, there’s no guarantee to be in-document. For that, also include Vue.nextTick\n/vm.$nextTick\n. For example:\n|\nUpgrade Path\nRun the migration helper on your codebase to find all examples of this hook.\nv-for\nv-for\nArgument Order for Arrays changed\nWhen including an index\n, the argument order for arrays used to be (index, value)\n. It is now (value, index)\nto be more consistent with JavaScript’s native array methods such as forEach\nand map\n.\nUpgrade Path\nRun the migration helper on your codebase to find examples of the obsolete argument order. Note that if you name your index arguments something unusual like position\nor num\n, the helper will not flag them.\nv-for\nArgument Order for Objects changed\nWhen including a property name/key, the argument order for objects used to be (name, value)\n. It is now (value, name)\nto be more consistent with common object iterators such as lodash’s.\nUpgrade Path\nRun the migration helper on your codebase to find examples of the obsolete argument order. Note that if you name your key arguments something like name\nor property\n, the helper will not flag them.\n$index\nand $key\nremoved\nThe implicitly assigned $index\nand $key\nvariables have been removed in favor of explicitly defining them in v-for\n. This makes the code easier to read for developers less experienced with Vue and also results in much clearer behavior when dealing with nested loops.\nUpgrade Path\nRun the migration helper on your codebase to find examples of these removed variables. If you miss any, you should also see console errors such as: Uncaught ReferenceError: $index is not defined\ntrack-by\nreplaced\ntrack-by\nhas been replaced with key\n, which works like any other attribute: without the v-bind:\nor :\nprefix, it is treated as a literal string. In most cases, you’d want to use a dynamic binding which expects a full expression instead of a key. For example, in place of:\n|\nYou would now write:\n|\nUpgrade Path\nRun the migration helper on your codebase to find examples of track-by\n.\nv-for\nRange Values changed\nPreviously, v-for=\"number in 10\"\nwould have number\nstarting at 0 and ending at 9. Now it starts at 1 and ends at 10.\nUpgrade Path\nSearch your codebase for the regex /\\w+ in \\d+/\n. Wherever it appears in a v-for\n, check to see if you may be affected.\nProps\ncoerce\nProp Option removed\nIf you want to coerce a prop, setup a local computed value based on it instead. For example, instead of:\n|\nYou could write:\n|\nThere are a few advantages:\n- You still have access to the original value of the prop.\n- You are forced to be more explicit, by giving your coerced value a name that differentiates it from the value passed in the prop.\nUpgrade Path\nRun the migration helper on your codebase to find examples of the coerce\noption.\ntwoWay\nProp Option removed\nProps are now always one-way down. To produce side effects in the parent scope, a component needs to explicitly emit an event instead of relying on implicit binding. For more information, see:\n- Custom component events\n- Custom input components (using component events)\n- Global state management\nUpgrade Path\nRun the migration helper on your codebase to find examples of the twoWay\noption.\n.once\nand .sync\nModifiers on v-bind\nremoved\nProps are now always one-way down. To produce side effects in the parent scope, a component needs to explicitly emit an event instead of relying on implicit binding. For more information, see:\n- Custom component events\n- Custom input components (using component events)\n- Global state management\nUpgrade Path\nRun the migration helper on your codebase to find examples of the .once\nand .sync\nmodifiers.\nProp Mutation deprecated\nMutating a prop locally is now considered an anti-pattern, e.g. declaring a prop and then setting this.myProp = 'someOtherValue'\nin the component. Due to the new rendering mechanism, whenever the parent component re-renders, the child component’s local changes will be overwritten.\nMost use cases of mutating a prop can be replaced by one of these options:\n- a data property, with the prop used to set its default value\n- a computed property\nUpgrade Path\nRun your end-to-end test suite or app after upgrading and look for console warnings about prop mutations.\nProps on a Root Instance replaced\nOn root Vue instances (i.e. instances created with new Vue({ ... })\n), you must use propsData\ninstead of props\n.\nUpgrade Path\nRun your end-to-end test suite, if you have one. The failed tests should alert to you to the fact that props passed to root instances are no longer working.\nComputed properties\ncache: false\ndeprecated\nCaching invalidation of computed properties will be removed in future major versions of Vue. Replace any uncached computed properties with methods, which will have the same result.\nFor example:\n|\nOr with component methods:\n|\nUpgrade Path\nRun the migration helper on your codebase to find examples of the cache: false\noption.\nBuilt-In Directives\nTruthiness/Falsiness with v-bind\nchanged\nWhen used with v-bind\n, the only falsy values are now: null\n, undefined\n, and false\n. This means 0\nand empty strings will render as truthy. So for example, v-bind:draggable=\"''\"\nwill render as draggable=\"true\"\n.\nFor enumerated attributes, in addition to the falsy values above, the string \"false\"\nwill also render as attr=\"false\"\n.\nNote that for other directives (e.g. v-if\nand v-show\n), JavaScript’s normal truthiness still applies.\nUpgrade Path\nRun your end-to-end test suite, if you have one. The failed tests should alert to you to any parts of your app that may be affected by this change.\nListening for Native Events on Components with v-on\nchanged\nWhen used on a component, v-on\nnow only listens to custom events $emit\nted by that component. To listen for a native DOM event on the root element, you can use the .native\nmodifier. For example:\n|\nUpgrade Path\nRun your end-to-end test suite, if you have one. The failed tests should alert to you to any parts of your app that may be affected by this change.\ndebounce\nParam Attribute for v-model\nremoved\nDebouncing is used to limit how often we execute Ajax requests and other expensive operations. Vue’s debounce\nattribute parameter for v-model\nmade this easy for very simple cases, but it actually debounced state updates rather than the expensive operations themselves. It’s a subtle difference, but it comes with limitations as an application grows.\nThese limitations become apparent when designing a search indicator, like this one for example:\nUsing the debounce\nattribute, there’d be no way to detect the “Typing” state, because we lose access to the input’s real-time state. By decoupling the debounce function from Vue however, we’re able to debounce only the operation we want to limit, removing the limits on features we can develop:\n|\n|\nAnother advantage of this approach is there will be times when debouncing isn’t quite the right wrapper function. For example, when hitting an API for search suggestions, waiting to offer suggestions until after the user has stopped typing for a period of time isn’t an ideal experience. What you probably want instead is a throttling function. Now since you’re already using a utility library like lodash, refactoring to use its throttle\nfunction instead takes only a few seconds.\nUpgrade Path\nRun the migration helper on your codebase to find examples of the debounce\nattribute.\nlazy\nor number\nParam Attributes for v-model\nreplaced\nThe lazy\nand number\nparam attributes are now modifiers, to make it more clear what That means instead of:\n|\nYou would use:\n|\nUpgrade Path\nRun the migration helper on your codebase to find examples of the these param attributes.\nvalue\nAttribute with v-model\nremoved\nv-model\nno longer cares about the initial value of an inline value\nattribute. For predictability, it will instead always treat the Vue instance data as the source of truth.\nThat means this element:\n|\nbacked by this data:\n|\nwill render with a value of “bar” instead of “foo”. The same goes for a <textarea>\nwith existing content. Instead of:\n|\nYou should ensure your initial value for text\nis “hello world”.\nUpgrade Path\nRun your end-to-end test suite or app after upgrading and look for console warnings about inline value attributes with v-model\n.\nv-model\nwith v-for\nIterated Primitive Values removed\nCases like this no longer work:\n|\nThe reason is this is the equivalent JavaScript that the <input>\nwould compile to:\n|\nAs you can see, v-model\n‘s two-way binding doesn’t make sense here. Setting str\nto another value in the iterator function will do nothing because it’s only a local variable in the function scope.\nInstead, you should use an array of objects so that v-model\ncan update the field on the object. For example:\n|\nUpgrade Path\nRun your test suite, if you have one. The failed tests should alert to you to any parts of your app that may be affected by this change.\nv-bind:style\nwith Object Syntax and !important\nremoved\nThis will no longer work:\n|\nIf you really need to override another !important\n, you must use the string syntax:\n|\nUpgrade Path\nRun the migration helper on your codebase to find examples of style bindings with !important\nin objects.\nv-el\nand v-ref\nreplaced\nFor simplicity, v-el\nand v-ref\nhave been merged into the ref\nattribute, accessible on a component instance via $refs\n. That means v-el:my-element\nwould become ref=\"myElement\"\nand v-ref:my-component\nwould become ref=\"myComponent\"\n. When used on a normal element, the ref\nwill be the DOM element, and when used on a component, the ref\nwill be the component instance.\nSince v-ref\nis no longer a directive, but a special attribute, it can also be dynamically defined. This is especially useful in combination with v-for\n. For example:\n|\nPreviously, v-el\n/v-ref\ncombined with v-for\nwould produce an array of elements/components, because there was no way to give each item a unique name. You can still achieve this behavior by giving each item the same ref\n:\n|\nUnlike in 1.x, these $refs\nare not reactive, because they’re registered/updated during the render process itself. Making them reactive would require duplicate renders for every change.\nOn the other hand, $refs\nare designed primarily for programmatic access in JavaScript - it is not recommended to rely on them in templates, because that would mean referring to state that does not belong to the instance itself. This would violate Vue’s data-driven view model.\nUpgrade Path\nRun the migration helper on your codebase to find examples of v-el\nand v-ref\n.\nv-else\nwith v-show\nremoved\nv-else\nno longer works with v-show\n. Use v-if\nwith a negation expression instead. For example, instead of:\n|\nYou can use:\n|\nUpgrade Path\nRun the migration helper on your codebase to find examples of the v-else\nwith v-show\n.\nCustom Directives simplified\nDirectives have a greatly reduced scope of responsibility: they are now only used for applying low-level direct DOM manipulations. In most cases, you should prefer using components as the main code-reuse abstraction.\nSome of the most notable differences include:\n- Directives no longer have instances. This means there’s no more\nthis\ninside directive hooks. Instead, they receive everything they might need as arguments. If you really must persist state across hooks, you can do so onel\n. - Options such as\nacceptStatement\n,deep\n,priority\n, etc have all been removed. To replacetwoWay\ndirectives, see this example. - Some of the current hooks have different behavior and there are also a couple new hooks.\nFortunately, since the new directives are much simpler, you can master them more easily. Read the new Custom Directives guide to learn more.\nUpgrade Path\nRun the migration helper on your codebase to find examples of defined directives. The helper will flag all of them, as it's likely in most cases that you'll want to refactor to a component.\nDirective .literal\nModifier removed\nThe .literal\nmodifier has been removed, as the same can be easily achieved by providing a string literal as the value.\nFor example, you can update:\n|\nto:\n|\nUpgrade Path\nRun the migration helper on your codebase to find examples of the `.literal` modifier on a directive.\nTransitions\ntransition\nAttribute replaced\nVue’s transition system has changed quite drastically and now uses <transition>\nand <transition-group>\nwrapper elements, rather than the transition\nattribute. It’s recommended to read the new Transitions guide to learn more.\nUpgrade Path\nRun the migration helper on your codebase to find examples of the transition\nattribute.\nVue.transition\nfor Reusable Transitions replaced\nWith the new transition system, you can now use components for reusable transitions.\nUpgrade Path\nRun the migration helper on your codebase to find examples of Vue.transition\n.\nTransition stagger\nAttribute removed\nIf you need to stagger list transitions, you can control timing by setting and accessing a data-index\n(or similar attribute) on an element. See an example here.\nUpgrade Path\nRun the migration helper on your codebase to find examples of the transition\nattribute. During your update, you can transition (pun very much intended) to the new staggering strategy as well.\nEvents\nevents\noption removed\nThe events\noption has been removed. Event handlers should now be registered in the created\nhook instead. Check out the $dispatch\nand $broadcast\nmigration guide for a detailed example.\nVue.directive('on').keyCodes\nreplaced\nThe new, more concise way to configure keyCodes\nis through Vue.config.keyCodes\n. For example:\n|\nUpgrade Path\nRun the migration helper on your codebase to find examples of the the old keyCode\nconfiguration syntax.\n$dispatch\nand $broadcast\nreplaced\n$dispatch\nand $broadcast\nhave been removed in favor of more explicitly cross-component communication and more maintainable state management solutions, such as Vuex.\nThe problem is event flows that depend on a component’s tree structure can be hard to reason about and are very brittle when the tree becomes large. They don’t scale well and only set you up for pain later. $dispatch\nand $broadcast\nalso do not solve communication between sibling components.\nOne of the most common uses for these methods is to communicate between a parent and its direct children. In these cases, you can actually listen to an $emit\nfrom a child with v-on\n. This allows you to keep the convenience of events with added explicitness.\nHowever, when communicating between distant descendants/ancestors, $emit\nwon’t help you. Instead, the simplest possible upgrade would be to use a centralized event hub. This has the added benefit of allowing you to communicate between components no matter where they are in the component tree - even between siblings! Because Vue instances implement an event emitter interface, you can actually use an empty Vue instance for this purpose.\nFor example, let’s say we have a todo app structured like this:\n|\nWe could manage communication between components with this single event hub:\n|\nThen in our components, we can use $emit\n, $on\n, $off\nto emit events, listen for events, and clean up event listeners, respectively:\n|\n|\n|\nThis pattern can serve as a replacement for $dispatch\nand $broadcast\nin simple scenarios, but for more complex cases, it’s recommended to use a dedicated state management layer such as Vuex.\nUpgrade Path\nRun the migration helper on your codebase to find examples of $dispatch\nand $broadcast\n.\nFilters\nFilters Outside Text Interpolations removed\nFilters can now only be used inside text interpolations ({{ }}\ntags). In the past we’ve found using filters within directives such as v-model\n, v-on\n, etc led to more complexity than convenience. For list filtering on v-for\n, it’s also better to move that logic into JavaScript as computed properties, so that it can be reused throughout your component.\nIn general, whenever something can be achieved in plain JavaScript, we want to avoid introducing a special syntax like filters to take care of the same concern. Here’s how you can replace Vue’s built-in directive filters:\nReplacing the debounce\nFilter\nInstead of:\n|\n|\nUse lodash’s debounce\n(or possibly throttle\n) to directly limit calling the expensive method. You can achieve the same as above like this:\n|\n|\nFor more on the advantages of this strategy, see the example here with v-model\n.\nReplacing the limitBy\nFilter\nInstead of:\n|\nUse JavaScript’s built-in .slice\nmethod in a computed property:\n|\n|\nReplacing the filterBy\nFilter\nInstead of:\n|\nUse JavaScript’s built-in .filter\nmethod in a computed property:\n|\n|\nJavaScript’s native .filter\ncan also manage much more complex filtering operations, because you have access to the full power of JavaScript within computed properties. For example, if you wanted to find all active users and case-insensitively match against both their name and email:\n|\nReplacing the orderBy\nFilter\nInstead of:\n|\nUse lodash’s orderBy\n(or possibly sortBy\n) in a computed property:\n|\n|\nYou can even order by multiple columns:\n|\nUpgrade Path\nRun the migration helper on your codebase to find examples of filters being used inside directives. If you miss any, you should also see console errors.\nFilter Argument Syntax changed\nFilters’ syntax for arguments now better aligns with JavaScript function invocation. So instead of taking space-delimited arguments:\n|\nWe surround the arguments with parentheses and delimit the arguments with commas:\n|\nUpgrade Path\nRun the migration helper on your codebase to find examples of the old filter syntax. If you miss any, you should also see console errors.\nBuilt-In Text Filters removed\nAlthough filters within text interpolations are still allowed, all of the filters have been removed. Instead, it’s recommended to use more specialized libraries for solving problems in each domain (e.g. date-fns\nto format dates and accounting\nfor currencies).\nFor each of Vue’s built-in text filters, we go through how you can replace them below. The example code could exist in custom helper functions, methods, or computed properties.\nReplacing the json\nFilter\nYou actually don’t need to for debugging anymore, as Vue will nicely format output for you automatically, whether it’s a string, number, array, or plain object. If you want the exact same functionality as JavaScript’s JSON.stringify\nthough, then you can use that in a method or computed property.\nReplacing the capitalize\nFilter\n|\nReplacing the uppercase\nFilter\n|\nReplacing the lowercase\nFilter\n|\nReplacing the pluralize\nFilter\nThe pluralize package on NPM serves this purpose nicely, but if you only want to pluralize a specific word or want to have special output for cases like 0\n, then you can also easily define your own pluralize functions. For example:\n|\nReplacing the currency\nFilter\nFor a very naive implementation, you could do something like this:\n|\nIn many cases though, you’ll still run into strange behavior (e.g. 0.035.toFixed(2)\nrounds up to 0.04\n, but 0.045\nrounds down to 0.04\n). To work around these issues, you can use the accounting\nlibrary to more reliably format currencies.\nUpgrade Path\nRun the migration helper on your codebase to find examples of the obsolete text filters. If you miss any, you should also see console errors.\nTwo-Way Filters replaced\nSome users have enjoyed using two-way filters with v-model\nto create interesting inputs with very little code. While seemingly simple however, two-way filters can also hide a great deal of complexity - and even encourage poor UX by delaying state updates. Instead, components wrapping an input are recommended as a more explicit and feature-rich way of creating custom inputs.\nAs an example, we’ll now walk the migration of a two-way currency filter:\nIt mostly works well, but the delayed state updates can cause strange behavior. For example, try entering 9.999\ninto one of those inputs. When the input loses focus, its value will update to $10.00\n. When looking at the calculated total however, you’ll see that 9.999\nis what’s stored in our data. The version of reality that the user sees is out of sync!\nTo start transitioning towards a more robust solution using Vue 2.0, let’s first wrap this filter in a new <currency-input>\ncomponent:\nThis allows us add behavior that a filter alone couldn’t encapsulate, such as selecting the content of an input on focus. Now the next step will be to extract the business logic from the filter. Below, we pull everything out into an external currencyValidator\nobject:\nThis increased modularity not only makes it easier to migrate to Vue 2, but also allows currency parsing and formatting to be:\n- unit tested in isolation from your Vue code\n- used by other parts of your application, such as to validate the payload to an API endpoint\nHaving this validator extracted out, we’ve also more comfortably built it up into a more robust solution. The state quirks have been eliminated and it’s actually impossible for users to enter anything wrong, similar to what the browser’s native number input tries to do.\nWe’re still limited however, by filters and by Vue 1.0 in general, so let’s complete the upgrade to Vue 2.0:\nYou may notice that:\n- Every aspect of our input is more explicit, using lifecycle hooks and DOM events in place of the hidden behavior of two-way filters.\n- We can now use\nv-model\ndirectly on our custom inputs, which is not only more consistent with normal inputs, but also means our component is Vuex-friendly. - Since we’re no longer using filter options that require a value to be returned, our currency work could actually be done asynchronously. That means if we had a lot of apps that had to work with currencies, we could easily refactor this logic into a shared microservice.\nUpgrade Path\nRun the migration helper on your codebase to find examples of filters used in directives like v-model\n. If you miss any, you should also see console errors.\nSlots\nDuplicate Slots removed\nIt is no longer supported to have <slot>\ns with the same name in the same template. When a slot is rendered it is “used up” and cannot be rendered elsewhere in the same render tree. If you must render the same content in multiple places, pass that content as a prop.\nUpgrade Path\nRun your end-to-end test suite or app after upgrading and look for console warnings about duplicate slots v-model\n.\nslot\nAttribute Styling removed\nContent inserted via named <slot>\nno longer preserves the slot\nattribute. Use a wrapper element to style them, or for advanced use cases, modify the inserted content programmatically using render functions.\nUpgrade Path\nRun the migration helper on your codebase to find CSS selectors targeting named slots (e.g. [slot=\"my-slot-name\"]\n).\nSpecial Attributes\nkeep-alive\nAttribute replaced\nkeep-alive\nis no longer a special attribute, but rather a wrapper component, similar to <transition>\n. For example:\n|\nThis makes it possible to use <keep-alive>\non multiple conditional children:\n|\nWhen <keep-alive>\nhas multiple children, they should eventually evaluate to a single child. Any child other than the first one will be ignored.\nWhen used together with <transition>\n, make sure to nest it inside:\n|\nUpgrade Path\nRun the migration helper on your codebase to find keep-alive\nattributes.\nInterpolation\nInterpolation within Attributes removed\nInterpolation within attributes is no longer valid. For example:\n|\nShould either be updated to use an inline expression:\n|\nOr a data/computed property:\n|\n|\nUpgrade Path\nRun the migration helper on your codebase to find examples of interpolation used within attributes.\nHTML Interpolation removed\nHTML interpolations ({{{ foo }}}\n) have been removed in favor of the v-html\ndirective.\nUpgrade Path\nRun the migration helper on your codebase to find HTML interpolations.\nOne-Time Bindings replaced\nOne time bindings ({{* foo }}\n) have been replaced by the new v-once\ndirective.\nUpgrade Path\nRun the migration helper on your codebase to find one-time bindings.\nReactivity\nvm.$watch\nchanged\nWatchers created via vm.$watch\nare now fired before the associated component rerenders. This gives you the chance to further update state before the component rerender, thus avoiding unnecessary updates. For example, you can watch a component prop and update the component’s own data when the prop changes.\nIf you were previously relying on vm.$watch\nto do something with the DOM after a component updates, you can instead do so in the updated\nlifecycle hook.\nUpgrade Path\nRun your end-to-end test suite, if you have one. The failed tests should alert to you to the fact that a watcher was relying on the old behavior.\nvm.$set\nchanged\nvm.$set\nis now an alias for Vue.set\n.\nUpgrade Path\nRun the migration helper on your codebase to find examples of the obsolete usage.\nvm.$delete\nchanged\nvm.$delete\nis now an alias for Vue.delete\n.\nUpgrade Path\nRun the migration helper on your codebase to find examples of the obsolete usage.\nArray.prototype.$set\nremoved\nUse Vue.set\ninstead.\nUpgrade Path\nRun the migration helper on your codebase to find examples of .$set\non an array. If you miss any, you should see console errors from the missing method.\nArray.prototype.$remove\nremoved\nUse Array.prototype.splice\ninstead. For example:\n|\nOr better yet, pass removal methods an index:\n|\nUpgrade Path\nRun the migration helper on your codebase to find examples of .$remove\non an array. If you miss any, you should see console errors from the missing method.\nVue.set\nand Vue.delete\non Vue instances removed\nVue.set\nand Vue.delete\ncan no longer work on Vue instances. It is now mandatory to properly declare all top-level reactive properties in the data option. If you’d like to delete properties on a Vue instance or its $data\n, set it to null.\nUpgrade Path\nRun the migration helper on your codebase to find examples of Vue.set\nor Vue.delete\non a Vue instance. If you miss any, they'll trigger console warnings.\nReplacing vm.$data\nremoved\nIt is now prohibited to replace a component instance’s root $data. This prevents some edge cases in the reactivity system and makes the component state more predictable (especially with type-checking systems).\nUpgrade Path\nRun the migration helper on your codebase to find examples of overwriting vm.$data\n. If you miss any, console warnings will be emitted.\nvm.$get\nremoved\nInstead, retrieve reactive data directly.\nUpgrade Path\nRun the migration helper on your codebase to find examples of vm.$get\n. If you miss any, you'll see console errors.\nDOM-Focused Instance Methods\nvm.$appendTo\nremoved\nUse the native DOM API:\n|\nUpgrade Path\nRun the migration helper on your codebase to find examples of vm.$appendTo\n. If you miss any, you'll see console errors.\nvm.$before\nremoved\nUse the native DOM API:\n|\nUpgrade Path\nRun the migration helper on your codebase to find examples of vm.$before\n. If you miss any, you'll see console errors.\nvm.$after\nremoved\nUse the native DOM API:\n|\nOr if myElement\nis the last child:\n|\nUpgrade Path\nRun the migration helper on your codebase to find examples of vm.$after\n. If you miss any, you'll see console errors.\nvm.$remove\nremoved\nUse the native DOM API:\n|\nUpgrade Path\nRun the migration helper on your codebase to find examples of vm.$remove\n. If you miss any, you'll see console errors.\nMeta Instance Methods\nvm.$eval\nremoved\nNo real use. If you do happen to rely on this feature somehow and aren’t sure how to work around it, post on the forum for ideas.\nUpgrade Path\nRun the migration helper on your codebase to find examples of vm.$eval\n. If you miss any, you'll see console errors.\nvm.$interpolate\nremoved\nNo real use. If you do happen to rely on this feature somehow and aren’t sure how to work around it, post on the forum for ideas.\nUpgrade Path\nRun the migration helper on your codebase to find examples of vm.$interpolate\n. If you miss any, you'll see console errors.\nvm.$log\nremoved\nUse the Vue Devtools for the optimal debugging experience.\nUpgrade Path\nRun the migration helper on your codebase to find examples of vm.$log\n. If you miss any, you'll see console errors.\nInstance DOM Options\nreplace: false\nremoved\nComponents now always replace the element they’re bound to. To simulate the behavior of replace: false\n, you can wrap your root component with an element similar to the one you’re replacing. For example:\n|\nOr with a render function:\n|\nUpgrade Path\nRun the migration helper on your codebase to find examples of replace: false\n.\nGlobal Config\nVue.config.debug\nremoved\nNo longer necessary, since warnings come with stack traces by default now.\nUpgrade Path\nRun the migration helper on your codebase to find examples of Vue.config.debug\n.\nVue.config.async\nremoved\nAsync is now required for rendering performance.\nUpgrade Path\nRun the migration helper on your codebase to find examples of Vue.config.async\n.\nVue.config.delimiters\nreplaced\nThis has been reworked as a component-level option. This allows you to use alternative delimiters within your app without breaking 3rd-party components.\nUpgrade Path\nRun the migration helper on your codebase to find examples of Vue.config.delimiters\n.\nVue.config.unsafeDelimiters\nremoved\nHTML interpolation has been removed in favor of v-html\n.\nUpgrade Path\nRun the migration helper on your codebase to find examples of Vue.config.unsafeDelimiters\n. After this, the helper will also find instances of HTML interpolation so that you can replace them with `v-html`.\nGlobal API\nVue.extend\nwith el\nremoved\nThe el option can no longer be used in Vue.extend\n. It’s only valid as an instance creation option.\nUpgrade Path\nRun your end-to-end test suite or app after upgrading and look for console warnings about the el\noption with Vue.extend\n.\nVue.elementDirective\nremoved\nUse components instead.\nUpgrade Path\nRun the migration helper on your codebase to find examples of Vue.elementDirective\n.\nVue.partial\nremoved\nPartials have been removed in favor of more explicit data flow between components, using props. Unless you’re using a partial in a performance-critical area, the recommendation is to use a normal component instead. If you were dynamically binding the name\nof a partial, you can use a dynamic component.\nIf you happen to be using partials in a performance-critical part of your app, then you should upgrade to functional components. They must be in a plain JS/JSX file (rather than in a .vue\nfile) and are stateless and instanceless, like partials. This makes rendering extremely fast.\nA benefit of functional components over partials is that they can be much more dynamic, because they grant you access to the full power of JavaScript. There is a cost to this power however. If you’ve never used a component framework with render functions before, they may take a bit longer to learn.\nUpgrade Path\nRun the migration helper on your codebase to find examples of Vue.partial\n.",
    "metadata": {
      "source": "https://v2.vuejs.org/v2/guide/migration",
      "title": "Migration from Vue 1.x — Vue.js"
    }
  },
  {
    "page_content": "API Documentation\nAPI Documentation\nEnumerations\nInterfaces\n- HistoryState\n- LocationAsRelativeRaw\n- MatcherLocation\n- MatcherLocationAsPath\n- NavigationFailure\n- NavigationGuard\n- NavigationGuardNext\n- NavigationGuardWithThis\n- NavigationHookAfter\n- NavigationRedirectError\n- RouteLocationAsPathGeneric\n- RouteLocationAsPathTyped\n- RouteLocationAsRelativeGeneric\n- RouteLocationAsRelativeTyped\n- RouteLocationGeneric\n- RouteLocationMatched\n- RouteLocationNamedRaw\n- RouteLocationNormalizedGeneric\n- RouteLocationNormalizedLoadedGeneric\n- RouteLocationNormalizedLoadedTyped\n- RouteLocationNormalizedTyped\n- RouteLocationOptions\n- RouteLocationPathRaw\n- RouteLocationResolvedGeneric\n- RouteLocationResolvedTyped\n- RouteLocationTyped\n- RouteMeta\n- RouteQueryAndHash\n- RouteRecordInfo\n- RouteRecordMultipleViews\n- RouteRecordMultipleViewsWithChildren\n- RouteRecordNormalized\n- RouteRecordRedirect\n- RouteRecordSingleView\n- RouteRecordSingleViewWithChildren\n- Router\n- RouterHistory\n- RouterLinkProps\n- RouterMatcher\n- RouterOptions\n- RouterScrollBehavior\n- RouterViewProps\n- TypesConfig\n- UseLinkOptions\n- UseLinkReturn\n- _PathParserOptions\n- _RouteLocationBase\n- _RouteRecordBase\n- _RouterLinkI\nType Aliases\nLocationQuery\nƬ LocationQuery: Record\n<string\n, LocationQueryValue\n| LocationQueryValue\n[]>\nNormalized query object that appears in RouteLocationNormalized\nLocationQueryRaw\nƬ LocationQueryRaw: Record\n<string\n| number\n, LocationQueryValueRaw\n| LocationQueryValueRaw\n[]>\nLoose LocationQuery object that can be passed to functions like Router.push and Router.replace or anywhere when creating a RouteLocationRaw\nLocationQueryValue\nƬ LocationQueryValue: string\n| null\nPossible values in normalized LocationQuery. null\nrenders the query param but without an =\n.\nExample\n?isNull&isEmpty=&other=other\ngives\n`{ isNull: null, isEmpty: '', other: 'other' }`.\nLocationQueryValueRaw\nƬ LocationQueryValueRaw: LocationQueryValue\n| number\n| undefined\nPossible values when defining a query.\nNavigationGuardNextCallback\nƬ NavigationGuardNextCallback: (vm\n: ComponentPublicInstance\n) => unknown\nCallback that can be passed to next()\nin beforeRouteEnter()\nguards.\nType declaration\n▸ (vm\n): unknown\nParameters\nName | Type |\n---|---|\nvm | ComponentPublicInstance |\nReturns\nunknown\nNavigationGuardReturn\nƬ NavigationGuardReturn: void\n| Error\n| boolean\n| RouteLocationRaw\nReturn types for a Navigation Guard. Based on TypesConfig\nSee\nParamValue\nƬ ParamValue<isRaw\n>: true\nextends isRaw\n? string\n| number\n: string\nUtility type for raw and non raw params like :id\nType parameters\nName | Type |\n---|---|\nisRaw | extends boolean |\nParamValueOneOrMore\nƬ ParamValueOneOrMore<isRaw\n>: [ParamValue\n<isRaw\n>, ...ParamValue<isRaw>[]]\nUtility type for raw and non raw params like :id+\nType parameters\nName | Type |\n---|---|\nisRaw | extends boolean |\nParamValueZeroOrMore\nƬ ParamValueZeroOrMore<isRaw\n>: true\nextends isRaw\n? ParamValue\n<isRaw\n>[] | undefined\n| null\n: ParamValue\n<isRaw\n>[] | undefined\nUtility type for raw and non raw params like :id*\nType parameters\nName | Type |\n---|---|\nisRaw | extends boolean |\nParamValueZeroOrOne\nƬ ParamValueZeroOrOne<isRaw\n>: true\nextends isRaw\n? string\n| number\n| null\n| undefined\n: string\nUtility type for raw and non raw params like :id?\nType parameters\nName | Type |\n---|---|\nisRaw | extends boolean |\nPathParserOptions\nƬ PathParserOptions: Pick\n<_PathParserOptions\n, \"end\"\n| \"sensitive\"\n| \"strict\"\n>\nRouteComponent\nƬ RouteComponent: Component\n| DefineComponent\nAllowed Component in RouteLocationMatched\nRouteLocation\nƬ RouteLocation<Name\n>: RouteMapGeneric\nextends RouteMap\n? RouteLocationGeneric\n: RouteLocationTypedList\n<RouteMap\n>[Name\n]\nRouteLocationRaw resolved using the matcher\nType parameters\nName | Type |\n---|---|\nName | extends keyof RouteMap = keyof RouteMap |\nRouteLocationAsPath\nƬ RouteLocationAsPath<Name\n>: RouteMapGeneric\nextends RouteMap\n? RouteLocationAsPathGeneric\n: RouteLocationAsPathTypedList\n<RouteMap\n>[Name\n]\nRoute location as an object with a path\nproperty.\nType parameters\nName | Type |\n---|---|\nName | extends keyof RouteMap = keyof RouteMap |\nRouteLocationAsPathTypedList\nƬ RouteLocationAsPathTypedList<RouteMap\n>: { [N in keyof RouteMap]: RouteLocationAsPathTyped<RouteMap, N> }\nList of all possible RouteLocationAsPath indexed by the route name.\nType parameters\nName | Type |\n---|---|\nRouteMap | extends RouteMapGeneric = RouteMapGeneric |\nRouteLocationAsRelative\nƬ RouteLocationAsRelative<Name\n>: RouteMapGeneric\nextends RouteMap\n? RouteLocationAsRelativeGeneric\n: RouteLocationAsRelativeTypedList\n<RouteMap\n>[Name\n]\nRoute location relative to the current location. It accepts other properties than path\nlike params\n, query\nand hash\nto conveniently change them.\nType parameters\nName | Type |\n---|---|\nName | extends keyof RouteMap = keyof RouteMap |\nRouteLocationAsRelativeTypedList\nƬ RouteLocationAsRelativeTypedList<RouteMap\n>: { [N in keyof RouteMap]: RouteLocationAsRelativeTyped<RouteMap, N> }\nList of all possible RouteLocationAsRelative indexed by the route name.\nType parameters\nName | Type |\n---|---|\nRouteMap | extends RouteMapGeneric = RouteMapGeneric |\nRouteLocationAsString\nƬ RouteLocationAsString<Name\n>: RouteMapGeneric\nextends RouteMap\n? string\n: _LiteralUnion\n<RouteLocationAsStringTypedList\n<RouteMap\n>[Name\n], string\n>\nSame as RouteLocationAsPath but as a string literal.\nType parameters\nName | Type |\n---|---|\nName | extends keyof RouteMap = keyof RouteMap |\nRouteLocationAsStringTyped\nƬ RouteLocationAsStringTyped<RouteMap\n, Name\n>: RouteMap\n[Name\n][\"path\"\n]\nHelper to generate a type safe version of the RouteLocationAsString type.\nType parameters\nName | Type |\n---|---|\nRouteMap | extends RouteMapGeneric = RouteMapGeneric |\nName | extends keyof RouteMap = keyof RouteMap |\nRouteLocationAsStringTypedList\nƬ RouteLocationAsStringTypedList<RouteMap\n>: { [N in keyof RouteMap]: RouteLocationAsStringTyped<RouteMap, N> }\nList of all possible RouteLocationAsString indexed by the route name.\nType parameters\nName | Type |\n---|---|\nRouteMap | extends RouteMapGeneric = RouteMapGeneric |\nRouteLocationNormalized\nƬ RouteLocationNormalized<Name\n>: RouteMapGeneric\nextends RouteMap\n? RouteLocationNormalizedGeneric\n: RouteLocationNormalizedTypedList\n<RouteMap\n>[Name\n]\nSimilar to RouteLocation but its matched\nproperty cannot contain redirect records\nType parameters\nName | Type |\n---|---|\nName | extends keyof RouteMap = keyof RouteMap |\nRouteLocationNormalizedLoaded\nƬ RouteLocationNormalizedLoaded<Name\n>: RouteMapGeneric\nextends RouteMap\n? RouteLocationNormalizedLoadedGeneric\n: RouteLocationNormalizedLoadedTypedList\n<RouteMap\n>[Name\n]\nSimilar to RouteLocationNormalized but its components\ndo not contain any function to lazy load components. In other words, it's ready to be rendered by <RouterView>\n.\nType parameters\nName | Type |\n---|---|\nName | extends keyof RouteMap = keyof RouteMap |\nRouteLocationNormalizedLoadedTypedList\nƬ RouteLocationNormalizedLoadedTypedList<RouteMap\n>: { [N in keyof RouteMap]: RouteLocationNormalizedLoadedTyped<RouteMap, N> }\nList of all possible RouteLocationNormalizedLoaded indexed by the route name.\nType parameters\nName | Type |\n---|---|\nRouteMap | extends RouteMapGeneric = RouteMapGeneric |\nRouteLocationNormalizedTypedList\nƬ RouteLocationNormalizedTypedList<RouteMap\n>: { [N in keyof RouteMap]: RouteLocationNormalizedTyped<RouteMap, N> }\nList of all possible RouteLocationNormalized indexed by the route name.\nType parameters\nName | Type |\n---|---|\nRouteMap | extends RouteMapGeneric = RouteMapGeneric |\nRouteLocationRaw\nƬ RouteLocationRaw<Name\n>: RouteMapGeneric\nextends RouteMap\n? RouteLocationAsString\n| RouteLocationAsRelativeGeneric\n| RouteLocationAsPathGeneric\n: _LiteralUnion\n<RouteLocationAsStringTypedList\n<RouteMap\n>[Name\n], string\n> | RouteLocationAsRelativeTypedList\n<RouteMap\n>[Name\n] | RouteLocationAsPathTypedList\n<RouteMap\n>[Name\n]\nRoute location that can be passed to router.push()\nand other user-facing APIs.\nType parameters\nName | Type |\n---|---|\nName | extends keyof RouteMap = keyof RouteMap |\nRouteLocationResolved\nƬ RouteLocationResolved<Name\n>: RouteMapGeneric\nextends RouteMap\n? RouteLocationResolvedGeneric\n: RouteLocationResolvedTypedList\n<RouteMap\n>[Name\n]\nRoute location resolved with router.resolve()\n.\nType parameters\nName | Type |\n---|---|\nName | extends keyof RouteMap = keyof RouteMap |\nRouteLocationResolvedTypedList\nƬ RouteLocationResolvedTypedList<RouteMap\n>: { [N in keyof RouteMap]: RouteLocationResolvedTyped<RouteMap, N> }\nList of all possible RouteLocationResolved indexed by the route name.\nType parameters\nName | Type |\n---|---|\nRouteMap | extends RouteMapGeneric = RouteMapGeneric |\nRouteLocationTypedList\nƬ RouteLocationTypedList<RouteMap\n>: { [N in keyof RouteMap]: RouteLocationTyped<RouteMap, N> }\nList of all possible RouteLocation indexed by the route name.\nType parameters\nName | Type |\n---|---|\nRouteMap | extends RouteMapGeneric = RouteMapGeneric |\nRouteMap\nƬ RouteMap: TypesConfig\nextends Record\n<\"RouteNamedMap\"\n, infer RouteNamedMap> ? RouteNamedMap\n: RouteMapGeneric\nConvenience type to get the typed RouteMap or a generic one if not provided. It is extracted from the TypesConfig if it exists, it becomes RouteMapGeneric otherwise.\nRouteMapGeneric\nƬ RouteMapGeneric: Record\n<string\n| symbol\n, RouteRecordInfo\n>\nGeneric version of the RouteMap\n.\nRouteParamValue\nƬ RouteParamValue: string\nRouteParamValueRaw\nƬ RouteParamValueRaw: RouteParamValue\n| number\n| null\n| undefined\nRouteParams\nƬ RouteParams<Name\n>: RouteMap\n[Name\n][\"params\"\n]\nGenerate a type safe params for a route location. Requires the name of the route to be passed as a generic.\nSee\nType parameters\nName | Type |\n---|---|\nName | extends keyof RouteMap = keyof RouteMap |\nRouteParamsGeneric\nƬ RouteParamsGeneric: Record\n<string\n, RouteParamValue\n| RouteParamValue\n[]>\nRouteParamsRaw\nƬ RouteParamsRaw<Name\n>: RouteMap\n[Name\n][\"paramsRaw\"\n]\nGenerate a type safe raw params for a route location. Requires the name of the route to be passed as a generic.\nSee\nType parameters\nName | Type |\n---|---|\nName | extends keyof RouteMap = keyof RouteMap |\nRouteParamsRawGeneric\nƬ RouteParamsRawGeneric: Record\n<string\n, RouteParamValueRaw\n| Exclude\n<RouteParamValueRaw\n, null\n| undefined\n>[]>\nRouteRecord\nƬ RouteRecord: RouteRecordNormalized\nNormalized version of a route record.\nRouteRecordName\nƬ RouteRecordName: RouteMapGeneric\nextends RouteMap\n? RouteRecordNameGeneric\n: keyof RouteMap\nPossible values for a route record after normalization\nNOTE: since RouteRecordName\nis a type, it evaluates too early and it's often the generic version RouteRecordNameGeneric. If you need a typed version of all of the names of routes, use keyof RouteMap\nRouteRecordNameGeneric\nƬ RouteRecordNameGeneric: string\n| symbol\n| undefined\nGeneric version of RouteRecordName.\nRouteRecordRaw\nƬ RouteRecordRaw: RouteRecordSingleView\n| RouteRecordSingleViewWithChildren\n| RouteRecordMultipleViews\n| RouteRecordMultipleViewsWithChildren\n| RouteRecordRedirect\nRouteRecordRedirectOption\nƬ RouteRecordRedirectOption: RouteLocationRaw\n| (to\n: RouteLocation\n) => RouteLocationRaw\n_Awaitable\nƬ _Awaitable<T\n>: T\n| PromiseLike\n<T\n>\nMaybe a promise maybe not\nType parameters\nName |\n---|\nT |\n_RouteMetaBase\nƬ _RouteMetaBase: Record\n<string\n| number\n| symbol\n, unknown\n>\nDefault type for RouteMeta when not augmented.\n_RouteRecordProps\nƬ _RouteRecordProps<Name\n>: boolean\n| Record\n<string\n, any\n> | (to\n: RouteLocationNormalized\n<Name\n>) => Record\n<string\n, any\n>\nType parameters\nName | Type |\n---|---|\nName | extends keyof RouteMap = keyof RouteMap |\nVariables\nRouterLink\n• Const\nRouterLink: _RouterLinkI\nComponent to render a link that triggers a navigation on click.\nRouterView\n• Const\nRouterView: () => { $props\n: AllowedComponentProps\n& ComponentCustomProps\n& VNodeProps\n& RouterViewProps\n; $slots\n: { default?\n: (__namedParameters\n: { Component\n: VNode\n<RendererNode\n, RendererElement\n, { [key: string]\n: any\n; }> ; route\n: RouteLocationNormalizedLoadedGeneric\n}) => VNode\n<RendererNode\n, RendererElement\n, { [key: string]\n: any\n; }>[] } }\nComponent to display the current route the user is at.\nType declaration\n• new RouterView(): Object\nComponent to display the current route the user is at.\nReturns\nObject\nName | Type |\n---|---|\n$props | AllowedComponentProps & ComponentCustomProps & VNodeProps & RouterViewProps |\n$slots | { default? : (__namedParameters : { Component : VNode <RendererNode , RendererElement , { [key: string] : any ; }> ; route : RouteLocationNormalizedLoadedGeneric }) => VNode <RendererNode , RendererElement , { [key: string] : any ; }>[] } |\n$slots.default? | (__namedParameters : { Component : VNode <RendererNode , RendererElement , { [key: string] : any ; }> ; route : RouteLocationNormalizedLoadedGeneric }) => VNode <RendererNode , RendererElement , { [key: string] : any ; }>[] |\nSTART_LOCATION\n• Const\nSTART_LOCATION: RouteLocationNormalizedLoaded\nInitial route location where the router is. Can be used in navigation guards to differentiate the initial navigation.\nExample\nimport { START_LOCATION } from 'vue-router'\nrouter.beforeEach((to, from) => {\nif (from === START_LOCATION) {\n// initial navigation\n}\n})\nmatchedRouteKey\n• Const\nmatchedRouteKey: InjectionKey\n<ComputedRef\n<undefined\n| RouteRecordNormalized\n>>\nRouteRecord being rendered by the closest ancestor Router View. Used for onBeforeRouteUpdate\nand onBeforeRouteLeave\n. rvlm stands for Router View Location Matched\nrouteLocationKey\n• Const\nrouteLocationKey: InjectionKey\n<RouteLocationNormalizedLoadedGeneric\n>\nAllows overriding the current route returned by useRoute\nin tests. rl stands for route location\nrouterKey\n• Const\nrouterKey: InjectionKey\n<Router\n>\nAllows overriding the router instance returned by useRouter\nin tests. r stands for router\nrouterViewLocationKey\n• Const\nrouterViewLocationKey: InjectionKey\n<Ref\n<RouteLocationNormalizedLoadedGeneric\n>>\nAllows overriding the current route used by router-view. Internally this is used when the route\nprop is passed.\nviewDepthKey\n• Const\nviewDepthKey: InjectionKey\n<number\n| Ref\n<number\n>>\nAllows overriding the router view depth to control which component in matched\nis rendered. rvd stands for Router View Depth\nFunctions\ncreateMemoryHistory\n▸ createMemoryHistory(base?\n): RouterHistory\nCreates an in-memory based history. The main purpose of this history is to handle SSR. It starts in a special location that is nowhere. It's up to the user to replace that location with the starter location by either calling router.push\nor router.replace\n.\nParameters\nName | Type | Default value | Description |\n---|---|---|---|\nbase | string | '' | Base applied to all urls, defaults to '/' |\nReturns\na history object that can be passed to the router constructor\ncreateRouter\n▸ createRouter(options\n): Router\nCreates a Router instance that can be used by a Vue app.\nParameters\nName | Type | Description |\n---|---|---|\noptions | RouterOptions | RouterOptions |\nReturns\ncreateRouterMatcher\n▸ createRouterMatcher(routes\n, globalOptions\n): RouterMatcher\nCreates a Router Matcher.\nParameters\nName | Type | Description |\n---|---|---|\nroutes | readonly RouteRecordRaw [] | array of initial routes |\nglobalOptions | PathParserOptions | global route options |\nReturns\ncreateWebHashHistory\n▸ createWebHashHistory(base?\n): RouterHistory\nCreates a hash history. Useful for web applications with no host (e.g. file://\n) or when configuring a server to handle any URL is not possible.\nParameters\nName | Type | Description |\n---|---|---|\nbase? | string | optional base to provide. Defaults to location.pathname + location.search If there is a <base> tag in the head , its value will be ignored in favor of this parameter but note it affects all the history.pushState() calls, meaning that if you use a <base> tag, it's href value has to match this parameter (ignoring anything after the # ). |\nReturns\nExample\n// at https://example.com/folder\ncreateWebHashHistory() // gives a url of `https://example.com/folder#`\ncreateWebHashHistory('/folder/') // gives a url of `https://example.com/folder/#`\n// if the `#` is provided in the base, it won't be added by `createWebHashHistory`\ncreateWebHashHistory('/folder/#/app/') // gives a url of `https://example.com/folder/#/app/`\n// you should avoid doing this because it changes the original url and breaks copying urls\ncreateWebHashHistory('/other-folder/') // gives a url of `https://example.com/other-folder/#`\n// at file:///usr/etc/folder/index.html\n// for locations with no `host`, the base is ignored\ncreateWebHashHistory('/iAmIgnored') // gives a url of `file:///usr/etc/folder/index.html#`\ncreateWebHistory\n▸ createWebHistory(base?\n): RouterHistory\nCreates an HTML5 history. Most common history for single page applications.\nParameters\nName | Type |\n---|---|\nbase? | string |\nReturns\nisNavigationFailure\n▸ isNavigationFailure(error\n, type?\n): error is NavigationRedirectError\nCheck if an object is a NavigationFailure.\nParameters\nName | Type | Description |\n---|---|---|\nerror | any | possible NavigationFailure |\ntype? | NAVIGATION_GUARD_REDIRECT | optional types to check for |\nReturns\nerror is NavigationRedirectError\nExample\nimport { isNavigationFailure, NavigationFailureType } from 'vue-router'\nrouter.afterEach((to, from, failure) => {\n// Any kind of navigation failure\nif (isNavigationFailure(failure)) {\n// ...\n}\n// Only duplicated navigations\nif (isNavigationFailure(failure, NavigationFailureType.duplicated)) {\n// ...\n}\n// Aborted or canceled navigations\nif (isNavigationFailure(failure, NavigationFailureType.aborted | NavigationFailureType.canceled)) {\n// ...\n}\n})\n▸ isNavigationFailure(error\n, type?\n): error is NavigationFailure\nParameters\nName | Type |\n---|---|\nerror | any |\ntype? | ErrorTypes | NavigationFailureType |\nReturns\nerror is NavigationFailure\nloadRouteLocation\n▸ loadRouteLocation(route\n): Promise\n<RouteLocationNormalizedLoaded\n>\nEnsures a route is loaded, so it can be passed as o prop to <RouterView>\n.\nParameters\nName | Type | Description |\n---|---|---|\nroute | RouteLocationNormalizedGeneric | RouteLocationGeneric | resolved route to load |\nReturns\nPromise\n<RouteLocationNormalizedLoaded\n>\nonBeforeRouteLeave\n▸ onBeforeRouteLeave(leaveGuard\n): void\nAdd a navigation guard that triggers whenever the component for the current location is about to be left. Similar to beforeRouteLeave but can be used in any component. The guard is removed when the component is unmounted.\nParameters\nName | Type | Description |\n---|---|---|\nleaveGuard | NavigationGuard | NavigationGuard |\nReturns\nvoid\nonBeforeRouteUpdate\n▸ onBeforeRouteUpdate(updateGuard\n): void\nAdd a navigation guard that triggers whenever the current location is about to be updated. Similar to beforeRouteUpdate but can be used in any component. The guard is removed when the component is unmounted.\nParameters\nName | Type | Description |\n---|---|---|\nupdateGuard | NavigationGuard | NavigationGuard |\nReturns\nvoid\nparseQuery\n▸ parseQuery(search\n): LocationQuery\nTransforms a queryString into a LocationQuery object. Accept both, a version with the leading ?\nand without Should work as URLSearchParams\nParameters\nName | Type | Description |\n---|---|---|\nsearch | string | search string to parse |\nReturns\na query object\nstringifyQuery\n▸ stringifyQuery(query\n): string\nStringifies a LocationQueryRaw object. Like URLSearchParams\n, it doesn't prepend a ?\nParameters\nName | Type | Description |\n---|---|---|\nquery | LocationQueryRaw | query object to stringify |\nReturns\nstring\nstring version of the query without the leading ?\nuseLink\n▸ useLink<Name\n>(props\n): UseLinkReturn\n<Name\n>\nReturns the internal behavior of a RouterLink without the rendering part.\nType parameters\nName | Type |\n---|---|\nName | extends string | symbol = string | symbol |\nParameters\nName | Type | Description |\n---|---|---|\nprops | UseLinkOptions <Name > | a to location and an optional replace flag |\nReturns\nUseLinkReturn\n<Name\n>\nuseRoute\n▸ useRoute<Name\n>(_name?\n): RouteLocationNormalizedLoaded\n<Name\n>\nReturns the current route location. Equivalent to using $route\ninside templates.\nType parameters\nName | Type |\n---|---|\nName | extends string | symbol = string | symbol |\nParameters\nName | Type |\n---|---|\n_name? | Name |\nReturns\nRouteLocationNormalizedLoaded\n<Name\n>\nuseRouter\n▸ useRouter(): Router\nReturns the router instance. Equivalent to using $router\ninside templates.",
    "metadata": {
      "source": "https://router.vuejs.org/api/",
      "title": "API Documentation | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / RouteLocationAsPathTyped\nInterface: RouteLocationAsPathTyped<RouteMap, Name>\nHelper to generate a type safe version of the RouteLocationAsPath type.\nType parameters\nName | Type |\n---|---|\nRouteMap | extends RouteMapGeneric = RouteMapGeneric |\nName | extends keyof RouteMap = keyof RouteMap |\nHierarchy\n↳\nRouteLocationAsPathTyped\nProperties\nforce\n• Optional\nforce: boolean\nTriggers the navigation even if the location is the same as the current one. Note this will also add a new entry to the history unless replace: true\nis passed.\nInherited from\nRouteLocationAsPathGeneric.force\nhash\n• Optional\nhash: string\nInherited from\nRouteLocationAsPathGeneric.hash\npath\n• path: _LiteralUnion\n<RouteMap\n[Name\n][\"path\"\n]>\nPercentage encoded pathname section of the URL.\nOverrides\nRouteLocationAsPathGeneric.path\nquery\n• Optional\nquery: LocationQueryRaw\nInherited from\nRouteLocationAsPathGeneric.query\nreplace\n• Optional\nreplace: boolean\nReplace the entry in the history instead of pushing a new entry\nInherited from\nRouteLocationAsPathGeneric.replace\nstate\n• Optional\nstate: HistoryState\nState to save using the History API. This cannot contain any reactive values and some primitives like Symbols are forbidden. More info at https://developer.mozilla.org/en-US/docs/Web/API/History/state",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/routelocationaspathtyped",
      "title": "Interface: RouteLocationAsPathTyped<RouteMap, Name> | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / MatcherLocation\nInterface: MatcherLocation\nNormalized/resolved Route location that returned by the matcher.\nProperties\nmatched\n• matched: RouteRecordNormalized\n[]\nArray of RouteRecord containing components as they were passed when adding records. It can also contain redirect records. This can't be used directly\nmeta\n• meta: RouteMeta\nMerged meta\nproperties from all the matched route records.\nname\n• name: null\n| RouteRecordNameGeneric\nName of the matched record\nparams\n• params: RouteParamsGeneric\nObject of decoded params extracted from the path\n.\npath\n• path: string\nPercentage encoded pathname section of the URL.",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/matcherlocation",
      "title": "Interface: MatcherLocation | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / UseLinkOptions\nInterface: UseLinkOptions<Name>\nOptions passed to useLink.\nType parameters\nName | Type |\n---|---|\nName | extends keyof RouteMap = keyof RouteMap |\nProperties\nreplace\n• Optional\nreplace: MaybeRef\n<undefined\n| boolean\n>\nto\n• to: MaybeRef\n<string\n| RouteLocationAsRelativeGeneric\n| RouteLocationAsPathGeneric\n| RouteLocationAsRelativeTyped\n<RouteMapGeneric\n, Name\n>>",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/uselinkoptions",
      "title": "Interface: UseLinkOptions<Name> | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / RouterMatcher\nInterface: RouterMatcher\nInternal RouterMatcher\nProperties\naddRoute\n• addRoute: (record\n: RouteRecordRaw\n, parent?\n: RouteRecordMatcher\n) => () => void\nType declaration\n▸ (record\n, parent?\n): () => void\nParameters\nName | Type |\n---|---|\nrecord | RouteRecordRaw |\nparent? | RouteRecordMatcher |\nReturns\nfn\n▸ (): void\nReturns\nvoid\nclearRoutes\n• clearRoutes: () => void\nType declaration\n▸ (): void\nReturns\nvoid\ngetRecordMatcher\n• getRecordMatcher: (name\n: NonNullable\n<RouteRecordNameGeneric\n>) => undefined\n| RouteRecordMatcher\nType declaration\n▸ (name\n): undefined\n| RouteRecordMatcher\nParameters\nName | Type |\n---|---|\nname | NonNullable <RouteRecordNameGeneric > |\nReturns\nundefined\n| RouteRecordMatcher\ngetRoutes\n• getRoutes: () => RouteRecordMatcher\n[]\nType declaration\n▸ (): RouteRecordMatcher\n[]\nReturns\nRouteRecordMatcher\n[]\nresolve\n• resolve: (location\n: MatcherLocationRaw\n, currentLocation\n: MatcherLocation\n) => MatcherLocation\nResolves a location. Gives access to the route record that corresponds to the actual path as well as filling the corresponding params objects\nParam\nMatcherLocationRaw to resolve to a url\nParam\nMatcherLocation of the current location\nType declaration\n▸ (location\n, currentLocation\n): MatcherLocation\nResolves a location. Gives access to the route record that corresponds to the actual path as well as filling the corresponding params objects\nParameters\nName | Type | Description |\n---|---|---|\nlocation | MatcherLocationRaw | MatcherLocationRaw to resolve to a url |\ncurrentLocation | MatcherLocation | MatcherLocation of the current location |\nReturns\nMethods\nremoveRoute\n▸ removeRoute(matcher\n): void\nParameters\nName | Type |\n---|---|\nmatcher | RouteRecordMatcher |\nReturns\nvoid\n▸ removeRoute(name\n): void\nParameters\nName | Type |\n---|---|\nname | NonNullable <RouteRecordNameGeneric > |\nReturns\nvoid",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/routermatcher",
      "title": "Interface: RouterMatcher | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / RouteLocationNormalizedLoadedGeneric\nInterface: RouteLocationNormalizedLoadedGeneric\nGeneric version of RouteLocationNormalizedLoaded that is used when no RouteMap is provided.\nHierarchy\nRouteLocationNormalizedGeneric\n↳\nRouteLocationNormalizedLoadedGeneric\nProperties\nfullPath\n• fullPath: string\nThe whole location including the search\nand hash\n. This string is percentage encoded.\nInherited from\nRouteLocationNormalizedGeneric.fullPath\nhash\n• hash: string\nHash of the current location. If present, starts with a #\n.\nInherited from\nRouteLocationNormalizedGeneric.hash\nmatched\n• matched: RouteLocationMatched\n[]\nArray of RouteLocationMatched containing only plain components (any lazy-loaded components have been loaded and were replaced inside the components\nobject) so it can be directly used to display routes. It cannot contain redirect records either. This property is non-enumerable.\nOverrides\nRouteLocationNormalizedGeneric.matched\nmeta\n• meta: RouteMeta\nMerged meta\nproperties from all the matched route records.\nInherited from\nRouteLocationNormalizedGeneric.meta\nname\n• name: RouteRecordNameGeneric\nName of the matched record\nInherited from\nRouteLocationNormalizedGeneric.name\nparams\n• params: RouteParamsGeneric\nObject of decoded params extracted from the path\n.\nInherited from\nRouteLocationNormalizedGeneric.params\npath\n• path: string\nPercentage encoded pathname section of the URL.\nInherited from\nRouteLocationNormalizedGeneric.path\nquery\n• query: LocationQuery\nObject representation of the search\nproperty of the current location.\nInherited from\nRouteLocationNormalizedGeneric.query\nredirectedFrom\n• redirectedFrom: undefined\n| RouteLocationGeneric\nContains the location we were initially trying to access before ending up on the current location.",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/routelocationnormalizedloadedgeneric",
      "title": "Interface: RouteLocationNormalizedLoadedGeneric | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / RouteRecordRedirect\nInterface: RouteRecordRedirect\nRoute Record that defines a redirect. Cannot have component\nor components\nas it is never rendered.\nHierarchy\n↳\nRouteRecordRedirect\nProperties\nalias\n• Optional\nalias: string\n| string\n[]\nAliases for the record. Allows defining extra paths that will behave like a copy of the record. Allows having paths shorthands like /users/:id\nand /u/:id\n. All alias\nand path\nvalues must share the same params.\nInherited from\nbeforeEnter\n• Optional\nbeforeEnter: NavigationGuardWithThis\n<undefined\n> | NavigationGuardWithThis\n<undefined\n>[]\nBefore Enter guard specific to this record. Note beforeEnter\nhas no effect if the record has a redirect\nproperty.\nInherited from\nchildren\n• Optional\nchildren: RouteRecordRaw\n[]\nArray of nested routes.\nInherited from\ncomponent\n• Optional\ncomponent: undefined\ncomponents\n• Optional\ncomponents: undefined\nend\n• Optional\nend: boolean\nShould the RegExp match until the end by appending a $\nto it.\nDefault Value\ntrue\nInherited from\nmeta\n• Optional\nmeta: RouteMeta\nArbitrary data attached to the record.\nInherited from\nname\n• Optional\nname: RouteRecordNameGeneric\nName for the route record. Must be unique.\nInherited from\npath\n• path: string\nPath of the record. Should start with /\nunless the record is the child of another record.\nExample\n`/users/:id` matches `/users/1` as well as `/users/posva`.\nInherited from\nprops\n• Optional\nprops: undefined\nAllow passing down params as props to the component rendered by router-view\n.\nOverrides\nredirect\n• redirect: RouteRecordRedirectOption\nWhere to redirect if the route is directly matched. The redirection happens before any navigation guard and triggers a new navigation with the new target location.\nOverrides\nsensitive\n• Optional\nsensitive: boolean\nMakes the RegExp case-sensitive.\nDefault Value\nfalse\nInherited from\nstrict\n• Optional\nstrict: boolean\nWhether to disallow a trailing slash or not.\nDefault Value\nfalse",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/routerecordredirect",
      "title": "Interface: RouteRecordRedirect | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / RouteLocationAsRelativeTyped\nInterface: RouteLocationAsRelativeTyped<RouteMap, Name>\nHelper to generate a type safe version of the RouteLocationAsRelative type.\nType parameters\nName | Type |\n---|---|\nRouteMap | extends RouteMapGeneric = RouteMapGeneric |\nName | extends keyof RouteMap = keyof RouteMap |\nHierarchy\nRouteLocationAsRelativeGeneric\n↳\nRouteLocationAsRelativeTyped\nProperties\nforce\n• Optional\nforce: boolean\nTriggers the navigation even if the location is the same as the current one. Note this will also add a new entry to the history unless replace: true\nis passed.\nInherited from\nRouteLocationAsRelativeGeneric.force\nhash\n• Optional\nhash: string\nInherited from\nRouteLocationAsRelativeGeneric.hash\nname\n• Optional\nname: Extract\n<Name\n, string\n| symbol\n>\nOverrides\nRouteLocationAsRelativeGeneric.name\nparams\n• Optional\nparams: RouteMap\n[Name\n][\"paramsRaw\"\n]\nOverrides\nRouteLocationAsRelativeGeneric.params\npath\n• Optional\npath: undefined\nA relative path to the current location. This property should be removed\nInherited from\nRouteLocationAsRelativeGeneric.path\nquery\n• Optional\nquery: LocationQueryRaw\nInherited from\nRouteLocationAsRelativeGeneric.query\nreplace\n• Optional\nreplace: boolean\nReplace the entry in the history instead of pushing a new entry\nInherited from\nRouteLocationAsRelativeGeneric.replace\nstate\n• Optional\nstate: HistoryState\nState to save using the History API. This cannot contain any reactive values and some primitives like Symbols are forbidden. More info at https://developer.mozilla.org/en-US/docs/Web/API/History/state",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/routelocationasrelativetyped",
      "title": "Interface: RouteLocationAsRelativeTyped<RouteMap, Name> | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / NavigationRedirectError\nInterface: NavigationRedirectError\nInternal error used to detect a redirection.\nHierarchy\nOmit\n<NavigationFailure\n,\"to\"\n|\"type\"\n>↳\nNavigationRedirectError\nProperties\ncause\n• Optional\ncause: unknown\nInherited from\nOmit.cause\nfrom\n• from: RouteLocationNormalizedGeneric\nRoute location we were navigating from\nInherited from\nOmit.from\nmessage\n• message: string\nInherited from\nOmit.message\nname\n• name: string\nInherited from\nOmit.name\nstack\n• Optional\nstack: string\nInherited from\nOmit.stack\nto\n• to: string\n| RouteLocationAsRelativeGeneric\n| RouteLocationAsPathGeneric\ntype\n• type: NAVIGATION_GUARD_REDIRECT",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/navigationredirecterror",
      "title": "Interface: NavigationRedirectError | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / RouterViewProps\nInterface: RouterViewProps\nProperties\nname\n• Optional\nname: string\nroute\n• Optional\nroute: RouteLocationNormalizedGeneric\nAPI Documentation / RouterViewProps\n• Optional\nname: string\n• Optional\nroute: RouteLocationNormalizedGeneric",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/routerviewprops",
      "title": "Interface: RouterViewProps | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / RouterOptions\nInterface: RouterOptions\nOptions to initialize a Router instance.\nHierarchy\n↳\nRouterOptions\nProperties\nend\n• Optional\nend: boolean\nShould the RegExp match until the end by appending a $\nto it.\nDefault Value\ntrue\nInherited from\nPathParserOptions.end\nhistory\n• history: RouterHistory\nHistory implementation used by the router. Most web applications should use createWebHistory\nbut it requires the server to be properly configured. You can also use a hash based history with createWebHashHistory\nthat does not require any configuration on the server but isn't handled at all by search engines and does poorly on SEO.\nExample\ncreateRouter({\nhistory: createWebHistory(),\n// other options...\n})\nlinkActiveClass\n• Optional\nlinkActiveClass: string\nDefault class applied to active RouterLink. If none is provided, router-link-active\nwill be applied.\nlinkExactActiveClass\n• Optional\nlinkExactActiveClass: string\nDefault class applied to exact active RouterLink. If none is provided, router-link-exact-active\nwill be applied.\nparseQuery\n• Optional\nparseQuery: (search\n: string\n) => LocationQuery\nCustom implementation to parse a query. See its counterpart, RouterOptions.stringifyQuery.\nExample\nLet's say you want to use the qs package to parse queries, you can provide both parseQuery\nand stringifyQuery\n:\nimport qs from 'qs'\ncreateRouter({\n// other options...\nparseQuery: qs.parse,\nstringifyQuery: qs.stringify,\n})\nType declaration\n▸ (search\n): LocationQuery\nCustom implementation to parse a query. See its counterpart, RouterOptions.stringifyQuery.\nParameters\nName | Type |\n---|---|\nsearch | string |\nReturns\nExample\nLet's say you want to use the qs package to parse queries, you can provide both parseQuery\nand stringifyQuery\n:\nimport qs from 'qs'\ncreateRouter({\n// other options...\nparseQuery: qs.parse,\nstringifyQuery: qs.stringify,\n})\nroutes\n• routes: readonly RouteRecordRaw\n[]\nInitial list of routes that should be added to the router.\nscrollBehavior\n• Optional\nscrollBehavior: RouterScrollBehavior\nFunction to control scrolling when navigating between pages. Can return a Promise to delay scrolling. Check ScrollBehavior.\nExample\nfunction scrollBehavior(to, from, savedPosition) {\n// `to` and `from` are both route locations\n// `savedPosition` can be null if there isn't one\n}\nsensitive\n• Optional\nsensitive: boolean\nMakes the RegExp case-sensitive.\nDefault Value\nfalse\nInherited from\nPathParserOptions.sensitive\nstrict\n• Optional\nstrict: boolean\nWhether to disallow a trailing slash or not.\nDefault Value\nfalse\nInherited from\nPathParserOptions.strict\nstringifyQuery\n• Optional\nstringifyQuery: (query\n: LocationQueryRaw\n) => string\nCustom implementation to stringify a query object. Should not prepend a leading ?\n. parseQuery counterpart to handle query parsing.\nType declaration\n▸ (query\n): string\nCustom implementation to stringify a query object. Should not prepend a leading ?\n. parseQuery counterpart to handle query parsing.\nParameters\nName | Type |\n---|---|\nquery | LocationQueryRaw |\nReturns\nstring",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/routeroptions",
      "title": "Interface: RouterOptions | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / RouteQueryAndHash\nInterface: RouteQueryAndHash\nHierarchy\nRouteQueryAndHash\n↳\nRouteLocationAsRelativeGeneric\nProperties\nhash\n• Optional\nhash: string\nquery\n• Optional\nquery: LocationQueryRaw\nAPI Documentation / RouteQueryAndHash\nRouteQueryAndHash\n↳ RouteLocationAsRelativeGeneric\n• Optional\nhash: string\n• Optional\nquery: LocationQueryRaw",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/routequeryandhash",
      "title": "Interface: RouteQueryAndHash | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / _RouteLocationBase\nInterface: _RouteLocationBase\nBase properties for a normalized route location.\nHierarchy\nPick\n<MatcherLocation\n,\"name\"\n|\"path\"\n|\"params\"\n|\"meta\"\n>↳\n_RouteLocationBase\nProperties\nfullPath\n• fullPath: string\nThe whole location including the search\nand hash\n. This string is percentage encoded.\nhash\n• hash: string\nHash of the current location. If present, starts with a #\n.\nmeta\n• meta: RouteMeta\nMerged meta\nproperties from all the matched route records.\nInherited from\nPick.meta\nname\n• name: null\n| RouteRecordNameGeneric\nName of the matched record\nInherited from\nPick.name\nparams\n• params: RouteParamsGeneric\nObject of decoded params extracted from the path\n.\nInherited from\nPick.params\npath\n• path: string\nPercentage encoded pathname section of the URL.\nInherited from\nPick.path\nquery\n• query: LocationQuery\nObject representation of the search\nproperty of the current location.\nredirectedFrom\n• redirectedFrom: undefined\n| RouteLocationGeneric\nContains the location we were initially trying to access before ending up on the current location.",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/routelocationbase",
      "title": "Interface: _RouteLocationBase | Vue Router"
    }
  },
  {
    "page_content": "English\nAppearance\nComplete guide to\nMastering Pinia\nwritten by its creator\nThe official\nVue.js Certification\nGet certified!\nAPI Documentation / HistoryState\nAllowed HTML history.state\n▪ [x: number]: HistoryStateValue\nnumber\nHistoryStateValue",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/historystate",
      "title": "Interface: HistoryState | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / Router\nInterface: Router\nRouter instance.\nProperties\ncurrentRoute\n• Readonly\ncurrentRoute: Ref\n<RouteLocationNormalizedLoadedGeneric\n>\nCurrent RouteLocationNormalized\nlistening\n• listening: boolean\nAllows turning off the listening of history events. This is a low level api for micro-frontend.\noptions\n• Readonly\noptions: RouterOptions\nOriginal options object passed to create the Router\nMethods\naddRoute\n▸ addRoute(parentName\n, route\n): () => void\nAdd a new route record as the child of an existing route.\nParameters\nName | Type | Description |\n---|---|---|\nparentName | NonNullable <RouteRecordNameGeneric > | Parent Route Record where route should be appended at |\nroute | RouteRecordRaw | Route Record to add |\nReturns\nfn\n▸ (): void\nReturns\nvoid\n▸ addRoute(route\n): () => void\nAdd a new route record to the router.\nParameters\nName | Type | Description |\n---|---|---|\nroute | RouteRecordRaw | Route Record to add |\nReturns\nfn\n▸ (): void\nReturns\nvoid\nafterEach\n▸ afterEach(guard\n): () => void\nAdd a navigation hook that is executed after every navigation. Returns a function that removes the registered hook.\nParameters\nName | Type | Description |\n---|---|---|\nguard | NavigationHookAfter | navigation hook to add |\nReturns\nfn\na function that removes the registered hook\n▸ (): void\nReturns\nvoid\nExample\nrouter.afterEach((to, from, failure) => {\nif (isNavigationFailure(failure)) {\nconsole.log('failed navigation', failure)\n}\n})\nback\n▸ back(): void\nGo back in history if possible by calling history.back()\n. Equivalent to router.go(-1)\n.\nReturns\nvoid\nbeforeEach\n▸ beforeEach(guard\n): () => void\nAdd a navigation guard that executes before any navigation. Returns a function that removes the registered guard.\nParameters\nName | Type | Description |\n---|---|---|\nguard | NavigationGuardWithThis <undefined > | navigation guard to add |\nReturns\nfn\n▸ (): void\nReturns\nvoid\nbeforeResolve\n▸ beforeResolve(guard\n): () => void\nAdd a navigation guard that executes before navigation is about to be resolved. At this state all component have been fetched and other navigation guards have been successful. Returns a function that removes the registered guard.\nParameters\nName | Type | Description |\n---|---|---|\nguard | NavigationGuardWithThis <undefined > | navigation guard to add |\nReturns\nfn\na function that removes the registered guard\n▸ (): void\nReturns\nvoid\nExample\nrouter.beforeResolve(to => {\nif (to.meta.requiresAuth && !isAuthenticated) return false\n})\nclearRoutes\n▸ clearRoutes(): void\nDelete all routes from the router matcher.\nReturns\nvoid\nforward\n▸ forward(): void\nGo forward in history if possible by calling history.forward()\n. Equivalent to router.go(1)\n.\nReturns\nvoid\ngetRoutes\n▸ getRoutes(): RouteRecordNormalized\n[]\nGet a full list of all the route records.\nReturns\ngo\n▸ go(delta\n): void\nAllows you to move forward or backward through the history. Calls history.go()\n.\nParameters\nName | Type | Description |\n---|---|---|\ndelta | number | The position in the history to which you want to move, relative to the current page |\nReturns\nvoid\nhasRoute\n▸ hasRoute(name\n): boolean\nChecks if a route with a given name exists\nParameters\nName | Type | Description |\n---|---|---|\nname | NonNullable <RouteRecordNameGeneric > | Name of the route to check |\nReturns\nboolean\ninstall\n▸ install(app\n): void\nCalled automatically by app.use(router)\n. Should not be called manually by the user. This will trigger the initial navigation when on client side.\nParameters\nName | Type | Description |\n---|---|---|\napp | App <any > | Application that uses the router |\nReturns\nvoid\nisReady\n▸ isReady(): Promise\n<void\n>\nReturns a Promise that resolves when the router has completed the initial navigation, which means it has resolved all async enter hooks and async components that are associated with the initial route. If the initial navigation already happened, the promise resolves immediately.\nThis is useful in server-side rendering to ensure consistent output on both the server and the client. Note that on server side, you need to manually push the initial location while on client side, the router automatically picks it up from the URL.\nReturns\nPromise\n<void\n>\nonError\n▸ onError(handler\n): () => void\nAdds an error handler that is called every time a non caught error happens during navigation. This includes errors thrown synchronously and asynchronously, errors returned or passed to next\nin any navigation guard, and errors occurred when trying to resolve an async component that is required to render a route.\nParameters\nName | Type | Description |\n---|---|---|\nhandler | _ErrorListener | error handler to register |\nReturns\nfn\n▸ (): void\nReturns\nvoid\npush\n▸ push(to\n): Promise\n<undefined\n| void\n| NavigationFailure\n>\nProgrammatically navigate to a new URL by pushing an entry in the history stack.\nParameters\nName | Type | Description |\n---|---|---|\nto | string | RouteLocationAsRelativeGeneric | RouteLocationAsPathGeneric | Route location to navigate to |\nReturns\nPromise\n<undefined\n| void\n| NavigationFailure\n>\nremoveRoute\n▸ removeRoute(name\n): void\nRemove an existing route by its name.\nParameters\nName | Type | Description |\n---|---|---|\nname | NonNullable <RouteRecordNameGeneric > | Name of the route to remove |\nReturns\nvoid\nreplace\n▸ replace(to\n): Promise\n<undefined\n| void\n| NavigationFailure\n>\nProgrammatically navigate to a new URL by replacing the current entry in the history stack.\nParameters\nName | Type | Description |\n---|---|---|\nto | string | RouteLocationAsRelativeGeneric | RouteLocationAsPathGeneric | Route location to navigate to |\nReturns\nPromise\n<undefined\n| void\n| NavigationFailure\n>\nresolve\n▸ resolve<Name\n>(to\n, currentLocation?\n): RouteLocationResolvedGeneric\nReturns the normalized version of a route location. Also includes an href\nproperty that includes any existing base\n. By default, the currentLocation\nused is router.currentRoute\nand should only be overridden in advanced use cases.\nType parameters\nName | Type |\n---|---|\nName | extends string | symbol = string | symbol |\nParameters\nName | Type | Description |\n---|---|---|\nto | RouteLocationAsRelativeTyped <RouteMapGeneric , Name > | Raw route location to resolve |\ncurrentLocation? | RouteLocationNormalizedLoadedGeneric | Optional current location to resolve against |\nReturns\n▸ resolve(to\n, currentLocation?\n): RouteLocationResolvedGeneric\nParameters\nName | Type |\n---|---|\nto | string | RouteLocationAsRelativeGeneric | RouteLocationAsPathGeneric |\ncurrentLocation? | RouteLocationNormalizedLoadedGeneric |",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/router",
      "title": "Interface: Router | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / RouterHistory\nInterface: RouterHistory\nInterface implemented by History implementations that can be passed to the router as Router.history\nProperties\nbase\n• Readonly\nbase: string\nBase path that is prepended to every url. This allows hosting an SPA at a sub-folder of a domain like example.com/sub-folder\nby having a base\nof /sub-folder\nlocation\n• Readonly\nlocation: string\nCurrent History location\nstate\n• Readonly\nstate: HistoryState\nCurrent History state\nMethods\ncreateHref\n▸ createHref(location\n): string\nGenerates the corresponding href to be used in an anchor tag.\nParameters\nName | Type | Description |\n---|---|---|\nlocation | string | history location that should create an href |\nReturns\nstring\ndestroy\n▸ destroy(): void\nClears any event listener attached by the history implementation.\nReturns\nvoid\ngo\n▸ go(delta\n, triggerListeners?\n): void\nTraverses history in a given direction.\nParameters\nName | Type | Description |\n---|---|---|\ndelta | number | distance to travel. If delta is < 0, it will go back, if it's > 0, it will go forward by that amount of entries. |\ntriggerListeners? | boolean | whether this should trigger listeners attached to the history |\nReturns\nvoid\nExample\nmyHistory.go(-1) // equivalent to window.history.back()\nmyHistory.go(1) // equivalent to window.history.forward()\nlisten\n▸ listen(callback\n): () => void\nAttach a listener to the History implementation that is triggered when the navigation is triggered from outside (like the Browser back and forward buttons) or when passing true\nto RouterHistory.back and RouterHistory.forward\nParameters\nName | Type | Description |\n---|---|---|\ncallback | NavigationCallback | listener to attach |\nReturns\nfn\na callback to remove the listener\n▸ (): void\nReturns\nvoid\npush\n▸ push(to\n, data?\n): void\nNavigates to a location. In the case of an HTML5 History implementation, this will call history.pushState\nto effectively change the URL.\nParameters\nName | Type | Description |\n---|---|---|\nto | string | location to push |\ndata? | HistoryState | optional HistoryState to be associated with the navigation entry |\nReturns\nvoid\nreplace\n▸ replace(to\n, data?\n): void\nSame as RouterHistory.push but performs a history.replaceState\ninstead of history.pushState\nParameters\nName | Type | Description |\n---|---|---|\nto | string | location to set |\ndata? | HistoryState | optional HistoryState to be associated with the navigation entry |\nReturns\nvoid",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/routerhistory",
      "title": "Interface: RouterHistory | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / _RouteRecordBase\nInterface: _RouteRecordBase\nInternal type for common properties among all kind of RouteRecordRaw.\nHierarchy\n_RouteRecordBaseMeta\n↳\n_RouteRecordBase\n↳↳\nRouteRecordSingleViewWithChildren\n↳↳\nRouteRecordMultipleViewsWithChildren\nProperties\nalias\n• Optional\nalias: string\n| string\n[]\nAliases for the record. Allows defining extra paths that will behave like a copy of the record. Allows having paths shorthands like /users/:id\nand /u/:id\n. All alias\nand path\nvalues must share the same params.\nbeforeEnter\n• Optional\nbeforeEnter: NavigationGuardWithThis\n<undefined\n> | NavigationGuardWithThis\n<undefined\n>[]\nBefore Enter guard specific to this record. Note beforeEnter\nhas no effect if the record has a redirect\nproperty.\nchildren\n• Optional\nchildren: RouteRecordRaw\n[]\nArray of nested routes.\nend\n• Optional\nend: boolean\nShould the RegExp match until the end by appending a $\nto it.\nDefault Value\ntrue\nInherited from\nPathParserOptions.end\nmeta\n• Optional\nmeta: RouteMeta\nArbitrary data attached to the record.\nInherited from\n_RouteRecordBaseMeta.meta\nname\n• Optional\nname: RouteRecordNameGeneric\nName for the route record. Must be unique.\npath\n• path: string\nPath of the record. Should start with /\nunless the record is the child of another record.\nExample\n`/users/:id` matches `/users/1` as well as `/users/posva`.\nprops\n• Optional\nprops: _RouteRecordProps\n| Record\n<string\n, _RouteRecordProps\n>\nAllow passing down params as props to the component rendered by router-view\n.\nredirect\n• Optional\nredirect: RouteRecordRedirectOption\nWhere to redirect if the route is directly matched. The redirection happens before any navigation guard and triggers a new navigation with the new target location.\nsensitive\n• Optional\nsensitive: boolean\nMakes the RegExp case-sensitive.\nDefault Value\nfalse\nInherited from\nPathParserOptions.sensitive\nstrict\n• Optional\nstrict: boolean\nWhether to disallow a trailing slash or not.\nDefault Value\nfalse\nInherited from\nPathParserOptions.strict",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/routerecordbase",
      "title": "Interface: _RouteRecordBase | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / RouteLocationTyped\nInterface: RouteLocationTyped<RouteMap, Name>\nHelper to generate a type safe version of the RouteLocation type.\nType parameters\nName | Type |\n---|---|\nRouteMap | extends RouteMapGeneric |\nName | extends keyof RouteMap |\nHierarchy\n↳\nRouteLocationTyped\nProperties\nfullPath\n• fullPath: string\nThe whole location including the search\nand hash\n. This string is percentage encoded.\nInherited from\nhash\n• hash: string\nHash of the current location. If present, starts with a #\n.\nInherited from\nmatched\n• matched: RouteRecordNormalized\n[]\nArray of RouteRecord containing components as they were passed when adding records. It can also contain redirect records. This can't be used directly. This property is non-enumerable.\nInherited from\nmeta\n• meta: RouteMeta\nMerged meta\nproperties from all the matched route records.\nInherited from\nname\n• name: Extract\n<Name\n, string\n| symbol\n>\nName of the matched record\nOverrides\nparams\n• params: RouteMap\n[Name\n][\"params\"\n]\nObject of decoded params extracted from the path\n.\nOverrides\npath\n• path: string\nPercentage encoded pathname section of the URL.\nInherited from\nquery\n• query: LocationQuery\nObject representation of the search\nproperty of the current location.\nInherited from\nredirectedFrom\n• redirectedFrom: undefined\n| RouteLocationGeneric\nContains the location we were initially trying to access before ending up on the current location.",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/routelocationtyped",
      "title": "Interface: RouteLocationTyped<RouteMap, Name> | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / RouteLocationPathRaw\nInterface: RouteLocationPathRaw\nRoute Location that can infer the possible paths.\nHierarchy\n↳\nRouteLocationPathRaw\nProperties\nforce\n• Optional\nforce: boolean\nTriggers the navigation even if the location is the same as the current one. Note this will also add a new entry to the history unless replace: true\nis passed.\nInherited from\nhash\n• Optional\nhash: string\nInherited from\npath\n• path: string\nInherited from\nquery\n• Optional\nquery: LocationQueryRaw\nInherited from\nreplace\n• Optional\nreplace: boolean\nReplace the entry in the history instead of pushing a new entry\nInherited from\nstate\n• Optional\nstate: HistoryState\nState to save using the History API. This cannot contain any reactive values and some primitives like Symbols are forbidden. More info at https://developer.mozilla.org/en-US/docs/Web/API/History/state",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/routelocationpathraw",
      "title": "Interface: RouteLocationPathRaw | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / RouteLocationMatched\nInterface: RouteLocationMatched\nNormalized version of a route record.\nHierarchy\n↳\nRouteLocationMatched\nProperties\naliasOf\n• aliasOf: undefined\n| RouteRecordNormalized\nDefines if this record is the alias of another one. This property is undefined\nif the record is the original one.\nInherited from\nbeforeEnter\n• beforeEnter: undefined\n| NavigationGuardWithThis\n<undefined\n> | NavigationGuardWithThis\n<undefined\n>[]\nRegistered beforeEnter guards\nInherited from\nRouteRecordNormalized.beforeEnter\nchildren\n• children: RouteRecordRaw\n[]\nNested route records.\nInherited from\nRouteRecordNormalized.children\ncomponents\n• components: undefined\n| null\n| Record\n<string\n, RouteComponent\n>\nComponents to display when the URL matches this route. Allow using named views.\nOverrides\nRouteRecordNormalized.components\nenterCallbacks\n• enterCallbacks: Record\n<string\n, NavigationGuardNextCallback\n[]>\nRegistered beforeRouteEnter callbacks passed to next\nor returned in guards\nInherited from\nRouteRecordNormalized.enterCallbacks\ninstances\n• instances: Record\n<string\n, undefined\n| null\n| ComponentPublicInstance\n>\nMounted route component instances Having the instances on the record mean beforeRouteUpdate and beforeRouteLeave guards can only be invoked with the latest mounted app instance if there are multiple application instances rendering the same view, basically duplicating the content on the page, which shouldn't happen in practice. It will work if multiple apps are rendering different named views.\nInherited from\nRouteRecordNormalized.instances\nleaveGuards\n• leaveGuards: Set\n<NavigationGuard\n>\nRegistered leave guards\nInherited from\nRouteRecordNormalized.leaveGuards\nmeta\n• meta: RouteMeta\nArbitrary data attached to the record.\nInherited from\nname\n• name: RouteRecordNameGeneric\nName for the route record. Must be unique.\nInherited from\npath\n• path: string\nPath of the record. Should start with /\nunless the record is the child of another record.\nInherited from\nprops\n• props: Record\n<string\n, _RouteRecordProps\n>\nAllow passing down params as props to the component rendered by router-view\n. Should be an object with the same keys as components\nor a boolean to be applied to every component.\nInherited from\nredirect\n• redirect: undefined\n| RouteRecordRedirectOption\nWhere to redirect if the route is directly matched. The redirection happens before any navigation guard and triggers a new navigation with the new target location.\nInherited from\nRouteRecordNormalized.redirect\nupdateGuards\n• updateGuards: Set\n<NavigationGuard\n>\nRegistered update guards",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/routelocationmatched",
      "title": "Interface: RouteLocationMatched | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / RouteRecordInfo\nInterface: RouteRecordInfo<Name, Path, ParamsRaw, Params, Meta>\nHelper type to define a Typed RouteRecord\nSee\nType parameters\nName | Type |\n---|---|\nName | extends string | symbol = string |\nPath | extends string = string |\nParamsRaw | extends RouteParamsRawGeneric = RouteParamsRawGeneric |\nParams | extends RouteParamsGeneric = RouteParamsGeneric |\nMeta | extends RouteMeta = RouteMeta |\nProperties\nmeta\n• meta: Meta\nname\n• name: Name\nparams\n• params: Params\nparamsRaw\n• paramsRaw: ParamsRaw\npath\n• path: Path",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/routerecordinfo",
      "title": "Interface: RouteRecordInfo<Name, Path, ParamsRaw, Params, Meta> | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / RouteLocationNormalizedLoadedTyped\nInterface: RouteLocationNormalizedLoadedTyped<RouteMap, Name>\nHelper to generate a type safe version of the RouteLocationNormalizedLoaded type.\nType parameters\nName | Type |\n---|---|\nRouteMap | extends RouteMapGeneric = RouteMapGeneric |\nName | extends keyof RouteMap = keyof RouteMap |\nHierarchy\nRouteLocationNormalizedLoadedGeneric\n↳\nRouteLocationNormalizedLoadedTyped\nProperties\nfullPath\n• fullPath: string\nThe whole location including the search\nand hash\n. This string is percentage encoded.\nInherited from\nRouteLocationNormalizedLoadedGeneric.fullPath\nhash\n• hash: string\nHash of the current location. If present, starts with a #\n.\nInherited from\nRouteLocationNormalizedLoadedGeneric.hash\nmatched\n• matched: RouteLocationMatched\n[]\nArray of RouteLocationMatched containing only plain components (any lazy-loaded components have been loaded and were replaced inside the components\nobject) so it can be directly used to display routes. It cannot contain redirect records either. This property is non-enumerable.\nInherited from\nRouteLocationNormalizedLoadedGeneric.matched\nmeta\n• meta: RouteMeta\nMerged meta\nproperties from all the matched route records.\nInherited from\nRouteLocationNormalizedLoadedGeneric.meta\nname\n• name: Extract\n<Name\n, string\n| symbol\n>\nName of the matched record\nOverrides\nRouteLocationNormalizedLoadedGeneric.name\nparams\n• params: RouteMap\n[Name\n][\"params\"\n]\nObject of decoded params extracted from the path\n.\nOverrides\nRouteLocationNormalizedLoadedGeneric.params\npath\n• path: string\nPercentage encoded pathname section of the URL.\nInherited from\nRouteLocationNormalizedLoadedGeneric.path\nquery\n• query: LocationQuery\nObject representation of the search\nproperty of the current location.\nInherited from\nRouteLocationNormalizedLoadedGeneric.query\nredirectedFrom\n• redirectedFrom: undefined\n| RouteLocationGeneric\nContains the location we were initially trying to access before ending up on the current location.",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/routelocationnormalizedloadedtyped",
      "title": "Interface: RouteLocationNormalizedLoadedTyped<RouteMap, Name> | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / RouteLocationNormalizedTyped\nInterface: RouteLocationNormalizedTyped<RouteMap, Name>\nHelper to generate a type safe version of the RouteLocationNormalized type.\nType parameters\nName | Type |\n---|---|\nRouteMap | extends RouteMapGeneric = RouteMapGeneric |\nName | extends keyof RouteMap = keyof RouteMap |\nHierarchy\nRouteLocationNormalizedGeneric\n↳\nRouteLocationNormalizedTyped\nProperties\nfullPath\n• fullPath: string\nThe whole location including the search\nand hash\n. This string is percentage encoded.\nInherited from\nRouteLocationNormalizedGeneric.fullPath\nhash\n• hash: string\nHash of the current location. If present, starts with a #\n.\nInherited from\nRouteLocationNormalizedGeneric.hash\nmatched\n• matched: RouteRecordNormalized\n[]\nArray of RouteRecordNormalized\nOverrides\nRouteLocationNormalizedGeneric.matched\nmeta\n• meta: RouteMeta\nMerged meta\nproperties from all the matched route records.\nInherited from\nRouteLocationNormalizedGeneric.meta\nname\n• name: Extract\n<Name\n, string\n| symbol\n>\nName of the matched record\nOverrides\nRouteLocationNormalizedGeneric.name\nparams\n• params: RouteMap\n[Name\n][\"params\"\n]\nObject of decoded params extracted from the path\n.\nOverrides\nRouteLocationNormalizedGeneric.params\npath\n• path: string\nPercentage encoded pathname section of the URL.\nInherited from\nRouteLocationNormalizedGeneric.path\nquery\n• query: LocationQuery\nObject representation of the search\nproperty of the current location.\nInherited from\nRouteLocationNormalizedGeneric.query\nredirectedFrom\n• redirectedFrom: undefined\n| RouteLocationGeneric\nContains the location we were initially trying to access before ending up on the current location.",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/routelocationnormalizedtyped",
      "title": "Interface: RouteLocationNormalizedTyped<RouteMap, Name> | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / RouteLocationResolvedTyped\nInterface: RouteLocationResolvedTyped<RouteMap, Name>\nHelper to generate a type safe version of the RouteLocationResolved type.\nType parameters\nName | Type |\n---|---|\nRouteMap | extends RouteMapGeneric |\nName | extends keyof RouteMap |\nHierarchy\nRouteLocationTyped\n<RouteMap\n,Name\n>↳\nRouteLocationResolvedTyped\nProperties\nfullPath\n• fullPath: string\nThe whole location including the search\nand hash\n. This string is percentage encoded.\nInherited from\nhash\n• hash: string\nHash of the current location. If present, starts with a #\n.\nInherited from\nhref\n• href: string\nResolved href\nfor the route location that will be set on the <a href=\"...\">\n.\nmatched\n• matched: RouteRecordNormalized\n[]\nArray of RouteRecord containing components as they were passed when adding records. It can also contain redirect records. This can't be used directly. This property is non-enumerable.\nInherited from\nmeta\n• meta: RouteMeta\nMerged meta\nproperties from all the matched route records.\nInherited from\nname\n• name: Extract\n<Name\n, string\n| symbol\n>\nName of the matched record\nInherited from\nparams\n• params: RouteMap\n[Name\n][\"params\"\n]\nObject of decoded params extracted from the path\n.\nInherited from\npath\n• path: string\nPercentage encoded pathname section of the URL.\nInherited from\nquery\n• query: LocationQuery\nObject representation of the search\nproperty of the current location.\nInherited from\nredirectedFrom\n• redirectedFrom: undefined\n| RouteLocationGeneric\nContains the location we were initially trying to access before ending up on the current location.",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/routelocationresolvedtyped",
      "title": "Interface: RouteLocationResolvedTyped<RouteMap, Name> | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / _PathParserOptions\nInterface: _PathParserOptions\nProperties\nend\n• Optional\nend: boolean\nShould the RegExp match until the end by appending a $\nto it.\nDefault Value\ntrue\nsensitive\n• Optional\nsensitive: boolean\nMakes the RegExp case-sensitive.\nDefault Value\nfalse\nstart\n• Optional\nstart: boolean\nShould the RegExp match from the beginning by prepending a ^\nto it.\nDefault Value\ntrue\nstrict\n• Optional\nstrict: boolean\nWhether to disallow a trailing slash or not.\nDefault Value\nfalse",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/pathparseroptions",
      "title": "Interface: _PathParserOptions | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / ErrorTypes\nEnumeration: ErrorTypes\nFlags so we can combine them when checking for multiple errors. This is the internal version of NavigationFailureType.\nEnumeration Members\nMATCHER_NOT_FOUND\n• MATCHER_NOT_FOUND = 1\nNAVIGATION_ABORTED\n• NAVIGATION_ABORTED = 4\nNAVIGATION_CANCELLED\n• NAVIGATION_CANCELLED = 8\nNAVIGATION_DUPLICATED\n• NAVIGATION_DUPLICATED = 16\nNAVIGATION_GUARD_REDIRECT\n• NAVIGATION_GUARD_REDIRECT = 2",
    "metadata": {
      "source": "https://router.vuejs.org/api/enums/errortypes",
      "title": "Enumeration: ErrorTypes | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / RouteRecordSingleView\nInterface: RouteRecordSingleView\nRoute Record defining one single component with the component\noption.\nHierarchy\n↳\nRouteRecordSingleView\nProperties\nalias\n• Optional\nalias: string\n| string\n[]\nAliases for the record. Allows defining extra paths that will behave like a copy of the record. Allows having paths shorthands like /users/:id\nand /u/:id\n. All alias\nand path\nvalues must share the same params.\nInherited from\nbeforeEnter\n• Optional\nbeforeEnter: NavigationGuardWithThis\n<undefined\n> | NavigationGuardWithThis\n<undefined\n>[]\nBefore Enter guard specific to this record. Note beforeEnter\nhas no effect if the record has a redirect\nproperty.\nInherited from\nchildren\n• Optional\nchildren: undefined\nArray of nested routes.\nOverrides\ncomponent\n• component: RawRouteComponent\nComponent to display when the URL matches this route.\ncomponents\n• Optional\ncomponents: undefined\nend\n• Optional\nend: boolean\nShould the RegExp match until the end by appending a $\nto it.\nDefault Value\ntrue\nInherited from\nmeta\n• Optional\nmeta: RouteMeta\nArbitrary data attached to the record.\nInherited from\nname\n• Optional\nname: RouteRecordNameGeneric\nName for the route record. Must be unique.\nInherited from\npath\n• path: string\nPath of the record. Should start with /\nunless the record is the child of another record.\nExample\n`/users/:id` matches `/users/1` as well as `/users/posva`.\nInherited from\nprops\n• Optional\nprops: _RouteRecordProps\nAllow passing down params as props to the component rendered by router-view\n.\nOverrides\nredirect\n• Optional\nredirect: undefined\nWhere to redirect if the route is directly matched. The redirection happens before any navigation guard and triggers a new navigation with the new target location.\nOverrides\nsensitive\n• Optional\nsensitive: boolean\nMakes the RegExp case-sensitive.\nDefault Value\nfalse\nInherited from\nstrict\n• Optional\nstrict: boolean\nWhether to disallow a trailing slash or not.\nDefault Value\nfalse",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/routerecordsingleview",
      "title": "Interface: RouteRecordSingleView | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / LocationAsRelativeRaw\nInterface: LocationAsRelativeRaw\nHierarchy\nLocationAsRelativeRaw\nProperties\nname\n• Optional\nname: RouteRecordNameGeneric\nparams\n• Optional\nparams: RouteParamsRawGeneric\npath\n• Optional\npath: undefined\nIgnored path property since we are dealing with a relative location. Only undefined\nis allowed.",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/locationasrelativeraw",
      "title": "Interface: LocationAsRelativeRaw | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / RouteLocationNormalizedGeneric\nInterface: RouteLocationNormalizedGeneric\nGeneric version of RouteLocationNormalized that is used when no RouteMap is provided.\nHierarchy\n↳\nRouteLocationNormalizedGeneric\n↳↳\nRouteLocationNormalizedTyped\nProperties\nfullPath\n• fullPath: string\nThe whole location including the search\nand hash\n. This string is percentage encoded.\nInherited from\nhash\n• hash: string\nHash of the current location. If present, starts with a #\n.\nInherited from\nmatched\n• matched: RouteRecordNormalized\n[]\nArray of RouteRecordNormalized\nmeta\n• meta: RouteMeta\nMerged meta\nproperties from all the matched route records.\nInherited from\nname\n• name: RouteRecordNameGeneric\nName of the matched record\nOverrides\nparams\n• params: RouteParamsGeneric\nObject of decoded params extracted from the path\n.\nOverrides\npath\n• path: string\nPercentage encoded pathname section of the URL.\nInherited from\nquery\n• query: LocationQuery\nObject representation of the search\nproperty of the current location.\nInherited from\nredirectedFrom\n• redirectedFrom: undefined\n| RouteLocationGeneric\nContains the location we were initially trying to access before ending up on the current location.",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/routelocationnormalizedgeneric",
      "title": "Interface: RouteLocationNormalizedGeneric | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / NavigationGuard\nInterface: NavigationGuard\nNavigation Guard.\nCallable\nNavigationGuard\n▸ NavigationGuard(to\n, from\n, next\n): _Awaitable\n<NavigationGuardReturn\n>\nParameters\nName | Type |\n---|---|\nto | RouteLocationNormalizedGeneric |\nfrom | RouteLocationNormalizedLoadedGeneric |\nnext | NavigationGuardNext |",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/navigationguard",
      "title": "Interface: NavigationGuard | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / RouteLocationGeneric\nInterface: RouteLocationGeneric\nGeneric version of RouteLocation. It is used when no RouteMap is provided.\nHierarchy\n↳\nRouteLocationGeneric\nProperties\nfullPath\n• fullPath: string\nThe whole location including the search\nand hash\n. This string is percentage encoded.\nInherited from\nhash\n• hash: string\nHash of the current location. If present, starts with a #\n.\nInherited from\nmatched\n• matched: RouteRecordNormalized\n[]\nArray of RouteRecord containing components as they were passed when adding records. It can also contain redirect records. This can't be used directly. This property is non-enumerable.\nmeta\n• meta: RouteMeta\nMerged meta\nproperties from all the matched route records.\nInherited from\nname\n• name: null\n| RouteRecordNameGeneric\nName of the matched record\nInherited from\nparams\n• params: RouteParamsGeneric\nObject of decoded params extracted from the path\n.\nInherited from\npath\n• path: string\nPercentage encoded pathname section of the URL.\nInherited from\nquery\n• query: LocationQuery\nObject representation of the search\nproperty of the current location.\nInherited from\nredirectedFrom\n• redirectedFrom: undefined\n| RouteLocationGeneric\nContains the location we were initially trying to access before ending up on the current location.",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/routelocationgeneric",
      "title": "Interface: RouteLocationGeneric | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / UseLinkReturn\nInterface: UseLinkReturn<Name>\nReturn type of useLink.\nType parameters\nName | Type |\n---|---|\nName | extends keyof RouteMap = keyof RouteMap |\nProperties\nhref\n• href: ComputedRef\n<string\n>\nisActive\n• isActive: ComputedRef\n<boolean\n>\nisExactActive\n• isExactActive: ComputedRef\n<boolean\n>\nroute\n• route: ComputedRef\n<RouteLocationResolvedGeneric\n>\nMethods\nnavigate\n▸ navigate(e?\n): Promise\n<void\n| NavigationFailure\n>\nParameters\nName | Type |\n---|---|\ne? | MouseEvent |\nReturns\nPromise\n<void\n| NavigationFailure\n>",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/uselinkreturn",
      "title": "Interface: UseLinkReturn<Name> | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / RouteLocationAsPathGeneric\nInterface: RouteLocationAsPathGeneric\nGeneric version of RouteLocationAsPath. It is used when no RouteMap is provided.\nHierarchy\n↳\nRouteLocationAsPathGeneric\nProperties\nforce\n• Optional\nforce: boolean\nTriggers the navigation even if the location is the same as the current one. Note this will also add a new entry to the history unless replace: true\nis passed.\nInherited from\nhash\n• Optional\nhash: string\nInherited from\npath\n• path: string\nPercentage encoded pathname section of the URL.\nquery\n• Optional\nquery: LocationQueryRaw\nInherited from\nreplace\n• Optional\nreplace: boolean\nReplace the entry in the history instead of pushing a new entry\nInherited from\nstate\n• Optional\nstate: HistoryState\nState to save using the History API. This cannot contain any reactive values and some primitives like Symbols are forbidden. More info at https://developer.mozilla.org/en-US/docs/Web/API/History/state",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/routelocationaspathgeneric",
      "title": "Interface: RouteLocationAsPathGeneric | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / NavigationFailure\nInterface: NavigationFailure\nExtended Error that contains extra information regarding a failed navigation.\nHierarchy\nError\n↳\nNavigationFailure\nProperties\ncause\n• Optional\ncause: unknown\nInherited from\nError.cause\nfrom\n• from: RouteLocationNormalizedGeneric\nRoute location we were navigating from\nmessage\n• message: string\nInherited from\nError.message\nname\n• name: string\nInherited from\nError.name\nstack\n• Optional\nstack: string\nInherited from\nError.stack\nto\n• to: RouteLocationNormalizedGeneric\nRoute location we were navigating to\ntype\n• type: NAVIGATION_ABORTED\n| NAVIGATION_CANCELLED\n| NAVIGATION_DUPLICATED\nType of the navigation. One of NavigationFailureType",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/navigationfailure",
      "title": "Interface: NavigationFailure | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / RouteLocationResolvedGeneric\nInterface: RouteLocationResolvedGeneric\nGeneric version of RouteLocationResolved. It is used when no RouteMap is provided.\nHierarchy\n↳\nRouteLocationResolvedGeneric\nProperties\nfullPath\n• fullPath: string\nThe whole location including the search\nand hash\n. This string is percentage encoded.\nInherited from\nhash\n• hash: string\nHash of the current location. If present, starts with a #\n.\nInherited from\nhref\n• href: string\nResolved href\nfor the route location that will be set on the <a href=\"...\">\n.\nmatched\n• matched: RouteRecordNormalized\n[]\nArray of RouteRecord containing components as they were passed when adding records. It can also contain redirect records. This can't be used directly. This property is non-enumerable.\nInherited from\nmeta\n• meta: RouteMeta\nMerged meta\nproperties from all the matched route records.\nInherited from\nname\n• name: null\n| RouteRecordNameGeneric\nName of the matched record\nInherited from\nparams\n• params: RouteParamsGeneric\nObject of decoded params extracted from the path\n.\nInherited from\npath\n• path: string\nPercentage encoded pathname section of the URL.\nInherited from\nquery\n• query: LocationQuery\nObject representation of the search\nproperty of the current location.\nInherited from\nredirectedFrom\n• redirectedFrom: undefined\n| RouteLocationGeneric\nContains the location we were initially trying to access before ending up on the current location.",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/routelocationresolvedgeneric",
      "title": "Interface: RouteLocationResolvedGeneric | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / TypesConfig\nInterface: TypesConfig\nAllows customizing existing types of the router that are used globally like $router\n, <RouterLink>\n, etc. ONLY FOR INTERNAL USAGE.\n$router\n- the router instance$route\n- the current route locationbeforeRouteEnter\n- Page component optionbeforeRouteUpdate\n- Page component optionbeforeRouteLeave\n- Page component optionRouterLink\n- RouterLink ComponentRouterView\n- RouterView Component",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/typesconfig",
      "title": "Interface: TypesConfig | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / NavigationGuardWithThis\nInterface: NavigationGuardWithThis<T>\nNavigation Guard with a type parameter for this\n.\nSee\nType parameters\nName |\n---|\nT |\nCallable\nNavigationGuardWithThis\n▸ NavigationGuardWithThis(this\n, to\n, from\n, next\n): _Awaitable\n<NavigationGuardReturn\n>\nParameters\nName | Type |\n---|---|\nthis | T |\nto | RouteLocationNormalizedGeneric |\nfrom | RouteLocationNormalizedLoadedGeneric |\nnext | NavigationGuardNext |",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/navigationguardwiththis",
      "title": "Interface: NavigationGuardWithThis<T> | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / _RouterLinkI\nInterface: _RouterLinkI\nTyped version of the RouterLink\ncomponent. Its generic defaults to the typed router, so it can be inferred automatically for JSX.\nConstructors\nconstructor\n• new _RouterLinkI(): Object\nReturns\nObject\nName | Type |\n---|---|\n$props | AllowedComponentProps & ComponentCustomProps & VNodeProps & RouterLinkProps |\n$slots | { default? : (__namedParameters : { href : string ; isActive : boolean ; isExactActive : boolean ; route : RouteLocationResolvedGeneric ; navigate : (e? : MouseEvent ) => Promise <void | NavigationFailure > }) => VNode <RendererNode , RendererElement , { [key: string] : any ; }>[] } |\n$slots.default? | (__namedParameters : { href : string ; isActive : boolean ; isExactActive : boolean ; route : RouteLocationResolvedGeneric ; navigate : (e? : MouseEvent ) => Promise <void | NavigationFailure > }) => VNode <RendererNode , RendererElement , { [key: string] : any ; }>[] |\nProperties\nuseLink\n• useLink: <Name>(props\n: UseLinkOptions\n<Name\n>) => UseLinkReturn\n<Name\n>\nAccess to useLink()\nwithout depending on using vue-router\nType declaration\n▸ <Name\n>(props\n): UseLinkReturn\n<Name\n>\nAccess to useLink()\nwithout depending on using vue-router\nType parameters\nName | Type |\n---|---|\nName | extends string | symbol = string | symbol |\nParameters\nName | Type |\n---|---|\nprops | UseLinkOptions <Name > |\nReturns\nUseLinkReturn\n<Name\n>",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/routerlinki",
      "title": "Interface: _RouterLinkI | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / RouteRecordSingleViewWithChildren\nInterface: RouteRecordSingleViewWithChildren\nRoute Record defining one single component with a nested view.\nHierarchy\n↳\nRouteRecordSingleViewWithChildren\nProperties\nalias\n• Optional\nalias: string\n| string\n[]\nAliases for the record. Allows defining extra paths that will behave like a copy of the record. Allows having paths shorthands like /users/:id\nand /u/:id\n. All alias\nand path\nvalues must share the same params.\nInherited from\nbeforeEnter\n• Optional\nbeforeEnter: NavigationGuardWithThis\n<undefined\n> | NavigationGuardWithThis\n<undefined\n>[]\nBefore Enter guard specific to this record. Note beforeEnter\nhas no effect if the record has a redirect\nproperty.\nInherited from\nchildren\n• children: RouteRecordRaw\n[]\nArray of nested routes.\nOverrides\ncomponent\n• Optional\ncomponent: null\n| RawRouteComponent\nComponent to display when the URL matches this route.\ncomponents\n• Optional\ncomponents: undefined\nend\n• Optional\nend: boolean\nShould the RegExp match until the end by appending a $\nto it.\nDefault Value\ntrue\nInherited from\nmeta\n• Optional\nmeta: RouteMeta\nArbitrary data attached to the record.\nInherited from\nname\n• Optional\nname: RouteRecordNameGeneric\nName for the route record. Must be unique.\nInherited from\npath\n• path: string\nPath of the record. Should start with /\nunless the record is the child of another record.\nExample\n`/users/:id` matches `/users/1` as well as `/users/posva`.\nInherited from\nprops\n• Optional\nprops: _RouteRecordProps\nAllow passing down params as props to the component rendered by router-view\n.\nOverrides\nredirect\n• Optional\nredirect: RouteRecordRedirectOption\nWhere to redirect if the route is directly matched. The redirection happens before any navigation guard and triggers a new navigation with the new target location.\nInherited from\nsensitive\n• Optional\nsensitive: boolean\nMakes the RegExp case-sensitive.\nDefault Value\nfalse\nInherited from\nstrict\n• Optional\nstrict: boolean\nWhether to disallow a trailing slash or not.\nDefault Value\nfalse",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/routerecordsingleviewwithchildren",
      "title": "Interface: RouteRecordSingleViewWithChildren | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / NavigationGuardNext\nInterface: NavigationGuardNext\nnext()\ncallback passed to navigation guards.\nCallable\nNavigationGuardNext\n▸ NavigationGuardNext(): void\nReturns\nvoid\nNavigationGuardNext\n▸ NavigationGuardNext(error\n): void\nParameters\nName | Type |\n---|---|\nerror | Error |\nReturns\nvoid\nNavigationGuardNext\n▸ NavigationGuardNext(location\n): void\nParameters\nName | Type |\n---|---|\nlocation | string | RouteLocationAsRelativeGeneric | RouteLocationAsPathGeneric |\nReturns\nvoid\nNavigationGuardNext\n▸ NavigationGuardNext(valid\n): void\nParameters\nName | Type |\n---|---|\nvalid | undefined | boolean |\nReturns\nvoid\nNavigationGuardNext\n▸ NavigationGuardNext(cb\n): void\nParameters\nName | Type |\n---|---|\ncb | NavigationGuardNextCallback |\nReturns\nvoid",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/navigationguardnext",
      "title": "Interface: NavigationGuardNext | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / RouteMeta\nInterface: RouteMeta\nInterface to type meta\nfields in route records.\nExample\nts\n// typings.d.ts or router.ts\nimport 'vue-router';\ndeclare module 'vue-router' {\ninterface RouteMeta {\nrequiresAuth?: boolean\n}\n}\nHierarchy\n↳\nRouteMeta",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/routemeta",
      "title": "Interface: RouteMeta | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / NavigationHookAfter\nInterface: NavigationHookAfter\nNavigation hook triggered after a navigation is settled.\nCallable\nNavigationHookAfter\n▸ NavigationHookAfter(to\n, from\n, failure?\n): unknown\nParameters\nName | Type |\n---|---|\nto | RouteLocationNormalizedGeneric |\nfrom | RouteLocationNormalizedLoadedGeneric |\nfailure? | void | NavigationFailure |\nReturns\nunknown",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/navigationhookafter",
      "title": "Interface: NavigationHookAfter | Vue Router"
    }
  },
  {
    "page_content": "English\nAppearance\nComplete guide to\nMastering Pinia\nwritten by its creator\nThe official\nVue.js Certification\nGet certified!\nAPI Documentation / MatcherLocationAsPath\nMatcherLocationAsPath\n↳ RouteLocationPathRaw\nRouteLocationPathRaw\n• path: string\nstring",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/matcherlocationaspath",
      "title": "Interface: MatcherLocationAsPath | Vue Router"
    }
  },
  {
    "page_content": "API Documentation / RouteRecordNormalized\nInterface: RouteRecordNormalized\nNormalized version of a route record.\nHierarchy\nRouteRecordNormalized\nProperties\naliasOf\n• aliasOf: undefined\n| RouteRecordNormalized\nDefines if this record is the alias of another one. This property is undefined\nif the record is the original one.\nbeforeEnter\n• beforeEnter: undefined\n| NavigationGuardWithThis\n<undefined\n> | NavigationGuardWithThis\n<undefined\n>[]\nRegistered beforeEnter guards\nchildren\n• children: RouteRecordRaw\n[]\nNested route records.\ncomponents\n• components: undefined\n| null\n| Record\n<string\n, RawRouteComponent\n>\nComponents to display when the URL matches this route. Allow using named views.\nenterCallbacks\n• enterCallbacks: Record\n<string\n, NavigationGuardNextCallback\n[]>\nRegistered beforeRouteEnter callbacks passed to next\nor returned in guards\ninstances\n• instances: Record\n<string\n, undefined\n| null\n| ComponentPublicInstance\n>\nMounted route component instances Having the instances on the record mean beforeRouteUpdate and beforeRouteLeave guards can only be invoked with the latest mounted app instance if there are multiple application instances rendering the same view, basically duplicating the content on the page, which shouldn't happen in practice. It will work if multiple apps are rendering different named views.\nleaveGuards\n• leaveGuards: Set\n<NavigationGuard\n>\nRegistered leave guards\nmeta\n• meta: RouteMeta\nArbitrary data attached to the record.\nname\n• name: RouteRecordNameGeneric\nName for the route record. Must be unique.\npath\n• path: string\nPath of the record. Should start with /\nunless the record is the child of another record.\nprops\n• props: Record\n<string\n, _RouteRecordProps\n>\nAllow passing down params as props to the component rendered by router-view\n. Should be an object with the same keys as components\nor a boolean to be applied to every component.\nredirect\n• redirect: undefined\n| RouteRecordRedirectOption\nWhere to redirect if the route is directly matched. The redirection happens before any navigation guard and triggers a new navigation with the new target location.\nupdateGuards\n• updateGuards: Set\n<NavigationGuard\n>\nRegistered update guards",
    "metadata": {
      "source": "https://router.vuejs.org/api/interfaces/routerecordnormalized",
      "title": "Interface: RouteRecordNormalized | Vue Router"
    }
  },
  {
    "page_content": "Introduction\nYou are reading the documentation for Vue 3!\n- Vue 2 support has ended on Dec 31, 2023. Learn more about Vue 2 EOL.\n- Upgrading from Vue 2? Check out the Migration Guide.\nWhat is Vue?\nVue (pronounced /vjuː/, like view) is a JavaScript framework for building user interfaces. It builds on top of standard HTML, CSS, and JavaScript and provides a declarative, component-based programming model that helps you efficiently develop user interfaces of any complexity.\nHere is a minimal example:\njs\nimport { createApp, ref } from 'vue'\ncreateApp({\nsetup() {\nreturn {\ncount: ref(0)\n}\n}\n}).mount('#app')\ntemplate\n<div id=\"app\">\n<button @click=\"count++\">\nCount is: {{ count }}\n</button>\n</div>\nResult\nThe above example demonstrates the two core features of Vue:\nDeclarative Rendering: Vue extends standard HTML with a template syntax that allows us to declaratively describe HTML output based on JavaScript state.\nReactivity: Vue automatically tracks JavaScript state changes and efficiently updates the DOM when changes happen.\nYou may already have questions - don't worry. We will cover every little detail in the rest of the documentation. For now, please read along so you can have a high-level understanding of what Vue offers.\nPrerequisites\nThe rest of the documentation assumes basic familiarity with HTML, CSS, and JavaScript. If you are totally new to frontend development, it might not be the best idea to jump right into a framework as your first step - grasp the basics and then come back! You can check your knowledge level with these overviews for JavaScript, HTML and CSS if needed. Prior experience with other frameworks helps, but is not required.\nThe Progressive Framework\nVue is a framework and ecosystem that covers most of the common features needed in frontend development. But the web is extremely diverse - the things we build on the web may vary drastically in form and scale. With that in mind, Vue is designed to be flexible and incrementally adoptable. Depending on your use case, Vue can be used in different ways:\n- Enhancing static HTML without a build step\n- Embedding as Web Components on any page\n- Single-Page Application (SPA)\n- Fullstack / Server-Side Rendering (SSR)\n- Jamstack / Static Site Generation (SSG)\n- Targeting desktop, mobile, WebGL, and even the terminal\nIf you find these concepts intimidating, don't worry! The tutorial and guide only require basic HTML and JavaScript knowledge, and you should be able to follow along without being an expert in any of these.\nIf you are an experienced developer interested in how to best integrate Vue into your stack, or you are curious about what these terms mean, we discuss them in more detail in Ways of Using Vue.\nDespite the flexibility, the core knowledge about how Vue works is shared across all these use cases. Even if you are just a beginner now, the knowledge gained along the way will stay useful as you grow to tackle more ambitious goals in the future. If you are a veteran, you can pick the optimal way to leverage Vue based on the problems you are trying to solve, while retaining the same productivity. This is why we call Vue \"The Progressive Framework\": it's a framework that can grow with you and adapt to your needs.\nSingle-File Components\nIn most build-tool-enabled Vue projects, we author Vue components using an HTML-like file format called Single-File Component (also known as *.vue\nfiles, abbreviated as SFC). A Vue SFC, as the name suggests, encapsulates the component's logic (JavaScript), template (HTML), and styles (CSS) in a single file. Here's the previous example, written in SFC format:\nvue\n<script setup>\nimport { ref } from 'vue'\nconst count = ref(0)\n</script>\n<template>\n<button @click=\"count++\">Count is: {{ count }}</button>\n</template>\n<style scoped>\nbutton {\nfont-weight: bold;\n}\n</style>\nSFC is a defining feature of Vue and is the recommended way to author Vue components if your use case warrants a build setup. You can learn more about the how and why of SFC in its dedicated section - but for now, just know that Vue will handle all the build tools setup for you.\nAPI Styles\nVue components can be authored in two different API styles: Options API and Composition API.\nOptions API\nWith Options API, we define a component's logic using an object of options such as data\n, methods\n, and mounted\n. Properties defined by options are exposed on this\ninside functions, which points to the component instance:\nvue\n<script>\nexport default {\n// Properties returned from data() become reactive state\n// and will be exposed on `this`.\ndata() {\nreturn {\ncount: 0\n}\n},\n// Methods are functions that mutate state and trigger updates.\n// They can be bound as event handlers in templates.\nmethods: {\nincrement() {\nthis.count++\n}\n},\n// Lifecycle hooks are called at different stages\n// of a component's lifecycle.\n// This function will be called when the component is mounted.\nmounted() {\nconsole.log(`The initial count is ${this.count}.`)\n}\n}\n</script>\n<template>\n<button @click=\"increment\">Count is: {{ count }}</button>\n</template>\nComposition API\nWith Composition API, we define a component's logic using imported API functions. In SFCs, Composition API is typically used with <script setup>\n. The setup\nattribute is a hint that makes Vue perform compile-time transforms that allow us to use Composition API with less boilerplate. For example, imports and top-level variables / functions declared in <script setup>\nare directly usable in the template.\nHere is the same component, with the exact same template, but using Composition API and <script setup>\ninstead:\nvue\n<script setup>\nimport { ref, onMounted } from 'vue'\n// reactive state\nconst count = ref(0)\n// functions that mutate state and trigger updates\nfunction increment() {\ncount.value++\n}\n// lifecycle hooks\nonMounted(() => {\nconsole.log(`The initial count is ${count.value}.`)\n})\n</script>\n<template>\n<button @click=\"increment\">Count is: {{ count }}</button>\n</template>\nWhich to Choose?\nBoth API styles are fully capable of covering common use cases. They are different interfaces powered by the exact same underlying system. In fact, the Options API is implemented on top of the Composition API! The fundamental concepts and knowledge about Vue are shared across the two styles.\nThe Options API is centered around the concept of a \"component instance\" (this\nas seen in the example), which typically aligns better with a class-based mental model for users coming from OOP language backgrounds. It is also more beginner-friendly by abstracting away the reactivity details and enforcing code organization via option groups.\nThe Composition API is centered around declaring reactive state variables directly in a function scope and composing state from multiple functions together to handle complexity. It is more free-form and requires an understanding of how reactivity works in Vue to be used effectively. In return, its flexibility enables more powerful patterns for organizing and reusing logic.\nYou can learn more about the comparison between the two styles and the potential benefits of Composition API in the Composition API FAQ.\nIf you are new to Vue, here's our general recommendation:\nFor learning purposes, go with the style that looks easier to understand to you. Again, most of the core concepts are shared between the two styles. You can always pick up the other style later.\nFor production use:\nGo with Options API if you are not using build tools, or plan to use Vue primarily in low-complexity scenarios, e.g. progressive enhancement.\nGo with Composition API + Single-File Components if you plan to build full applications with Vue.\nYou don't have to commit to only one style during the learning phase. The rest of the documentation will provide code samples in both styles where applicable, and you can toggle between them at any time using the API Preference switches at the top of the left sidebar.\nStill Got Questions?\nCheck out our FAQ.\nPick Your Learning Path\nDifferent developers have different learning styles. Feel free to pick a learning path that suits your preference - although we do recommend going over all of the content, if possible!",
    "metadata": {
      "source": "https://vuejs.org/guide/",
      "title": "Introduction | Vue.js"
    }
  },
  {
    "page_content": "List Rendering\nv-for\nWe can use the v-for\ndirective to render a list of items based on an array. The v-for\ndirective requires a special syntax in the form of item in items\n, where items\nis the source data array and item\nis an alias for the array element being iterated on:\njs\nconst items = ref([{ message: 'Foo' }, { message: 'Bar' }])\ntemplate\n<li v-for=\"item in items\">\n{{ item.message }}\n</li>\nInside the v-for\nscope, template expressions have access to all parent scope properties. In addition, v-for\nalso supports an optional second alias for the index of the current item:\njs\nconst parentMessage = ref('Parent')\nconst items = ref([{ message: 'Foo' }, { message: 'Bar' }])\ntemplate\n<li v-for=\"(item, index) in items\">\n{{ parentMessage }} - {{ index }} - {{ item.message }}\n</li>\nThe variable scoping of v-for\nis similar to the following JavaScript:\njs\nconst parentMessage = 'Parent'\nconst items = [\n/* ... */\n]\nitems.forEach((item, index) => {\n// has access to outer scope `parentMessage`\n// but `item` and `index` are only available in here\nconsole.log(parentMessage, item.message, index)\n})\nNotice how the v-for\nvalue matches the function signature of the forEach\ncallback. In fact, you can use destructuring on the v-for\nitem alias similar to destructuring function arguments:\ntemplate\n<li v-for=\"{ message } in items\">\n{{ message }}\n</li>\n<!-- with index alias -->\n<li v-for=\"({ message }, index) in items\">\n{{ message }} {{ index }}\n</li>\nFor nested v-for\n, scoping also works similar to nested functions. Each v-for\nscope has access to parent scopes:\ntemplate\n<li v-for=\"item in items\">\n<span v-for=\"childItem in item.children\">\n{{ item.message }} {{ childItem }}\n</span>\n</li>\nYou can also use of\nas the delimiter instead of in\n, so that it is closer to JavaScript's syntax for iterators:\ntemplate\n<div v-for=\"item of items\"></div>\nv-for\nwith an Object\nYou can also use v-for\nto iterate through the properties of an object. The iteration order will be based on the result of calling Object.keys()\non the object:\njs\nconst myObject = reactive({\ntitle: 'How to do lists in Vue',\nauthor: 'Jane Doe',\npublishedAt: '2016-04-10'\n})\ntemplate\n<ul>\n<li v-for=\"value in myObject\">\n{{ value }}\n</li>\n</ul>\nYou can also provide a second alias for the property's name (a.k.a. key):\ntemplate\n<li v-for=\"(value, key) in myObject\">\n{{ key }}: {{ value }}\n</li>\nAnd another for the index:\ntemplate\n<li v-for=\"(value, key, index) in myObject\">\n{{ index }}. {{ key }}: {{ value }}\n</li>\nv-for\nwith a Range\nv-for\ncan also take an integer. In this case it will repeat the template that many times, based on a range of 1...n\n.\ntemplate\n<span v-for=\"n in 10\">{{ n }}</span>\nNote here n\nstarts with an initial value of 1\ninstead of 0\n.\nv-for\non <template>\nSimilar to template v-if\n, you can also use a <template>\ntag with v-for\nto render a block of multiple elements. For example:\ntemplate\n<ul>\n<template v-for=\"item in items\">\n<li>{{ item.msg }}</li>\n<li class=\"divider\" role=\"presentation\"></li>\n</template>\n</ul>\nv-for\nwith v-if\nNote\nIt's not recommended to use v-if\nand v-for\non the same element due to implicit precedence. Refer to style guide for details.\nWhen they exist on the same node, v-if\nhas a higher priority than v-for\n. That means the v-if\ncondition will not have access to variables from the scope of the v-for\n:\ntemplate\n<!--\nThis will throw an error because property \"todo\"\nis not defined on instance.\n-->\n<li v-for=\"todo in todos\" v-if=\"!todo.isComplete\">\n{{ todo.name }}\n</li>\nThis can be fixed by moving v-for\nto a wrapping <template>\ntag (which is also more explicit):\ntemplate\n<template v-for=\"todo in todos\">\n<li v-if=\"!todo.isComplete\">\n{{ todo.name }}\n</li>\n</template>\nMaintaining State with key\nWhen Vue is updating a list of elements rendered with v-for\n, by default it uses an \"in-place patch\" strategy. If the order of the data items has changed, instead of moving the DOM elements to match the order of the items, Vue will patch each element in-place and make sure it reflects what should be rendered at that particular index.\nThis default mode is efficient, but only suitable when your list render output does not rely on child component state or temporary DOM state (e.g. form input values).\nTo give Vue a hint so that it can track each node's identity, and thus reuse and reorder existing elements, you need to provide a unique key\nattribute for each item:\ntemplate\n<div v-for=\"item in items\" :key=\"item.id\">\n<!-- content -->\n</div>\nWhen using <template v-for>\n, the key\nshould be placed on the <template>\ncontainer:\ntemplate\n<template v-for=\"todo in todos\" :key=\"todo.name\">\n<li>{{ todo.name }}</li>\n</template>\nNote\nkey\nhere is a special attribute being bound with v-bind\n. It should not be confused with the property key variable when using v-for\nwith an object.\nIt is recommended to provide a key\nattribute with v-for\nwhenever possible, unless the iterated DOM content is simple (i.e. contains no components or stateful DOM elements), or you are intentionally relying on the default behavior for performance gains.\nThe key\nbinding expects primitive values - i.e. strings and numbers. Do not use objects as v-for\nkeys. For detailed usage of the key\nattribute, please see the key\nAPI documentation.\nv-for\nwith a Component\nThis section assumes knowledge of Components. Feel free to skip it and come back later.\nYou can directly use v-for\non a component, like any normal element (don't forget to provide a key\n):\ntemplate\n<MyComponent v-for=\"item in items\" :key=\"item.id\" />\nHowever, this won't automatically pass any data to the component, because components have isolated scopes of their own. In order to pass the iterated data into the component, we should also use props:\ntemplate\n<MyComponent\nv-for=\"(item, index) in items\"\n:item=\"item\"\n:index=\"index\"\n:key=\"item.id\"\n/>\nThe reason for not automatically injecting item\ninto the component is because that makes the component tightly coupled to how v-for\nworks. Being explicit about where its data comes from makes the component reusable in other situations.\nCheck out this example of a simple todo list to see how to render a list of components using v-for\n, passing different data to each instance.\nArray Change Detection\nMutation Methods\nVue is able to detect when a reactive array's mutation methods are called and trigger necessary updates. These mutation methods are:\npush()\npop()\nshift()\nunshift()\nsplice()\nsort()\nreverse()\nReplacing an Array\nMutation methods, as the name suggests, mutate the original array they are called on. In comparison, there are also non-mutating methods, e.g. filter()\n, concat()\nand slice()\n, which do not mutate the original array but always return a new array. When working with non-mutating methods, we should replace the old array with the new one:\njs\n// `items` is a ref with array value\nitems.value = items.value.filter((item) => item.message.match(/Foo/))\nYou might think this will cause Vue to throw away the existing DOM and re-render the entire list - luckily, that is not the case. Vue implements some smart heuristics to maximize DOM element reuse, so replacing an array with another array containing overlapping objects is a very efficient operation.\nDisplaying Filtered/Sorted Results\nSometimes we want to display a filtered or sorted version of an array without actually mutating or resetting the original data. In this case, you can create a computed property that returns the filtered or sorted array.\nFor example:\njs\nconst numbers = ref([1, 2, 3, 4, 5])\nconst evenNumbers = computed(() => {\nreturn numbers.value.filter((n) => n % 2 === 0)\n})\ntemplate\n<li v-for=\"n in evenNumbers\">{{ n }}</li>\nIn situations where computed properties are not feasible (e.g. inside nested v-for\nloops), you can use a method:\njs\nconst sets = ref([\n[1, 2, 3, 4, 5],\n[6, 7, 8, 9, 10]\n])\nfunction even(numbers) {\nreturn numbers.filter((number) => number % 2 === 0)\n}\ntemplate\n<ul v-for=\"numbers in sets\">\n<li v-for=\"n in even(numbers)\">{{ n }}</li>\n</ul>\nBe careful with reverse()\nand sort()\nin a computed property! These two methods will mutate the original array, which should be avoided in computed getters. Create a copy of the original array before calling these methods:\ndiff\n- return numbers.reverse()\n+ return [...numbers].reverse()",
    "metadata": {
      "source": "https://vuejs.org/guide/essentials/list",
      "title": "List Rendering | Vue.js"
    }
  },
  {
    "page_content": "TransitionGroup\n<TransitionGroup>\nis a built-in component designed for animating the insertion, removal, and order change of elements or components that are rendered in a list.\nDifferences from <Transition>\n<TransitionGroup>\nsupports the same props, CSS transition classes, and JavaScript hook listeners as <Transition>\n, with the following differences:\nBy default, it doesn't render a wrapper element. But you can specify an element to be rendered with the\ntag\nprop.Transition modes are not available, because we are no longer alternating between mutually exclusive elements.\nElements inside are always required to have a unique\nkey\nattribute.CSS transition classes will be applied to individual elements in the list, not to the group / container itself.\nTIP\nWhen used in in-DOM templates, it should be referenced as <transition-group>\n.\nEnter / Leave Transitions\nHere is an example of applying enter / leave transitions to a v-for\nlist using <TransitionGroup>\n:\ntemplate\n<TransitionGroup name=\"list\" tag=\"ul\">\n<li v-for=\"item in items\" :key=\"item\">\n{{ item }}\n</li>\n</TransitionGroup>\ncss\n.list-enter-active,\n.list-leave-active {\ntransition: all 0.5s ease;\n}\n.list-enter-from,\n.list-leave-to {\nopacity: 0;\ntransform: translateX(30px);\n}\n- 1\n- 2\n- 3\n- 4\n- 5\nMove Transitions\nThe above demo has some obvious flaws: when an item is inserted or removed, its surrounding items instantly \"jump\" into place instead of moving smoothly. We can fix this by adding a few additional CSS rules:\ncss\n.list-move, /* apply transition to moving elements */\n.list-enter-active,\n.list-leave-active {\ntransition: all 0.5s ease;\n}\n.list-enter-from,\n.list-leave-to {\nopacity: 0;\ntransform: translateX(30px);\n}\n/* ensure leaving items are taken out of layout flow so that moving\nanimations can be calculated correctly. */\n.list-leave-active {\nposition: absolute;\n}\nNow it looks much better - even animating smoothly when the whole list is shuffled:\n- 1\n- 2\n- 3\n- 4\n- 5\nStaggering List Transitions\nBy communicating with JavaScript transitions through data attributes, it's also possible to stagger transitions in a list. First, we render the index of an item as a data attribute on the DOM element:\ntemplate\n<TransitionGroup\ntag=\"ul\"\n:css=\"false\"\n@before-enter=\"onBeforeEnter\"\n@enter=\"onEnter\"\n@leave=\"onLeave\"\n>\n<li\nv-for=\"(item, index) in computedList\"\n:key=\"item.msg\"\n:data-index=\"index\"\n>\n{{ item.msg }}\n</li>\n</TransitionGroup>\nThen, in JavaScript hooks, we animate the element with a delay based on the data attribute. This example is using the GSAP library to perform the animation:\njs\nfunction onEnter(el, done) {\ngsap.to(el, {\nopacity: 1,\nheight: '1.6em',\ndelay: el.dataset.index * 0.15,\nonComplete: done\n})\n}\n- Bruce Lee\n- Jackie Chan\n- Chuck Norris\n- Jet Li\n- Kung Fury\nRelated",
    "metadata": {
      "source": "https://vuejs.org/guide/built-ins/transition-group",
      "title": "TransitionGroup | Vue.js"
    }
  },
  {
    "page_content": "Async Components\nBasic Usage\nIn large applications, we may need to divide the app into smaller chunks and only load a component from the server when it's needed. To make that possible, Vue has a defineAsyncComponent\nfunction:\njs\nimport { defineAsyncComponent } from 'vue'\nconst AsyncComp = defineAsyncComponent(() => {\nreturn new Promise((resolve, reject) => {\n// ...load component from server\nresolve(/* loaded component */)\n})\n})\n// ... use `AsyncComp` like a normal component\nAs you can see, defineAsyncComponent\naccepts a loader function that returns a Promise. The Promise's resolve\ncallback should be called when you have retrieved your component definition from the server. You can also call reject(reason)\nto indicate the load has failed.\nES module dynamic import also returns a Promise, so most of the time we will use it in combination with defineAsyncComponent\n. Bundlers like Vite and webpack also support the syntax (and will use it as bundle split points), so we can use it to import Vue SFCs:\njs\nimport { defineAsyncComponent } from 'vue'\nconst AsyncComp = defineAsyncComponent(() =>\nimport('./components/MyComponent.vue')\n)\nThe resulting AsyncComp\nis a wrapper component that only calls the loader function when it is actually rendered on the page. In addition, it will pass along any props and slots to the inner component, so you can use the async wrapper to seamlessly replace the original component while achieving lazy loading.\nAs with normal components, async components can be registered globally using app.component()\n:\njs\napp.component('MyComponent', defineAsyncComponent(() =>\nimport('./components/MyComponent.vue')\n))\nThey can also be defined directly inside their parent component:\nvue\n<script setup>\nimport { defineAsyncComponent } from 'vue'\nconst AdminPage = defineAsyncComponent(() =>\nimport('./components/AdminPageComponent.vue')\n)\n</script>\n<template>\n<AdminPage />\n</template>\nLoading and Error States\nAsynchronous operations inevitably involve loading and error states - defineAsyncComponent()\nsupports handling these states via advanced options:\njs\nconst AsyncComp = defineAsyncComponent({\n// the loader function\nloader: () => import('./Foo.vue'),\n// A component to use while the async component is loading\nloadingComponent: LoadingComponent,\n// Delay before showing the loading component. Default: 200ms.\ndelay: 200,\n// A component to use if the load fails\nerrorComponent: ErrorComponent,\n// The error component will be displayed if a timeout is\n// provided and exceeded. Default: Infinity.\ntimeout: 3000\n})\nIf a loading component is provided, it will be displayed first while the inner component is being loaded. There is a default 200ms delay before the loading component is shown - this is because on fast networks, an instant loading state may get replaced too fast and end up looking like a flicker.\nIf an error component is provided, it will be displayed when the Promise returned by the loader function is rejected. You can also specify a timeout to show the error component when the request is taking too long.\nUsing with Suspense\nAsync components can be used with the <Suspense>\nbuilt-in component. The interaction between <Suspense>\nand async components is documented in the dedicated chapter for <Suspense>\n.",
    "metadata": {
      "source": "https://vuejs.org/guide/components/async",
      "title": "Async Components | Vue.js"
    }
  },
  {
    "page_content": "Tooling\nTry It Online\nYou don't need to install anything on your machine to try out Vue SFCs - there are online playgrounds that allow you to do so right in the browser:\n- Vue SFC Playground\n- Always deployed from latest commit\n- Designed for inspecting component compilation results\n- Vue + Vite on StackBlitz\n- IDE-like environment running actual Vite dev server in the browser\n- Closest to local setup\nIt is also recommended to use these online playgrounds to provide reproductions when reporting bugs.\nProject Scaffolding\nVite\nVite is a lightweight and fast build tool with first-class Vue SFC support. It is created by Evan You, who is also the author of Vue!\nTo get started with Vite + Vue, simply run:\nnpm\npnpm\nyarn\nbun\nsh\n$ npm create vue@latest\nThis command will install and execute create-vue, the official Vue project scaffolding tool.\n- To learn more about Vite, check out the Vite docs.\n- To configure Vue-specific behavior in a Vite project, for example passing options to the Vue compiler, check out the docs for @vitejs/plugin-vue.\nBoth online playgrounds mentioned above also support downloading files as a Vite project.\nVue CLI\nVue CLI is the official webpack-based toolchain for Vue. It is now in maintenance mode and we recommend starting new projects with Vite unless you rely on specific webpack-only features. Vite will provide superior developer experience in most cases.\nFor information on migrating from Vue CLI to Vite:\nNote on In-Browser Template Compilation\nWhen using Vue without a build step, component templates are written either directly in the page's HTML or as inlined JavaScript strings. In such cases, Vue needs to ship the template compiler to the browser in order to perform on-the-fly template compilation. On the other hand, the compiler would be unnecessary if we pre-compile the templates with a build step. To reduce client bundle size, Vue provides different \"builds\" optimized for different use cases.\nBuild files that start with\nvue.runtime.*\nare runtime-only builds: they do not include the compiler. When using these builds, all templates must be pre-compiled via a build step.Build files that do not include\n.runtime\nare full builds: they include the compiler and support compiling templates directly in the browser. However, they will increase the payload by ~14kb.\nOur default tooling setups use the runtime-only build since all templates in SFCs are pre-compiled. If, for some reason, you need in-browser template compilation even with a build step, you can do so by configuring the build tool to alias vue\nto vue/dist/vue.esm-bundler.js\ninstead.\nIf you are looking for a lighter-weight alternative for no-build-step usage, check out petite-vue.\nIDE Support\nThe recommended IDE setup is VS Code + the Vue - Official extension (previously Volar). The extension provides syntax highlighting, TypeScript support, and intellisense for template expressions and component props.\nTIP\nVue - Official replaces Vetur, our previous official VS Code extension for Vue 2. If you have Vetur currently installed, make sure to disable it in Vue 3 projects.\nWebStorm also provides great built-in support for Vue SFCs.\nOther IDEs that support the Language Service Protocol (LSP) can also leverage Volar's core functionalities via LSP:\nBrowser Devtools\nThe Vue browser devtools extension allows you to explore a Vue app's component tree, inspect the state of individual components, track state management events, and profile performance.\nTypeScript\nMain article: Using Vue with TypeScript.\nVue - Official extension provides type checking for SFCs using\n<script lang=\"ts\">\nblocks, including template expressions and cross-component props validation.Use\nvue-tsc\nfor performing the same type checking from the command line, or for generatingd.ts\nfiles for SFCs.\nTesting\nMain article: Testing Guide.\nCypress is recommended for E2E tests. It can also be used for component testing for Vue SFCs via the Cypress Component Test Runner.\nVitest is a test runner created by Vue / Vite team members that focuses on speed. It is specifically designed for Vite-based applications to provide the same instant feedback loop for unit / component testing.\nJest can be made to work with Vite via vite-jest. However, this is only recommended if you have existing Jest-based test suites that you need to migrate over to a Vite-based setup, as Vitest provides similar functionalities with a much more efficient integration.\nLinting\nThe Vue team maintains eslint-plugin-vue, an ESLint plugin that supports SFC-specific linting rules.\nUsers previously using Vue CLI may be used to having linters configured via webpack loaders. However when using a Vite-based build setup, our general recommendation is:\nnpm install -D eslint eslint-plugin-vue\n, then followeslint-plugin-vue\n's configuration guide.Setup ESLint IDE extensions, for example ESLint for VS Code, so you get linter feedback right in your editor during development. This also avoids unnecessary linting cost when starting the dev server.\nRun ESLint as part of the production build command, so you get full linter feedback before shipping to production.\n(Optional) Setup tools like lint-staged to automatically lint modified files on git commit.\nFormatting\nThe Vue - Official VS Code extension provides formatting for Vue SFCs out of the box.\nAlternatively, Prettier provides built-in Vue SFC formatting support.\nSFC Custom Block Integrations\nCustom blocks are compiled into imports to the same Vue file with different request queries. It is up to the underlying build tool to handle these import requests.\nIf using Vite, a custom Vite plugin should be used to transform matched custom blocks into executable JavaScript. Example\nIf using Vue CLI or plain webpack, a webpack loader should be configured to transform the matched blocks. Example\nLower-Level Packages\n@vue/compiler-sfc\nThis package is part of the Vue core monorepo and is always published with the same version as the main vue\npackage. It is included as a dependency of the main vue\npackage and proxied under vue/compiler-sfc\nso you don't need to install it individually.\nThe package itself provides lower-level utilities for processing Vue SFCs and is only meant for tooling authors that need to support Vue SFCs in custom tools.\nTIP\nAlways prefer using this package via the vue/compiler-sfc\ndeep import since this ensures its version is in sync with the Vue runtime.\n@vitejs/plugin-vue\nOfficial plugin that provides Vue SFC support in Vite.\nvue-loader\nThe official loader that provides Vue SFC support in webpack. If you are using Vue CLI, also see docs on modifying vue-loader\noptions in Vue CLI.",
    "metadata": {
      "source": "https://vuejs.org/guide/scaling-up/tooling",
      "title": "Tooling | Vue.js"
    }
  },
  {
    "page_content": "Using Vue with TypeScript\nA type system like TypeScript can detect many common errors via static analysis at build time. This reduces the chance of runtime errors in production, and also allows us to more confidently refactor code in large-scale applications. TypeScript also improves developer ergonomics via type-based auto-completion in IDEs.\nVue is written in TypeScript itself and provides first-class TypeScript support. All official Vue packages come with bundled type declarations that should work out-of-the-box.\nProject Setup\ncreate-vue\n, the official project scaffolding tool, offers the options to scaffold a Vite-powered, TypeScript-ready Vue project.\nOverview\nWith a Vite-based setup, the dev server and the bundler are transpilation-only and do not perform any type-checking. This ensures the Vite dev server stays blazing fast even when using TypeScript.\nDuring development, we recommend relying on a good IDE setup for instant feedback on type errors.\nIf using SFCs, use the\nvue-tsc\nutility for command line type checking and type declaration generation.vue-tsc\nis a wrapper aroundtsc\n, TypeScript's own command line interface. It works largely the same astsc\nexcept that it supports Vue SFCs in addition to TypeScript files. You can runvue-tsc\nin watch mode in parallel to the Vite dev server, or use a Vite plugin like vite-plugin-checker which runs the checks in a separate worker thread.Vue CLI also provides TypeScript support, but is no longer recommended. See notes below.\nIDE Support\nVisual Studio Code (VS Code) is strongly recommended for its great out-of-the-box support for TypeScript.\nVue - Official (previously Volar) is the official VS Code extension that provides TypeScript support inside Vue SFCs, along with many other great features.\nTIP\nVue - Official extension replaces Vetur, our previous official VS Code extension for Vue 2. If you have Vetur currently installed, make sure to disable it in Vue 3 projects.\nWebStorm also provides out-of-the-box support for both TypeScript and Vue. Other JetBrains IDEs support them too, either out of the box or via a free plugin. As of version 2023.2, WebStorm and the Vue Plugin come with built-in support for the Vue Language Server. You can set the Vue service to use Volar integration on all TypeScript versions, under Settings > Languages & Frameworks > TypeScript > Vue. By default, Volar will be used for TypeScript versions 5.0 and higher.\nConfiguring tsconfig.json\nProjects scaffolded via create-vue\ninclude pre-configured tsconfig.json\n. The base config is abstracted in the @vue/tsconfig\npackage. Inside the project, we use Project References to ensure correct types for code running in different environments (e.g. app code and test code should have different global variables).\nWhen configuring tsconfig.json\nmanually, some notable options include:\ncompilerOptions.isolatedModules\nis set totrue\nbecause Vite uses esbuild for transpiling TypeScript and is subject to single-file transpile limitations.compilerOptions.verbatimModuleSyntax\nis a superset ofisolatedModules\nand is a good choice, too - it's what@vue/tsconfig\nuses.If you're using Options API, you need to set\ncompilerOptions.strict\ntotrue\n(or at least enablecompilerOptions.noImplicitThis\n, which is a part of thestrict\nflag) to leverage type checking ofthis\nin component options. Otherwisethis\nwill be treated asany\n.If you have configured resolver aliases in your build tool, for example the\n@/*\nalias configured by default in acreate-vue\nproject, you need to also configure it for TypeScript viacompilerOptions.paths\n.If you intend to use TSX with Vue, set\ncompilerOptions.jsx\nto\"preserve\"\n, and setcompilerOptions.jsxImportSource\nto\"vue\"\n.\nSee also:\nNote on Vue CLI and ts-loader\nIn webpack-based setups such as Vue CLI, it is common to perform type checking as part of the module transform pipeline, for example with ts-loader\n. This, however, isn't a clean solution because the type system needs knowledge of the entire module graph to perform type checks. Individual module's transform step simply is not the right place for the task. It leads to the following problems:\nts-loader\ncan only type check post-transform code. This doesn't align with the errors we see in IDEs or fromvue-tsc\n, which map directly back to the source code.Type checking can be slow. When it is performed in the same thread / process with code transformations, it significantly affects the build speed of the entire application.\nWe already have type checking running right in our IDE in a separate process, so the cost of dev experience slow down simply isn't a good trade-off.\nIf you are currently using Vue 3 + TypeScript via Vue CLI, we strongly recommend migrating over to Vite. We are also working on CLI options to enable transpile-only TS support, so that you can switch to vue-tsc\nfor type checking.\nGeneral Usage Notes\ndefineComponent()\nTo let TypeScript properly infer types inside component options, we need to define components with defineComponent()\n:\nts\nimport { defineComponent } from 'vue'\nexport default defineComponent({\n// type inference enabled\nprops: {\nname: String,\nmsg: { type: String, required: true }\n},\ndata() {\nreturn {\ncount: 1\n}\n},\nmounted() {\nthis.name // type: string | undefined\nthis.msg // type: string\nthis.count // type: number\n}\n})\ndefineComponent()\nalso supports inferring the props passed to setup()\nwhen using Composition API without <script setup>\n:\nts\nimport { defineComponent } from 'vue'\nexport default defineComponent({\n// type inference enabled\nprops: {\nmessage: String\n},\nsetup(props) {\nprops.message // type: string | undefined\n}\n})\nSee also:\nTIP\ndefineComponent()\nalso enables type inference for components defined in plain JavaScript.\nUsage in Single-File Components\nTo use TypeScript in SFCs, add the lang=\"ts\"\nattribute to <script>\ntags. When lang=\"ts\"\nis present, all template expressions also enjoy stricter type checking.\nvue\n<script lang=\"ts\">\nimport { defineComponent } from 'vue'\nexport default defineComponent({\ndata() {\nreturn {\ncount: 1\n}\n}\n})\n</script>\n<template>\n<!-- type checking and auto-completion enabled -->\n{{ count.toFixed(2) }}\n</template>\nlang=\"ts\"\ncan also be used with <script setup>\n:\nvue\n<script setup lang=\"ts\">\n// TypeScript enabled\nimport { ref } from 'vue'\nconst count = ref(1)\n</script>\n<template>\n<!-- type checking and auto-completion enabled -->\n{{ count.toFixed(2) }}\n</template>\nTypeScript in Templates\nThe <template>\nalso supports TypeScript in binding expressions when <script lang=\"ts\">\nor <script setup lang=\"ts\">\nis used. This is useful in cases where you need to perform type casting in template expressions.\nHere's a contrived example:\nvue\n<script setup lang=\"ts\">\nlet x: string | number = 1\n</script>\n<template>\n<!-- error because x could be a string -->\n{{ x.toFixed(2) }}\n</template>\nThis can be worked around with an inline type cast:\nvue\n<script setup lang=\"ts\">\nlet x: string | number = 1\n</script>\n<template>\n{{ (x as number).toFixed(2) }}\n</template>\nTIP\nIf using Vue CLI or a webpack-based setup, TypeScript in template expressions requires vue-loader@^16.8.0\n.\nUsage with TSX\nVue also supports authoring components with JSX / TSX. Details are covered in the Render Function & JSX guide.\nGeneric Components\nGeneric components are supported in two cases:\n- In SFCs:\n<script setup>\nwith thegeneric\nattribute - Render function / JSX components:\ndefineComponent()\n's function signature",
    "metadata": {
      "source": "https://vuejs.org/guide/typescript/overview",
      "title": "Using Vue with TypeScript | Vue.js"
    }
  },
  {
    "page_content": "Transition\nVue offers two built-in components that can help work with transitions and animations in response to changing state:\n<Transition>\nfor applying animations when an element or component is entering and leaving the DOM. This is covered on this page.<TransitionGroup>\nfor applying animations when an element or component is inserted into, removed from, or moved within av-for\nlist. This is covered in the next chapter.\nAside from these two components, we can also apply animations in Vue using other techniques such as toggling CSS classes or state-driven animations via style bindings. These additional techniques are covered in the Animation Techniques chapter.\nThe <Transition>\nComponent\n<Transition>\nis a built-in component: this means it is available in any component's template without having to register it. It can be used to apply enter and leave animations on elements or components passed to it via its default slot. The enter or leave can be triggered by one of the following:\n- Conditional rendering via\nv-if\n- Conditional display via\nv-show\n- Dynamic components toggling via the\n<component>\nspecial element - Changing the special\nkey\nattribute\nThis is an example of the most basic usage:\ntemplate\n<button @click=\"show = !show\">Toggle</button>\n<Transition>\n<p v-if=\"show\">hello</p>\n</Transition>\ncss\n/* we will explain what these classes do next! */\n.v-enter-active,\n.v-leave-active {\ntransition: opacity 0.5s ease;\n}\n.v-enter-from,\n.v-leave-to {\nopacity: 0;\n}\nhello\nTIP\n<Transition>\nonly supports a single element or component as its slot content. If the content is a component, the component must also have only one single root element.\nWhen an element in a <Transition>\ncomponent is inserted or removed, this is what happens:\nVue will automatically sniff whether the target element has CSS transitions or animations applied. If it does, a number of CSS transition classes will be added / removed at appropriate timings.\nIf there are listeners for JavaScript hooks, these hooks will be called at appropriate timings.\nIf no CSS transitions / animations are detected and no JavaScript hooks are provided, the DOM operations for insertion and/or removal will be executed on the browser's next animation frame.\nCSS-Based Transitions\nTransition Classes\nThere are six classes applied for enter / leave transitions.\nv-enter-from\n: Starting state for enter. Added before the element is inserted, removed one frame after the element is inserted.v-enter-active\n: Active state for enter. Applied during the entire entering phase. Added before the element is inserted, removed when the transition/animation finishes. This class can be used to define the duration, delay and easing curve for the entering transition.v-enter-to\n: Ending state for enter. Added one frame after the element is inserted (at the same timev-enter-from\nis removed), removed when the transition/animation finishes.v-leave-from\n: Starting state for leave. Added immediately when a leaving transition is triggered, removed after one frame.v-leave-active\n: Active state for leave. Applied during the entire leaving phase. Added immediately when a leaving transition is triggered, removed when the transition/animation finishes. This class can be used to define the duration, delay and easing curve for the leaving transition.v-leave-to\n: Ending state for leave. Added one frame after a leaving transition is triggered (at the same timev-leave-from\nis removed), removed when the transition/animation finishes.\nv-enter-active\nand v-leave-active\ngive us the ability to specify different easing curves for enter / leave transitions, which we'll see an example of in the following sections.\nNamed Transitions\nA transition can be named via the name\nprop:\ntemplate\n<Transition name=\"fade\">\n...\n</Transition>\nFor a named transition, its transition classes will be prefixed with its name instead of v\n. For example, the applied class for the above transition will be fade-enter-active\ninstead of v-enter-active\n. The CSS for the fade transition should look like this:\ncss\n.fade-enter-active,\n.fade-leave-active {\ntransition: opacity 0.5s ease;\n}\n.fade-enter-from,\n.fade-leave-to {\nopacity: 0;\n}\nCSS Transitions\n<Transition>\nis most commonly used in combination with native CSS transitions, as seen in the basic example above. The transition\nCSS property is a shorthand that allows us to specify multiple aspects of a transition, including properties that should be animated, duration of the transition, and easing curves.\nHere is a more advanced example that transitions multiple properties, with different durations and easing curves for enter and leave:\ntemplate\n<Transition name=\"slide-fade\">\n<p v-if=\"show\">hello</p>\n</Transition>\ncss\n/*\nEnter and leave animations can use different\ndurations and timing functions.\n*/\n.slide-fade-enter-active {\ntransition: all 0.3s ease-out;\n}\n.slide-fade-leave-active {\ntransition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1);\n}\n.slide-fade-enter-from,\n.slide-fade-leave-to {\ntransform: translateX(20px);\nopacity: 0;\n}\nhello\nCSS Animations\nNative CSS animations are applied in the same way as CSS transitions, with the difference being that *-enter-from\nis not removed immediately after the element is inserted, but on an animationend\nevent.\nFor most CSS animations, we can simply declare them under the *-enter-active\nand *-leave-active\nclasses. Here's an example:\ntemplate\n<Transition name=\"bounce\">\n<p v-if=\"show\" style=\"text-align: center;\">\nHello here is some bouncy text!\n</p>\n</Transition>\ncss\n.bounce-enter-active {\nanimation: bounce-in 0.5s;\n}\n.bounce-leave-active {\nanimation: bounce-in 0.5s reverse;\n}\n@keyframes bounce-in {\n0% {\ntransform: scale(0);\n}\n50% {\ntransform: scale(1.25);\n}\n100% {\ntransform: scale(1);\n}\n}\nHello here is some bouncy text!\nCustom Transition Classes\nYou can also specify custom transition classes by passing the following props to <Transition>\n:\nenter-from-class\nenter-active-class\nenter-to-class\nleave-from-class\nleave-active-class\nleave-to-class\nThese will override the conventional class names. This is especially useful when you want to combine Vue's transition system with an existing CSS animation library, such as Animate.css:\ntemplate\n<!-- assuming Animate.css is included on the page -->\n<Transition\nname=\"custom-classes\"\nenter-active-class=\"animate__animated animate__tada\"\nleave-active-class=\"animate__animated animate__bounceOutRight\"\n>\n<p v-if=\"show\">hello</p>\n</Transition>\nUsing Transitions and Animations Together\nVue needs to attach event listeners in order to know when a transition has ended. It can either be transitionend\nor animationend\n, depending on the type of CSS rules applied. If you are only using one or the other, Vue can automatically detect the correct type.\nHowever, in some cases you may want to have both on the same element, for example having a CSS animation triggered by Vue, along with a CSS transition effect on hover. In these cases, you will have to explicitly declare the type you want Vue to care about by passing the type\nprop, with a value of either animation\nor transition\n:\ntemplate\n<Transition type=\"animation\">...</Transition>\nNested Transitions and Explicit Transition Durations\nAlthough the transition classes are only applied to the direct child element in <Transition>\n, we can transition nested elements using nested CSS selectors:\ntemplate\n<Transition name=\"nested\">\n<div v-if=\"show\" class=\"outer\">\n<div class=\"inner\">\nHello\n</div>\n</div>\n</Transition>\ncss\n/* rules that target nested elements */\n.nested-enter-active .inner,\n.nested-leave-active .inner {\ntransition: all 0.3s ease-in-out;\n}\n.nested-enter-from .inner,\n.nested-leave-to .inner {\ntransform: translateX(30px);\nopacity: 0;\n}\n/* ... other necessary CSS omitted */\nWe can even add a transition delay to the nested element on enter, which creates a staggered enter animation sequence:\ncss\n/* delay enter of nested element for staggered effect */\n.nested-enter-active .inner {\ntransition-delay: 0.25s;\n}\nHowever, this creates a small issue. By default, the <Transition>\ncomponent attempts to automatically figure out when the transition has finished by listening to the first transitionend\nor animationend\nevent on the root transition element. With a nested transition, the desired behavior should be waiting until the transitions of all inner elements have finished.\nIn such cases you can specify an explicit transition duration (in milliseconds) using the duration\nprop on the <transition>\ncomponent. The total duration should match the delay plus transition duration of the inner element:\ntemplate\n<Transition :duration=\"550\">...</Transition>\nHello\nIf necessary, you can also specify separate values for enter and leave durations using an object:\ntemplate\n<Transition :duration=\"{ enter: 500, leave: 800 }\">...</Transition>\nPerformance Considerations\nYou may notice that the animations shown above are mostly using properties like transform\nand opacity\n. These properties are efficient to animate because:\nThey do not affect the document layout during the animation, so they do not trigger expensive CSS layout calculation on every animation frame.\nMost modern browsers can leverage GPU hardware acceleration when animating\ntransform\n.\nIn comparison, properties like height\nor margin\nwill trigger CSS layout, so they are much more expensive to animate, and should be used with caution.\nJavaScript Hooks\nYou can hook into the transition process with JavaScript by listening to events on the <Transition>\ncomponent:\nhtml\n<Transition\n@before-enter=\"onBeforeEnter\"\n@enter=\"onEnter\"\n@after-enter=\"onAfterEnter\"\n@enter-cancelled=\"onEnterCancelled\"\n@before-leave=\"onBeforeLeave\"\n@leave=\"onLeave\"\n@after-leave=\"onAfterLeave\"\n@leave-cancelled=\"onLeaveCancelled\"\n>\n<!-- ... -->\n</Transition>\njs\n// called before the element is inserted into the DOM.\n// use this to set the \"enter-from\" state of the element\nfunction onBeforeEnter(el) {}\n// called one frame after the element is inserted.\n// use this to start the entering animation.\nfunction onEnter(el, done) {\n// call the done callback to indicate transition end\n// optional if used in combination with CSS\ndone()\n}\n// called when the enter transition has finished.\nfunction onAfterEnter(el) {}\n// called when the enter transition is cancelled before completion.\nfunction onEnterCancelled(el) {}\n// called before the leave hook.\n// Most of the time, you should just use the leave hook\nfunction onBeforeLeave(el) {}\n// called when the leave transition starts.\n// use this to start the leaving animation.\nfunction onLeave(el, done) {\n// call the done callback to indicate transition end\n// optional if used in combination with CSS\ndone()\n}\n// called when the leave transition has finished and the\n// element has been removed from the DOM.\nfunction onAfterLeave(el) {}\n// only available with v-show transitions\nfunction onLeaveCancelled(el) {}\nThese hooks can be used in combination with CSS transitions / animations or on their own.\nWhen using JavaScript-only transitions, it is usually a good idea to add the :css=\"false\"\nprop. This explicitly tells Vue to skip auto CSS transition detection. Aside from being slightly more performant, this also prevents CSS rules from accidentally interfering with the transition:\ntemplate\n<Transition\n...\n:css=\"false\"\n>\n...\n</Transition>\nWith :css=\"false\"\n, we are also fully responsible for controlling when the transition ends. In this case, the done\ncallbacks are required for the @enter\nand @leave\nhooks. Otherwise, the hooks will be called synchronously and the transition will finish immediately.\nHere's a demo using the GSAP library to perform the animations. You can, of course, use any other animation library you want, for example Anime.js or Motion One:\nReusable Transitions\nTransitions can be reused through Vue's component system. To create a reusable transition, we can create a component that wraps the <Transition>\ncomponent and passes down the slot content:\nvue\n<!-- MyTransition.vue -->\n<script>\n// JavaScript hooks logic...\n</script>\n<template>\n<!-- wrap the built-in Transition component -->\n<Transition\nname=\"my-transition\"\n@enter=\"onEnter\"\n@leave=\"onLeave\">\n<slot></slot> <!-- pass down slot content -->\n</Transition>\n</template>\n<style>\n/*\nNecessary CSS...\nNote: avoid using <style scoped> here since it\ndoes not apply to slot content.\n*/\n</style>\nNow MyTransition\ncan be imported and used just like the built-in version:\ntemplate\n<MyTransition>\n<div v-if=\"show\">Hello</div>\n</MyTransition>\nTransition on Appear\nIf you also want to apply a transition on the initial render of a node, you can add the appear\nprop:\ntemplate\n<Transition appear>\n...\n</Transition>\nTransition Between Elements\nIn addition to toggling an element with v-if\n/ v-show\n, we can also transition between two elements using v-if\n/ v-else\n/ v-else-if\n, as long as we make sure that there is only one element being shown at any given moment:\ntemplate\n<Transition>\n<button v-if=\"docState === 'saved'\">Edit</button>\n<button v-else-if=\"docState === 'edited'\">Save</button>\n<button v-else-if=\"docState === 'editing'\">Cancel</button>\n</Transition>\nClick to cycle through states:\nTransition Modes\nIn the previous example, the entering and leaving elements are animated at the same time, and we had to make them position: absolute\nto avoid the layout issue when both elements are present in the DOM.\nHowever, in some cases this isn't an option, or simply isn't the desired behavior. We may want the leaving element to be animated out first, and for the entering element to only be inserted after the leaving animation has finished. Orchestrating such animations manually would be very complicated - luckily, we can enable this behavior by passing <Transition>\na mode\nprop:\ntemplate\n<Transition mode=\"out-in\">\n...\n</Transition>\nHere's the previous demo with mode=\"out-in\"\n:\nClick to cycle through states:\n<Transition>\nalso supports mode=\"in-out\"\n, although it's much less frequently used.\nTransition Between Components\n<Transition>\ncan also be used around dynamic components:\ntemplate\n<Transition name=\"fade\" mode=\"out-in\">\n<component :is=\"activeComponent\"></component>\n</Transition>\nComponent A\nDynamic Transitions\n<Transition>\nprops like name\ncan also be dynamic! It allows us to dynamically apply different transitions based on state change:\ntemplate\n<Transition :name=\"transitionName\">\n<!-- ... -->\n</Transition>\nThis can be useful when you've defined CSS transitions / animations using Vue's transition class conventions and want to switch between them.\nYou can also apply different behavior in JavaScript transition hooks based on the current state of your component. Finally, the ultimate way of creating dynamic transitions is through reusable transition components that accept props to change the nature of the transition(s) to be used. It may sound cheesy, but the only limit really is your imagination.\nTransitions with the Key Attribute\nSometimes you need to force the re-render of a DOM element in order for a transition to occur.\nTake this counter component for example:\nvue\n<script setup>\nimport { ref } from 'vue';\nconst count = ref(0);\nsetInterval(() => count.value++, 1000);\n</script>\n<template>\n<Transition>\n<span :key=\"count\">{{ count }}</span>\n</Transition>\n</template>\nIf we had excluded the key\nattribute, only the text node would be updated and thus no transition would occur. However, with the key\nattribute in place, Vue knows to create a new span\nelement whenever count\nchanges and thus the Transition\ncomponent has 2 different elements to transition between.\nRelated",
    "metadata": {
      "source": "https://vuejs.org/guide/built-ins/transition",
      "title": "Transition | Vue.js"
    }
  },
  {
    "page_content": "Single-File Components\nIntroduction\nVue Single-File Components (a.k.a. *.vue\nfiles, abbreviated as SFC) is a special file format that allows us to encapsulate the template, logic, and styling of a Vue component in a single file. Here's an example SFC:\nvue\n<script setup>\nimport { ref } from 'vue'\nconst greeting = ref('Hello World!')\n</script>\n<template>\n<p class=\"greeting\">{{ greeting }}</p>\n</template>\n<style>\n.greeting {\ncolor: red;\nfont-weight: bold;\n}\n</style>\nAs we can see, Vue SFC is a natural extension of the classic trio of HTML, CSS and JavaScript. The <template>\n, <script>\n, and <style>\nblocks encapsulate and colocate the view, logic and styling of a component in the same file. The full syntax is defined in the SFC Syntax Specification.\nWhy SFC\nWhile SFCs require a build step, there are numerous benefits in return:\n- Author modularized components using familiar HTML, CSS and JavaScript syntax\n- Colocation of inherently coupled concerns\n- Pre-compiled templates without runtime compilation cost\n- Component-scoped CSS\n- More ergonomic syntax when working with Composition API\n- More compile-time optimizations by cross-analyzing template and script\n- IDE support with auto-completion and type-checking for template expressions\n- Out-of-the-box Hot-Module Replacement (HMR) support\nSFC is a defining feature of Vue as a framework, and is the recommended approach for using Vue in the following scenarios:\n- Single-Page Applications (SPA)\n- Static Site Generation (SSG)\n- Any non-trivial frontend where a build step can be justified for better development experience (DX).\nThat said, we do realize there are scenarios where SFCs can feel like overkill. This is why Vue can still be used via plain JavaScript without a build step. If you are just looking for enhancing largely static HTML with light interactions, you can also check out petite-vue, a 6 kB subset of Vue optimized for progressive enhancement.\nHow It Works\nVue SFC is a framework-specific file format and must be pre-compiled by @vue/compiler-sfc into standard JavaScript and CSS. A compiled SFC is a standard JavaScript (ES) module - which means with proper build setup you can import an SFC like a module:\njs\nimport MyComponent from './MyComponent.vue'\nexport default {\ncomponents: {\nMyComponent\n}\n}\n<style>\ntags inside SFCs are typically injected as native <style>\ntags during development to support hot updates. For production they can be extracted and merged into a single CSS file.\nYou can play with SFCs and explore how they are compiled in the Vue SFC Playground.\nIn actual projects, we typically integrate the SFC compiler with a build tool such as Vite or Vue CLI (which is based on webpack), and Vue provides official scaffolding tools to get you started with SFCs as fast as possible. Check out more details in the SFC Tooling section.\nWhat About Separation of Concerns?\nSome users coming from a traditional web development background may have the concern that SFCs are mixing different concerns in the same place - which HTML/CSS/JS were supposed to separate!\nTo answer this question, it is important for us to agree that separation of concerns is not equal to the separation of file types. The ultimate goal of engineering principles is to improve the maintainability of codebases. Separation of concerns, when applied dogmatically as separation of file types, does not help us reach that goal in the context of increasingly complex frontend applications.\nIn modern UI development, we have found that instead of dividing the codebase into three huge layers that interweave with one another, it makes much more sense to divide them into loosely-coupled components and compose them. Inside a component, its template, logic, and styles are inherently coupled, and colocating them actually makes the component more cohesive and maintainable.\nNote even if you don't like the idea of Single-File Components, you can still leverage its hot-reloading and pre-compilation features by separating your JavaScript and CSS into separate files using Src Imports.",
    "metadata": {
      "source": "https://vuejs.org/guide/scaling-up/sfc",
      "title": "Single-File Components | Vue.js"
    }
  },
  {
    "page_content": "Components Basics\nComponents allow us to split the UI into independent and reusable pieces, and think about each piece in isolation. It's common for an app to be organized into a tree of nested components:\nThis is very similar to how we nest native HTML elements, but Vue implements its own component model that allows us to encapsulate custom content and logic in each component. Vue also plays nicely with native Web Components. If you are curious about the relationship between Vue Components and native Web Components, read more here.\nDefining a Component\nWhen using a build step, we typically define each Vue component in a dedicated file using the .vue\nextension - known as a Single-File Component (SFC for short):\nvue\n<script setup>\nimport { ref } from 'vue'\nconst count = ref(0)\n</script>\n<template>\n<button @click=\"count++\">You clicked me {{ count }} times.</button>\n</template>\nWhen not using a build step, a Vue component can be defined as a plain JavaScript object containing Vue-specific options:\njs\nimport { ref } from 'vue'\nexport default {\nsetup() {\nconst count = ref(0)\nreturn { count }\n},\ntemplate: `\n<button @click=\"count++\">\nYou clicked me {{ count }} times.\n</button>`\n// Can also target an in-DOM template:\n// template: '#my-template-element'\n}\nThe template is inlined as a JavaScript string here, which Vue will compile on the fly. You can also use an ID selector pointing to an element (usually native <template>\nelements) - Vue will use its content as the template source.\nThe example above defines a single component and exports it as the default export of a .js\nfile, but you can use named exports to export multiple components from the same file.\nUsing a Component\nTIP\nWe will be using SFC syntax for the rest of this guide - the concepts around components are the same regardless of whether you are using a build step or not. The Examples section shows component usage in both scenarios.\nTo use a child component, we need to import it in the parent component. Assuming we placed our counter component inside a file called ButtonCounter.vue\n, the component will be exposed as the file's default export:\nvue\n<script setup>\nimport ButtonCounter from './ButtonCounter.vue'\n</script>\n<template>\n<h1>Here is a child component!</h1>\n<ButtonCounter />\n</template>\nWith <script setup>\n, imported components are automatically made available to the template.\nIt's also possible to globally register a component, making it available to all components in a given app without having to import it. The pros and cons of global vs. local registration is discussed in the dedicated Component Registration section.\nComponents can be reused as many times as you want:\ntemplate\n<h1>Here are many child components!</h1>\n<ButtonCounter />\n<ButtonCounter />\n<ButtonCounter />\nNotice that when clicking on the buttons, each one maintains its own, separate count\n. That's because each time you use a component, a new instance of it is created.\nIn SFCs, it's recommended to use PascalCase\ntag names for child components to differentiate from native HTML elements. Although native HTML tag names are case-insensitive, Vue SFC is a compiled format so we are able to use case-sensitive tag names in it. We are also able to use />\nto close a tag.\nIf you are authoring your templates directly in a DOM (e.g. as the content of a native <template>\nelement), the template will be subject to the browser's native HTML parsing behavior. In such cases, you will need to use kebab-case\nand explicit closing tags for components:\ntemplate\n<!-- if this template is written in the DOM -->\n<button-counter></button-counter>\n<button-counter></button-counter>\n<button-counter></button-counter>\nSee in-DOM template parsing caveats for more details.\nPassing Props\nIf we are building a blog, we will likely need a component representing a blog post. We want all the blog posts to share the same visual layout, but with different content. Such a component won't be useful unless you can pass data to it, such as the title and content of the specific post we want to display. That's where props come in.\nProps are custom attributes you can register on a component. To pass a title to our blog post component, we must declare it in the list of props this component accepts, using the defineProps\nmacro:\nvue\n<!-- BlogPost.vue -->\n<script setup>\ndefineProps(['title'])\n</script>\n<template>\n<h4>{{ title }}</h4>\n</template>\ndefineProps\nis a compile-time macro that is only available inside <script setup>\nand does not need to be explicitly imported. Declared props are automatically exposed to the template. defineProps\nalso returns an object that contains all the props passed to the component, so that we can access them in JavaScript if needed:\njs\nconst props = defineProps(['title'])\nconsole.log(props.title)\nSee also: Typing Component Props\nIf you are not using <script setup>\n, props should be declared using the props\noption, and the props object will be passed to setup()\nas the first argument:\njs\nexport default {\nprops: ['title'],\nsetup(props) {\nconsole.log(props.title)\n}\n}\nA component can have as many props as you like and, by default, any value can be passed to any prop.\nOnce a prop is registered, you can pass data to it as a custom attribute, like this:\ntemplate\n<BlogPost title=\"My journey with Vue\" />\n<BlogPost title=\"Blogging with Vue\" />\n<BlogPost title=\"Why Vue is so fun\" />\nIn a typical app, however, you'll likely have an array of posts in your parent component:\njs\nconst posts = ref([\n{ id: 1, title: 'My journey with Vue' },\n{ id: 2, title: 'Blogging with Vue' },\n{ id: 3, title: 'Why Vue is so fun' }\n])\nThen want to render a component for each one, using v-for\n:\ntemplate\n<BlogPost\nv-for=\"post in posts\"\n:key=\"post.id\"\n:title=\"post.title\"\n/>\nNotice how v-bind\nsyntax (:title=\"post.title\"\n) is used to pass dynamic prop values. This is especially useful when you don't know the exact content you're going to render ahead of time.\nThat's all you need to know about props for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Props.\nListening to Events\nAs we develop our <BlogPost>\ncomponent, some features may require communicating back up to the parent. For example, we may decide to include an accessibility feature to enlarge the text of blog posts, while leaving the rest of the page at its default size.\nIn the parent, we can support this feature by adding a postFontSize\nref:\njs\nconst posts = ref([\n/* ... */\n])\nconst postFontSize = ref(1)\nWhich can be used in the template to control the font size of all blog posts:\ntemplate\n<div :style=\"{ fontSize: postFontSize + 'em' }\">\n<BlogPost\nv-for=\"post in posts\"\n:key=\"post.id\"\n:title=\"post.title\"\n/>\n</div>\nNow let's add a button to the <BlogPost>\ncomponent's template:\nvue\n<!-- BlogPost.vue, omitting <script> -->\n<template>\n<div class=\"blog-post\">\n<h4>{{ title }}</h4>\n<button>Enlarge text</button>\n</div>\n</template>\nThe button doesn't do anything yet - we want clicking the button to communicate to the parent that it should enlarge the text of all posts. To solve this problem, components provide a custom events system. The parent can choose to listen to any event on the child component instance with v-on\nor @\n, just as we would with a native DOM event:\ntemplate\n<BlogPost\n...\n@enlarge-text=\"postFontSize += 0.1\"\n/>\nThen the child component can emit an event on itself by calling the built-in $emit\nmethod, passing the name of the event:\nvue\n<!-- BlogPost.vue, omitting <script> -->\n<template>\n<div class=\"blog-post\">\n<h4>{{ title }}</h4>\n<button @click=\"$emit('enlarge-text')\">Enlarge text</button>\n</div>\n</template>\nThanks to the @enlarge-text=\"postFontSize += 0.1\"\nlistener, the parent will receive the event and update the value of postFontSize\n.\nWe can optionally declare emitted events using the defineEmits\nmacro:\nvue\n<!-- BlogPost.vue -->\n<script setup>\ndefineProps(['title'])\ndefineEmits(['enlarge-text'])\n</script>\nThis documents all the events that a component emits and optionally validates them. It also allows Vue to avoid implicitly applying them as native listeners to the child component's root element.\nSimilar to defineProps\n, defineEmits\nis only usable in <script setup>\nand doesn't need to be imported. It returns an emit\nfunction that is equivalent to the $emit\nmethod. It can be used to emit events in the <script setup>\nsection of a component, where $emit\nisn't directly accessible:\nvue\n<script setup>\nconst emit = defineEmits(['enlarge-text'])\nemit('enlarge-text')\n</script>\nSee also: Typing Component Emits\nIf you are not using <script setup>\n, you can declare emitted events using the emits\noption. You can access the emit\nfunction as a property of the setup context (passed to setup()\nas the second argument):\njs\nexport default {\nemits: ['enlarge-text'],\nsetup(props, ctx) {\nctx.emit('enlarge-text')\n}\n}\nThat's all you need to know about custom component events for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Custom Events.\nContent Distribution with Slots\nJust like with HTML elements, it's often useful to be able to pass content to a component, like this:\ntemplate\n<AlertBox>\nSomething bad happened.\n</AlertBox>\nWhich might render something like:\nThis is an Error for Demo Purposes\nSomething bad happened.\nThis can be achieved using Vue's custom <slot>\nelement:\nvue\n<!-- AlertBox.vue -->\n<template>\n<div class=\"alert-box\">\n<strong>This is an Error for Demo Purposes</strong>\n<slot />\n</div>\n</template>\n<style scoped>\n.alert-box {\n/* ... */\n}\n</style>\nAs you'll see above, we use the <slot>\nas a placeholder where we want the content to go – and that's it. We're done!\nThat's all you need to know about slots for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Slots.\nDynamic Components\nSometimes, it's useful to dynamically switch between components, like in a tabbed interface:\nThe above is made possible by Vue's <component>\nelement with the special is\nattribute:\ntemplate\n<!-- Component changes when currentTab changes -->\n<component :is=\"tabs[currentTab]\"></component>\nIn the example above, the value passed to :is\ncan contain either:\n- the name string of a registered component, OR\n- the actual imported component object\nYou can also use the is\nattribute to create regular HTML elements.\nWhen switching between multiple components with <component :is=\"...\">\n, a component will be unmounted when it is switched away from. We can force the inactive components to stay \"alive\" with the built-in <KeepAlive>\ncomponent.\nin-DOM Template Parsing Caveats\nIf you are writing your Vue templates directly in the DOM, Vue will have to retrieve the template string from the DOM. This leads to some caveats due to browsers' native HTML parsing behavior.\nTIP\nIt should be noted that the limitations discussed below only apply if you are writing your templates directly in the DOM. They do NOT apply if you are using string templates from the following sources:\n- Single-File Components\n- Inlined template strings (e.g.\ntemplate: '...'\n) <script type=\"text/x-template\">\nCase Insensitivity\nHTML tags and attribute names are case-insensitive, so browsers will interpret any uppercase characters as lowercase. That means when you’re using in-DOM templates, PascalCase component names and camelCased prop names or v-on\nevent names all need to use their kebab-cased (hyphen-delimited) equivalents:\njs\n// camelCase in JavaScript\nconst BlogPost = {\nprops: ['postTitle'],\nemits: ['updatePost'],\ntemplate: `\n<h3>{{ postTitle }}</h3>\n`\n}\ntemplate\n<!-- kebab-case in HTML -->\n<blog-post post-title=\"hello!\" @update-post=\"onUpdatePost\"></blog-post>\nSelf Closing Tags\nWe have been using self-closing tags for components in previous code samples:\ntemplate\n<MyComponent />\nThis is because Vue's template parser respects />\nas an indication to end any tag, regardless of its type.\nIn in-DOM templates, however, we must always include explicit closing tags:\ntemplate\n<my-component></my-component>\nThis is because the HTML spec only allows a few specific elements to omit closing tags, the most common being <input>\nand <img>\n. For all other elements, if you omit the closing tag, the native HTML parser will think you never terminated the opening tag. For example, the following snippet:\ntemplate\n<my-component /> <!-- we intend to close the tag here... -->\n<span>hello</span>\nwill be parsed as:\ntemplate\n<my-component>\n<span>hello</span>\n</my-component> <!-- but the browser will close it here. -->\nElement Placement Restrictions\nSome HTML elements, such as <ul>\n, <ol>\n, <table>\nand <select>\nhave restrictions on what elements can appear inside them, and some elements such as <li>\n, <tr>\n, and <option>\ncan only appear inside certain other elements.\nThis will lead to issues when using components with elements that have such restrictions. For example:\ntemplate\n<table>\n<blog-post-row></blog-post-row>\n</table>\nThe custom component <blog-post-row>\nwill be hoisted out as invalid content, causing errors in the eventual rendered output. We can use the special is\nattribute as a workaround:\ntemplate\n<table>\n<tr is=\"vue:blog-post-row\"></tr>\n</table>\nTIP\nWhen used on native HTML elements, the value of is\nmust be prefixed with vue:\nin order to be interpreted as a Vue component. This is required to avoid confusion with native customized built-in elements.\nThat's all you need to know about in-DOM template parsing caveats for now - and actually, the end of Vue's Essentials. Congratulations! There's still more to learn, but first, we recommend taking a break to play with Vue yourself - build something fun, or check out some of the Examples if you haven't already.\nOnce you feel comfortable with the knowledge you've just digested, move on with the guide to learn more about components in depth.",
    "metadata": {
      "source": "https://vuejs.org/guide/essentials/component-basics",
      "title": "Components Basics | Vue.js"
    }
  },
  {
    "page_content": "Ways of Using Vue\nWe believe there is no \"one size fits all\" story for the web. This is why Vue is designed to be flexible and incrementally adoptable. Depending on your use case, Vue can be used in different ways to strike the optimal balance between stack complexity, developer experience and end performance.\nStandalone Script\nVue can be used as a standalone script file - no build step required! If you have a backend framework already rendering most of the HTML, or your frontend logic isn't complex enough to justify a build step, this is the easiest way to integrate Vue into your stack. You can think of Vue as a more declarative replacement of jQuery in such cases.\nVue also provides an alternative distribution called petite-vue that is specifically optimized for progressively enhancing existing HTML. It has a smaller feature set, but is extremely lightweight and uses an implementation that is more efficient in no-build-step scenarios.\nEmbedded Web Components\nYou can use Vue to build standard Web Components that can be embedded in any HTML page, regardless of how they are rendered. This option allows you to leverage Vue in a completely consumer-agnostic fashion: the resulting web components can be embedded in legacy applications, static HTML, or even applications built with other frameworks.\nSingle-Page Application (SPA)\nSome applications require rich interactivity, deep session depth, and non-trivial stateful logic on the frontend. The best way to build such applications is to use an architecture where Vue not only controls the entire page, but also handles data updates and navigation without having to reload the page. This type of application is typically referred to as a Single-Page Application (SPA).\nVue provides core libraries and comprehensive tooling support with amazing developer experience for building modern SPAs, including:\n- Client-side router\n- Blazing fast build tool chain\n- IDE support\n- Browser devtools\n- TypeScript integrations\n- Testing utilities\nSPAs typically require the backend to expose API endpoints - but you can also pair Vue with solutions like Inertia.js to get the SPA benefits while retaining a server-centric development model.\nFullstack / SSR\nPure client-side SPAs are problematic when the app is sensitive to SEO and time-to-content. This is because the browser will receive a largely empty HTML page, and has to wait until the JavaScript is loaded before rendering anything.\nVue provides first-class APIs to \"render\" a Vue app into HTML strings on the server. This allows the server to send back already-rendered HTML, allowing end users to see the content immediately while the JavaScript is being downloaded. Vue will then \"hydrate\" the application on the client side to make it interactive. This is called Server-Side Rendering (SSR) and it greatly improves Core Web Vital metrics such as Largest Contentful Paint (LCP).\nThere are higher-level Vue-based frameworks built on top of this paradigm, such as Nuxt, which allow you to develop a fullstack application using Vue and JavaScript.\nJAMStack / SSG\nServer-side rendering can be done ahead of time if the required data is static. This means we can pre-render an entire application into HTML and serve them as static files. This improves site performance and makes deployment a lot simpler since we no longer need to dynamically render pages on each request. Vue can still hydrate such applications to provide rich interactivity on the client. This technique is commonly referred to as Static-Site Generation (SSG), also known as JAMStack.\nThere are two flavors of SSG: single-page and multi-page. Both flavors pre-render the site into static HTML, the difference is that:\nAfter the initial page load, a single-page SSG \"hydrates\" the page into an SPA. This requires more upfront JS payload and hydration cost, but subsequent navigations will be faster, since it only needs to partially update the page content instead of reloading the entire page.\nA multi-page SSG loads a new page on every navigation. The upside is that it can ship minimal JS - or no JS at all if the page requires no interaction! Some multi-page SSG frameworks such as Astro also support \"partial hydration\" - which allows you to use Vue components to create interactive \"islands\" inside static HTML.\nSingle-page SSGs are better suited if you expect non-trivial interactivity, deep session lengths, or persisted elements / state across navigations. Otherwise, multi-page SSG would be the better choice.\nThe Vue team also maintains a static-site generator called VitePress, which powers this website you are reading right now! VitePress supports both flavors of SSG. Nuxt also supports SSG. You can even mix SSR and SSG for different routes in the same Nuxt app.\nBeyond the Web\nAlthough Vue is primarily designed for building web applications, it is by no means limited to just the browser. You can:\n- Build desktop apps with Electron\n- Build mobile apps with Ionic Vue\n- Build desktop and mobile apps from the same codebase with Quasar or Tauri\n- Build 3D WebGL experiences with TresJS\n- Use Vue's Custom Renderer API to build custom renderers, like those for the terminal!",
    "metadata": {
      "source": "https://vuejs.org/guide/extras/ways-of-using-vue",
      "title": "Ways of Using Vue | Vue.js"
    }
  },
  {
    "page_content": "Production Deployment\nDevelopment vs. Production\nDuring development, Vue provides a number of features to improve the development experience:\n- Warning for common errors and pitfalls\n- Props / events validation\n- Reactivity debugging hooks\n- Devtools integration\nHowever, these features become useless in production. Some of the warning checks can also incur a small amount of performance overhead. When deploying to production, we should drop all the unused, development-only code branches for smaller payload size and better performance.\nWithout Build Tools\nIf you are using Vue without a build tool by loading it from a CDN or self-hosted script, make sure to use the production build (dist files that end in .prod.js\n) when deploying to production. Production builds are pre-minified with all development-only code branches removed.\n- If using global build (accessing via the\nVue\nglobal): usevue.global.prod.js\n. - If using ESM build (accessing via native ESM imports): use\nvue.esm-browser.prod.js\n.\nConsult the dist file guide for more details.\nWith Build Tools\nProjects scaffolded via create-vue\n(based on Vite) or Vue CLI (based on webpack) are pre-configured for production builds.\nIf using a custom setup, make sure that:\nvue\nresolves tovue.runtime.esm-bundler.js\n.- The compile time feature flags are properly configured.\nprocess.env\nis replaced with.NODE_ENV \"production\"\nduring build.\nAdditional references:\nTracking Runtime Errors\nThe app-level error handler can be used to report errors to tracking services:\njs\nimport { createApp } from 'vue'\nconst app = createApp(...)\napp.config.errorHandler = (err, instance, info) => {\n// report error to tracking services\n}\nServices such as Sentry and Bugsnag also provide official integrations for Vue.",
    "metadata": {
      "source": "https://vuejs.org/guide/best-practices/production-deployment",
      "title": "Production Deployment | Vue.js"
    }
  },
  {
    "page_content": "Security\nReporting Vulnerabilities\nWhen a vulnerability is reported, it immediately becomes our top concern, with a full-time contributor dropping everything to work on it. To report a vulnerability, please email security@vuejs.org.\nWhile the discovery of new vulnerabilities is rare, we also recommend always using the latest versions of Vue and its official companion libraries to ensure your application remains as secure as possible.\nRule No.1: Never Use Non-trusted Templates\nThe most fundamental security rule when using Vue is never use non-trusted content as your component template. Doing so is equivalent to allowing arbitrary JavaScript execution in your application - and worse, could lead to server breaches if the code is executed during server-side rendering. An example of such usage:\njs\nVue.createApp({\ntemplate: `<div>` + userProvidedString + `</div>` // NEVER DO THIS\n}).mount('#app')\nVue templates are compiled into JavaScript, and expressions inside templates will be executed as part of the rendering process. Although the expressions are evaluated against a specific rendering context, due to the complexity of potential global execution environments, it is impractical for a framework like Vue to completely shield you from potential malicious code execution without incurring unrealistic performance overhead. The most straightforward way to avoid this category of problems altogether is to make sure the contents of your Vue templates are always trusted and entirely controlled by you.\nWhat Vue Does to Protect You\nHTML content\nWhether using templates or render functions, content is automatically escaped. That means in this template:\ntemplate\n<h1>{{ userProvidedString }}</h1>\nif userProvidedString\ncontained:\njs\n'<script>alert(\"hi\")</script>'\nthen it would be escaped to the following HTML:\ntemplate\n<script>alert(\"hi\")</script>\nthus preventing the script injection. This escaping is done using native browser APIs, like textContent\n, so a vulnerability can only exist if the browser itself is vulnerable.\nAttribute bindings\nSimilarly, dynamic attribute bindings are also automatically escaped. That means in this template:\ntemplate\n<h1 :title=\"userProvidedString\">\nhello\n</h1>\nif userProvidedString\ncontained:\njs\n'\" onclick=\"alert(\\'hi\\')'\nthen it would be escaped to the following HTML:\ntemplate\n\" onclick=\"alert('hi')\nthus preventing the close of the title\nattribute to inject new, arbitrary HTML. This escaping is done using native browser APIs, like setAttribute\n, so a vulnerability can only exist if the browser itself is vulnerable.\nPotential Dangers\nIn any web application, allowing unsanitized, user-provided content to be executed as HTML, CSS, or JavaScript is potentially dangerous, so it should be avoided wherever possible. There are times when some risk may be acceptable, though.\nFor example, services like CodePen and JSFiddle allow user-provided content to be executed, but it's in a context where this is expected and sandboxed to some extent inside iframes. In the cases when an important feature inherently requires some level of vulnerability, it's up to your team to weigh the importance of the feature against the worst-case scenarios the vulnerability enables.\nHTML Injection\nAs you learned earlier, Vue automatically escapes HTML content, preventing you from accidentally injecting executable HTML into your application. However, in cases where you know the HTML is safe, you can explicitly render HTML content:\nUsing a template:\ntemplate<div v-html=\"userProvidedHtml\"></div>\nUsing a render function:\njsh('div', { innerHTML: this.userProvidedHtml })\nUsing a render function with JSX:\njsx<div innerHTML={this.userProvidedHtml}></div>\nWARNING\nUser-provided HTML can never be considered 100% safe unless it's in a sandboxed iframe or in a part of the app where only the user who wrote that HTML can ever be exposed to it. Additionally, allowing users to write their own Vue templates brings similar dangers.\nURL Injection\nIn a URL like this:\ntemplate\n<a :href=\"userProvidedUrl\">\nclick me\n</a>\nThere's a potential security issue if the URL has not been \"sanitized\" to prevent JavaScript execution using javascript:\n. There are libraries such as sanitize-url to help with this, but note: if you're ever doing URL sanitization on the frontend, you already have a security issue. User-provided URLs should always be sanitized by your backend before even being saved to a database. Then the problem is avoided for every client connecting to your API, including native mobile apps. Also note that even with sanitized URLs, Vue cannot help you guarantee that they lead to safe destinations.\nStyle Injection\nLooking at this example:\ntemplate\n<a\n:href=\"sanitizedUrl\"\n:style=\"userProvidedStyles\"\n>\nclick me\n</a>\nLet's assume that sanitizedUrl\nhas been sanitized, so that it's definitely a real URL and not JavaScript. With the userProvidedStyles\n, malicious users could still provide CSS to \"click jack\", e.g. styling the link into a transparent box over the \"Log in\" button. Then if https://user-controlled-website.com/\nis built to resemble the login page of your application, they might have just captured a user's real login information.\nYou may be able to imagine how allowing user-provided content for a <style>\nelement would create an even greater vulnerability, giving that user full control over how to style the entire page. That's why Vue prevents rendering of style tags inside templates, such as:\ntemplate\n<style>{{ userProvidedStyles }}</style>\nTo keep your users fully safe from clickjacking, we recommend only allowing full control over CSS inside a sandboxed iframe. Alternatively, when providing user control through a style binding, we recommend using its object syntax and only allowing users to provide values for specific properties it's safe for them to control, like this:\ntemplate\n<a\n:href=\"sanitizedUrl\"\n:style=\"{\ncolor: userProvidedColor,\nbackground: userProvidedBackground\n}\"\n>\nclick me\n</a>\nJavaScript Injection\nWe strongly discourage ever rendering a <script>\nelement with Vue, since templates and render functions should never have side effects. However, this isn't the only way to include strings that would be evaluated as JavaScript at runtime.\nEvery HTML element has attributes with values accepting strings of JavaScript, such as onclick\n, onfocus\n, and onmouseenter\n. Binding user-provided JavaScript to any of these event attributes is a potential security risk, so it should be avoided.\nWARNING\nUser-provided JavaScript can never be considered 100% safe unless it's in a sandboxed iframe or in a part of the app where only the user who wrote that JavaScript can ever be exposed to it.\nSometimes we receive vulnerability reports on how it's possible to do cross-site scripting (XSS) in Vue templates. In general, we do not consider such cases to be actual vulnerabilities because there's no practical way to protect developers from the two scenarios that would allow XSS:\nThe developer is explicitly asking Vue to render user-provided, unsanitized content as Vue templates. This is inherently unsafe, and there's no way for Vue to know the origin.\nThe developer is mounting Vue to an entire HTML page which happens to contain server-rendered and user-provided content. This is fundamentally the same problem as #1, but sometimes devs may do it without realizing it. This can lead to possible vulnerabilities where the attacker provides HTML which is safe as plain HTML but unsafe as a Vue template. The best practice is to never mount Vue on nodes that may contain server-rendered and user-provided content.\nBest Practices\nThe general rule is that if you allow unsanitized, user-provided content to be executed (as either HTML, JavaScript, or even CSS), you might open yourself up to attacks. This advice actually holds true whether using Vue, another framework, or even no framework.\nBeyond the recommendations made above for Potential Dangers, we also recommend familiarizing yourself with these resources:\nThen use what you learn to also review the source code of your dependencies for potentially dangerous patterns, if any of them include 3rd-party components or otherwise influence what's rendered to the DOM.\nBackend Coordination\nHTTP security vulnerabilities, such as cross-site request forgery (CSRF/XSRF) and cross-site script inclusion (XSSI), are primarily addressed on the backend, so they aren't a concern of Vue's. However, it's still a good idea to communicate with your backend team to learn how to best interact with their API, e.g., by submitting CSRF tokens with form submissions.\nServer-Side Rendering (SSR)\nThere are some additional security concerns when using SSR, so make sure to follow the best practices outlined throughout our SSR documentation to avoid vulnerabilities.",
    "metadata": {
      "source": "https://vuejs.org/guide/best-practices/security",
      "title": "Security | Vue.js"
    }
  },
  {
    "page_content": "Performance\nOverview\nVue is designed to be performant for most common use cases without much need for manual optimizations. However, there are always challenging scenarios where extra fine-tuning is needed. In this section, we will discuss what you should pay attention to when it comes to performance in a Vue application.\nFirst, let's discuss the two major aspects of web performance:\nPage Load Performance: how fast the application shows content and becomes interactive on the initial visit. This is usually measured using web vital metrics like Largest Contentful Paint (LCP) and First Input Delay (FID).\nUpdate Performance: how fast the application updates in response to user input. For example, how fast a list updates when the user types in a search box, or how fast the page switches when the user clicks a navigation link in a Single-Page Application (SPA).\nWhile it would be ideal to maximize both, different frontend architectures tend to affect how easy it is to attain desired performance in these aspects. In addition, the type of application you are building greatly influences what you should prioritize in terms of performance. Therefore, the first step of ensuring optimal performance is picking the right architecture for the type of application you are building:\nConsult Ways of Using Vue to see how you can leverage Vue in different ways.\nJason Miller discusses the types of web applications and their respective ideal implementation / delivery in Application Holotypes.\nProfiling Options\nTo improve performance, we need to first know how to measure it. There are a number of great tools that can help in this regard:\nFor profiling load performance of production deployments:\nFor profiling performance during local development:\n- Chrome DevTools Performance Panel\napp.config.performance\nenables Vue-specific performance markers in Chrome DevTools' performance timeline.\n- Vue DevTools Extension also provides a performance profiling feature.\nPage Load Optimizations\nThere are many framework-agnostic aspects for optimizing page load performance - check out this web.dev guide for a comprehensive round up. Here, we will primarily focus on techniques that are specific to Vue.\nChoosing the Right Architecture\nIf your use case is sensitive to page load performance, avoid shipping it as a pure client-side SPA. You want your server to be directly sending HTML containing the content the users want to see. Pure client-side rendering suffers from slow time-to-content. This can be mitigated with Server-Side Rendering (SSR) or Static Site Generation (SSG). Check out the SSR Guide to learn about performing SSR with Vue. If your app doesn't have rich interactivity requirements, you can also use a traditional backend server to render the HTML and enhance it with Vue on the client.\nIf your main application has to be an SPA, but has marketing pages (landing, about, blog), ship them separately! Your marketing pages should ideally be deployed as static HTML with minimal JS, by using SSG.\nBundle Size and Tree-shaking\nOne of the most effective ways to improve page load performance is shipping smaller JavaScript bundles. Here are a few ways to reduce bundle size when using Vue:\nUse a build step if possible.\nMany of Vue's APIs are \"tree-shakable\" if bundled via a modern build tool. For example, if you don't use the built-in\n<Transition>\ncomponent, it won't be included in the final production bundle. Tree-shaking can also remove other unused modules in your source code.When using a build step, templates are pre-compiled so we don't need to ship the Vue compiler to the browser. This saves 14kb min+gzipped JavaScript and avoids the runtime compilation cost.\nBe cautious of size when introducing new dependencies! In real-world applications, bloated bundles are most often a result of introducing heavy dependencies without realizing it.\nIf using a build step, prefer dependencies that offer ES module formats and are tree-shaking friendly. For example, prefer\nlodash-es\noverlodash\n.Check a dependency's size and evaluate whether it is worth the functionality it provides. Note if the dependency is tree-shaking friendly, the actual size increase will depend on the APIs you actually import from it. Tools like bundlejs.com can be used for quick checks, but measuring with your actual build setup will always be the most accurate.\nIf you are using Vue primarily for progressive enhancement and prefer to avoid a build step, consider using petite-vue (only 6kb) instead.\nCode Splitting\nCode splitting is where a build tool splits the application bundle into multiple smaller chunks, which can then be loaded on demand or in parallel. With proper code splitting, features required at page load can be downloaded immediately, with additional chunks being lazy loaded only when needed, thus improving performance.\nBundlers like Rollup (which Vite is based upon) or webpack can automatically create split chunks by detecting the ESM dynamic import syntax:\njs\n// lazy.js and its dependencies will be split into a separate chunk\n// and only loaded when `loadLazy()` is called.\nfunction loadLazy() {\nreturn import('./lazy.js')\n}\nLazy loading is best used on features that are not immediately needed after initial page load. In Vue applications, this can be used in combination with Vue's Async Component feature to create split chunks for component trees:\njs\nimport { defineAsyncComponent } from 'vue'\n// a separate chunk is created for Foo.vue and its dependencies.\n// it is only fetched on demand when the async component is\n// rendered on the page.\nconst Foo = defineAsyncComponent(() => import('./Foo.vue'))\nFor applications using Vue Router, it is strongly recommended to use lazy loading for route components. Vue Router has explicit support for lazy loading, separate from defineAsyncComponent\n. See Lazy Loading Routes for more details.\nUpdate Optimizations\nProps Stability\nIn Vue, a child component only updates when at least one of its received props has changed. Consider the following example:\ntemplate\n<ListItem\nv-for=\"item in list\"\n:id=\"item.id\"\n:active-id=\"activeId\" />\nInside the <ListItem>\ncomponent, it uses its id\nand activeId\nprops to determine whether it is the currently active item. While this works, the problem is that whenever activeId\nchanges, every <ListItem>\nin the list has to update!\nIdeally, only the items whose active status changed should update. We can achieve that by moving the active status computation into the parent, and make <ListItem>\ndirectly accept an active\nprop instead:\ntemplate\n<ListItem\nv-for=\"item in list\"\n:id=\"item.id\"\n:active=\"item.id === activeId\" />\nNow, for most components the active\nprop will remain the same when activeId\nchanges, so they no longer need to update. In general, the idea is keeping the props passed to child components as stable as possible.\nv-once\nv-once\nis a built-in directive that can be used to render content that relies on runtime data but never needs to update. The entire sub-tree it is used on will be skipped for all future updates. Consult its API reference for more details.\nv-memo\nv-memo\nis a built-in directive that can be used to conditionally skip the update of large sub-trees or v-for\nlists. Consult its API reference for more details.\nComputed Stability\nStarting in 3.4, a computed property will only trigger effects when its computed value has changed from the previous one. For example, the following isEven\ncomputed only triggers effects if the returned value has changed from true\nto false\n, or vice-versa:\njs\nconst count = ref(0)\nconst isEven = computed(() => count.value % 2 === 0)\nwatchEffect(() => console.log(isEven.value)) // true\n// will not trigger new logs because the computed value stays `true`\ncount.value = 2\ncount.value = 4\nThis reduces unnecessary effect triggers, but unfortunately doesn't work if the computed creates a new object on each compute:\njs\nconst computedObj = computed(() => {\nreturn {\nisEven: count.value % 2 === 0\n}\n})\nBecause a new object is created each time, the new value is technically always different from the old value. Even if the isEven\nproperty remains the same, Vue won't be able to know unless it performs a deep comparison of the old value and the new value. Such comparison could be expensive and likely not worth it.\nInstead, we can optimize this by manually comparing the new value with the old value, and conditionally returning the old value if we know nothing has changed:\njs\nconst computedObj = computed((oldValue) => {\nconst newValue = {\nisEven: count.value % 2 === 0\n}\nif (oldValue && oldValue.isEven === newValue.isEven) {\nreturn oldValue\n}\nreturn newValue\n})\nNote that you should always perform the full computation before comparing and returning the old value, so that the same dependencies can be collected on every run.\nGeneral Optimizations\nThe following tips affect both page load and update performance.\nVirtualize Large Lists\nOne of the most common performance issues in all frontend applications is rendering large lists. No matter how performant a framework is, rendering a list with thousands of items will be slow due to the sheer number of DOM nodes that the browser needs to handle.\nHowever, we don't necessarily have to render all these nodes upfront. In most cases, the user's screen size can display only a small subset of our large list. We can greatly improve the performance with list virtualization, the technique of only rendering the items that are currently in or close to the viewport in a large list.\nImplementing list virtualization isn't easy, luckily there are existing community libraries that you can directly use:\nReduce Reactivity Overhead for Large Immutable Structures\nVue's reactivity system is deep by default. While this makes state management intuitive, it does create a certain level of overhead when the data size is large, because every property access triggers proxy traps that perform dependency tracking. This typically becomes noticeable when dealing with large arrays of deeply nested objects, where a single render needs to access 100,000+ properties, so it should only affect very specific use cases.\nVue does provide an escape hatch to opt-out of deep reactivity by using shallowRef()\nand shallowReactive()\n. Shallow APIs create state that is reactive only at the root level, and exposes all nested objects untouched. This keeps nested property access fast, with the trade-off being that we must now treat all nested objects as immutable, and updates can only be triggered by replacing the root state:\njs\nconst shallowArray = shallowRef([\n/* big list of deep objects */\n])\n// this won't trigger updates...\nshallowArray.value.push(newObject)\n// this does:\nshallowArray.value = [...shallowArray.value, newObject]\n// this won't trigger updates...\nshallowArray.value[0].foo = 1\n// this does:\nshallowArray.value = [\n{\n...shallowArray.value[0],\nfoo: 1\n},\n...shallowArray.value.slice(1)\n]\nAvoid Unnecessary Component Abstractions\nSometimes we may create renderless components or higher-order components (i.e. components that render other components with extra props) for better abstraction or code organization. While there is nothing wrong with this, do keep in mind that component instances are much more expensive than plain DOM nodes, and creating too many of them due to abstraction patterns will incur performance costs.\nNote that reducing only a few instances won't have noticeable effect, so don't sweat it if the component is rendered only a few times in the app. The best scenario to consider this optimization is again in large lists. Imagine a list of 100 items where each item component contains many child components. Removing one unnecessary component abstraction here could result in a reduction of hundreds of component instances.",
    "metadata": {
      "source": "https://vuejs.org/guide/best-practices/performance",
      "title": "Performance | Vue.js"
    }
  },
  {
    "page_content": "Event Handling\nListening to Events\nWe can use the v-on\ndirective, which we typically shorten to the @\nsymbol, to listen to DOM events and run some JavaScript when they're triggered. The usage would be v-on:click=\"handler\"\nor with the shortcut, @click=\"handler\"\n.\nThe handler value can be one of the following:\nInline handlers: Inline JavaScript to be executed when the event is triggered (similar to the native\nonclick\nattribute).Method handlers: A property name or path that points to a method defined on the component.\nInline Handlers\nInline handlers are typically used in simple cases, for example:\njs\nconst count = ref(0)\ntemplate\n<button @click=\"count++\">Add 1</button>\n<p>Count is: {{ count }}</p>\nMethod Handlers\nThe logic for many event handlers will be more complex though, and likely isn't feasible with inline handlers. That's why v-on\ncan also accept the name or path of a component method you'd like to call.\nFor example:\njs\nconst name = ref('Vue.js')\nfunction greet(event) {\nalert(`Hello ${name.value}!`)\n// `event` is the native DOM event\nif (event) {\nalert(event.target.tagName)\n}\n}\ntemplate\n<!-- `greet` is the name of the method defined above -->\n<button @click=\"greet\">Greet</button>\nA method handler automatically receives the native DOM Event object that triggers it - in the example above, we are able to access the element dispatching the event via event.target\n.\nSee also: Typing Event Handlers\nMethod vs. Inline Detection\nThe template compiler detects method handlers by checking whether the v-on\nvalue string is a valid JavaScript identifier or property access path. For example, foo\n, foo.bar\nand foo['bar']\nare treated as method handlers, while foo()\nand count++\nare treated as inline handlers.\nCalling Methods in Inline Handlers\nInstead of binding directly to a method name, we can also call methods in an inline handler. This allows us to pass the method custom arguments instead of the native event:\njs\nfunction say(message) {\nalert(message)\n}\ntemplate\n<button @click=\"say('hello')\">Say hello</button>\n<button @click=\"say('bye')\">Say bye</button>\nAccessing Event Argument in Inline Handlers\nSometimes we also need to access the original DOM event in an inline handler. You can pass it into a method using the special $event\nvariable, or use an inline arrow function:\ntemplate\n<!-- using $event special variable -->\n<button @click=\"warn('Form cannot be submitted yet.', $event)\">\nSubmit\n</button>\n<!-- using inline arrow function -->\n<button @click=\"(event) => warn('Form cannot be submitted yet.', event)\">\nSubmit\n</button>\njs\nfunction warn(message, event) {\n// now we have access to the native event\nif (event) {\nevent.preventDefault()\n}\nalert(message)\n}\nEvent Modifiers\nIt is a very common need to call event.preventDefault()\nor event.stopPropagation()\ninside event handlers. Although we can do this easily inside methods, it would be better if the methods can be purely about data logic rather than having to deal with DOM event details.\nTo address this problem, Vue provides event modifiers for v-on\n. Recall that modifiers are directive postfixes denoted by a dot.\n.stop\n.prevent\n.self\n.capture\n.once\n.passive\ntemplate\n<!-- the click event's propagation will be stopped -->\n<a @click.stop=\"doThis\"></a>\n<!-- the submit event will no longer reload the page -->\n<form @submit.prevent=\"onSubmit\"></form>\n<!-- modifiers can be chained -->\n<a @click.stop.prevent=\"doThat\"></a>\n<!-- just the modifier -->\n<form @submit.prevent></form>\n<!-- only trigger handler if event.target is the element itself -->\n<!-- i.e. not from a child element -->\n<div @click.self=\"doThat\">...</div>\nTIP\nOrder matters when using modifiers because the relevant code is generated in the same order. Therefore using @click.prevent.self\nwill prevent click's default action on the element itself and its children, while @click.self.prevent\nwill only prevent click's default action on the element itself.\nThe .capture\n, .once\n, and .passive\nmodifiers mirror the options of the native addEventListener\nmethod:\ntemplate\n<!-- use capture mode when adding the event listener -->\n<!-- i.e. an event targeting an inner element is handled -->\n<!-- here before being handled by that element -->\n<div @click.capture=\"doThis\">...</div>\n<!-- the click event will be triggered at most once -->\n<a @click.once=\"doThis\"></a>\n<!-- the scroll event's default behavior (scrolling) will happen -->\n<!-- immediately, instead of waiting for `onScroll` to complete -->\n<!-- in case it contains `event.preventDefault()` -->\n<div @scroll.passive=\"onScroll\">...</div>\nThe .passive\nmodifier is typically used with touch event listeners for improving performance on mobile devices.\nTIP\nDo not use .passive\nand .prevent\ntogether, because .passive\nalready indicates to the browser that you do not intend to prevent the event's default behavior, and you will likely see a warning from the browser if you do so.\nKey Modifiers\nWhen listening for keyboard events, we often need to check for specific keys. Vue allows adding key modifiers for v-on\nor @\nwhen listening for key events:\ntemplate\n<!-- only call `submit` when the `key` is `Enter` -->\n<input @keyup.enter=\"submit\" />\nYou can directly use any valid key names exposed via KeyboardEvent.key\nas modifiers by converting them to kebab-case.\ntemplate\n<input @keyup.page-down=\"onPageDown\" />\nIn the above example, the handler will only be called if $event.key\nis equal to 'PageDown'\n.\nKey Aliases\nVue provides aliases for the most commonly used keys:\n.enter\n.tab\n.delete\n(captures both \"Delete\" and \"Backspace\" keys).esc\n.space\n.up\n.down\n.left\n.right\nSystem Modifier Keys\nYou can use the following modifiers to trigger mouse or keyboard event listeners only when the corresponding modifier key is pressed:\n.ctrl\n.alt\n.shift\n.meta\nNote\nOn Macintosh keyboards, meta is the command key (⌘). On Windows keyboards, meta is the Windows key (⊞). On Sun Microsystems keyboards, meta is marked as a solid diamond (◆). On certain keyboards, specifically MIT and Lisp machine keyboards and successors, such as the Knight keyboard, space-cadet keyboard, meta is labeled “META”. On Symbolics keyboards, meta is labeled “META” or “Meta”.\nFor example:\ntemplate\n<!-- Alt + Enter -->\n<input @keyup.alt.enter=\"clear\" />\n<!-- Ctrl + Click -->\n<div @click.ctrl=\"doSomething\">Do something</div>\nTIP\nNote that modifier keys are different from regular keys and when used with keyup\nevents, they have to be pressed when the event is emitted. In other words, keyup.ctrl\nwill only trigger if you release a key while holding down ctrl\n. It won't trigger if you release the ctrl\nkey alone.\n.exact\nModifier\nThe .exact\nmodifier allows control of the exact combination of system modifiers needed to trigger an event.\ntemplate\n<!-- this will fire even if Alt or Shift is also pressed -->\n<button @click.ctrl=\"onClick\">A</button>\n<!-- this will only fire when Ctrl and no other keys are pressed -->\n<button @click.ctrl.exact=\"onCtrlClick\">A</button>\n<!-- this will only fire when no system modifiers are pressed -->\n<button @click.exact=\"onClick\">A</button>\nMouse Button Modifiers\n.left\n.right\n.middle\nThese modifiers restrict the handler to events triggered by a specific mouse button.",
    "metadata": {
      "source": "https://vuejs.org/guide/essentials/event-handling",
      "title": "Event Handling | Vue.js"
    }
  },
  {
    "page_content": "Template Syntax\nVue uses an HTML-based template syntax that allows you to declaratively bind the rendered DOM to the underlying component instance's data. All Vue templates are syntactically valid HTML that can be parsed by spec-compliant browsers and HTML parsers.\nUnder the hood, Vue compiles the templates into highly-optimized JavaScript code. Combined with the reactivity system, Vue can intelligently figure out the minimal number of components to re-render and apply the minimal amount of DOM manipulations when the app state changes.\nIf you are familiar with Virtual DOM concepts and prefer the raw power of JavaScript, you can also directly write render functions instead of templates, with optional JSX support. However, do note that they do not enjoy the same level of compile-time optimizations as templates.\nText Interpolation\nThe most basic form of data binding is text interpolation using the \"Mustache\" syntax (double curly braces):\ntemplate\n<span>Message: {{ msg }}</span>\nThe mustache tag will be replaced with the value of the msg\nproperty from the corresponding component instance. It will also be updated whenever the msg\nproperty changes.\nRaw HTML\nThe double mustaches interpret the data as plain text, not HTML. In order to output real HTML, you will need to use the v-html\ndirective:\ntemplate\n<p>Using text interpolation: {{ rawHtml }}</p>\n<p>Using v-html directive: <span v-html=\"rawHtml\"></span></p>\nUsing text interpolation: <span style=\"color: red\">This should be red.</span>\nUsing v-html directive: This should be red.\nHere we're encountering something new. The v-html\nattribute you're seeing is called a directive. Directives are prefixed with v-\nto indicate that they are special attributes provided by Vue, and as you may have guessed, they apply special reactive behavior to the rendered DOM. Here, we're basically saying \"keep this element's inner HTML up-to-date with the rawHtml\nproperty on the current active instance.\"\nThe contents of the span\nwill be replaced with the value of the rawHtml\nproperty, interpreted as plain HTML - data bindings are ignored. Note that you cannot use v-html\nto compose template partials, because Vue is not a string-based templating engine. Instead, components are preferred as the fundamental unit for UI reuse and composition.\nSecurity Warning\nDynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to XSS vulnerabilities. Only use v-html\non trusted content and never on user-provided content.\nAttribute Bindings\nMustaches cannot be used inside HTML attributes. Instead, use a v-bind\ndirective:\ntemplate\n<div v-bind:id=\"dynamicId\"></div>\nThe v-bind\ndirective instructs Vue to keep the element's id\nattribute in sync with the component's dynamicId\nproperty. If the bound value is null\nor undefined\n, then the attribute will be removed from the rendered element.\nShorthand\nBecause v-bind\nis so commonly used, it has a dedicated shorthand syntax:\ntemplate\n<div :id=\"dynamicId\"></div>\nAttributes that start with :\nmay look a bit different from normal HTML, but it is in fact a valid character for attribute names and all Vue-supported browsers can parse it correctly. In addition, they do not appear in the final rendered markup. The shorthand syntax is optional, but you will likely appreciate it when you learn more about its usage later.\nFor the rest of the guide, we will be using the shorthand syntax in code examples, as that's the most common usage for Vue developers.\nSame-name Shorthand\nIf the attribute has the same name with the JavaScript value being bound, the syntax can be further shortened to omit the attribute value:\ntemplate\n<!-- same as :id=\"id\" -->\n<div :id></div>\n<!-- this also works -->\n<div v-bind:id></div>\nThis is similar to the property shorthand syntax when declaring objects in JavaScript. Note this is a feature that is only available in Vue 3.4 and above.\nBoolean Attributes\nBoolean attributes are attributes that can indicate true / false values by their presence on an element. For example, disabled\nis one of the most commonly used boolean attributes.\nv-bind\nworks a bit differently in this case:\ntemplate\n<button :disabled=\"isButtonDisabled\">Button</button>\nThe disabled\nattribute will be included if isButtonDisabled\nhas a truthy value. It will also be included if the value is an empty string, maintaining consistency with <button disabled=\"\">\n. For other falsy values the attribute will be omitted.\nDynamically Binding Multiple Attributes\nIf you have a JavaScript object representing multiple attributes that looks like this:\njs\nconst objectOfAttrs = {\nid: 'container',\nclass: 'wrapper',\nstyle: 'background-color:green'\n}\nYou can bind them to a single element by using v-bind\nwithout an argument:\ntemplate\n<div v-bind=\"objectOfAttrs\"></div>\nUsing JavaScript Expressions\nSo far we've only been binding to simple property keys in our templates. But Vue actually supports the full power of JavaScript expressions inside all data bindings:\ntemplate\n{{ number + 1 }}\n{{ ok ? 'YES' : 'NO' }}\n{{ message.split('').reverse().join('') }}\n<div :id=\"`list-${id}`\"></div>\nThese expressions will be evaluated as JavaScript in the data scope of the current component instance.\nIn Vue templates, JavaScript expressions can be used in the following positions:\n- Inside text interpolations (mustaches)\n- In the attribute value of any Vue directives (special attributes that start with\nv-\n)\nExpressions Only\nEach binding can only contain one single expression. An expression is a piece of code that can be evaluated to a value. A simple check is whether it can be used after return\n.\nTherefore, the following will NOT work:\ntemplate\n<!-- this is a statement, not an expression: -->\n{{ var a = 1 }}\n<!-- flow control won't work either, use ternary expressions -->\n{{ if (ok) { return message } }}\nCalling Functions\nIt is possible to call a component-exposed method inside a binding expression:\ntemplate\n<time :title=\"toTitleDate(date)\" :datetime=\"date\">\n{{ formatDate(date) }}\n</time>\nTIP\nFunctions called inside binding expressions will be called every time the component updates, so they should not have any side effects, such as changing data or triggering asynchronous operations.\nRestricted Globals Access\nTemplate expressions are sandboxed and only have access to a restricted list of globals. The list exposes commonly used built-in globals such as Math\nand Date\n.\nGlobals not explicitly included in the list, for example user-attached properties on window\n, will not be accessible in template expressions. You can, however, explicitly define additional globals for all Vue expressions by adding them to app.config.globalProperties\n.\nDirectives\nDirectives are special attributes with the v-\nprefix. Vue provides a number of built-in directives, including v-html\nand v-bind\nwhich we have introduced above.\nDirective attribute values are expected to be single JavaScript expressions (with the exception of v-for\n, v-on\nand v-slot\n, which will be discussed in their respective sections later). A directive's job is to reactively apply updates to the DOM when the value of its expression changes. Take v-if\nas an example:\ntemplate\n<p v-if=\"seen\">Now you see me</p>\nHere, the v-if\ndirective would remove / insert the <p>\nelement based on the truthiness of the value of the expression seen\n.\nArguments\nSome directives can take an \"argument\", denoted by a colon after the directive name. For example, the v-bind\ndirective is used to reactively update an HTML attribute:\ntemplate\n<a v-bind:href=\"url\"> ... </a>\n<!-- shorthand -->\n<a :href=\"url\"> ... </a>\nHere, href\nis the argument, which tells the v-bind\ndirective to bind the element's href\nattribute to the value of the expression url\n. In the shorthand, everything before the argument (i.e., v-bind:\n) is condensed into a single character, :\n.\nAnother example is the v-on\ndirective, which listens to DOM events:\ntemplate\n<a v-on:click=\"doSomething\"> ... </a>\n<!-- shorthand -->\n<a @click=\"doSomething\"> ... </a>\nHere, the argument is the event name to listen to: click\n. v-on\nhas a corresponding shorthand, namely the @\ncharacter. We will talk about event handling in more detail too.\nDynamic Arguments\nIt is also possible to use a JavaScript expression in a directive argument by wrapping it with square brackets:\ntemplate\n<!--\nNote that there are some constraints to the argument expression,\nas explained in the \"Dynamic Argument Value Constraints\" and \"Dynamic Argument Syntax Constraints\" sections below.\n-->\n<a v-bind:[attributeName]=\"url\"> ... </a>\n<!-- shorthand -->\n<a :[attributeName]=\"url\"> ... </a>\nHere, attributeName\nwill be dynamically evaluated as a JavaScript expression, and its evaluated value will be used as the final value for the argument. For example, if your component instance has a data property, attributeName\n, whose value is \"href\"\n, then this binding will be equivalent to v-bind:href\n.\nSimilarly, you can use dynamic arguments to bind a handler to a dynamic event name:\ntemplate\n<a v-on:[eventName]=\"doSomething\"> ... </a>\n<!-- shorthand -->\n<a @[eventName]=\"doSomething\"> ... </a>\nIn this example, when eventName\n's value is \"focus\"\n, v-on:[eventName]\nwill be equivalent to v-on:focus\n.\nDynamic Argument Value Constraints\nDynamic arguments are expected to evaluate to a string, with the exception of null\n. The special value null\ncan be used to explicitly remove the binding. Any other non-string value will trigger a warning.\nDynamic Argument Syntax Constraints\nDynamic argument expressions have some syntax constraints because certain characters, such as spaces and quotes, are invalid inside HTML attribute names. For example, the following is invalid:\ntemplate\n<!-- This will trigger a compiler warning. -->\n<a :['foo' + bar]=\"value\"> ... </a>\nIf you need to pass a complex dynamic argument, it's probably better to use a computed property, which we will cover shortly.\nWhen using in-DOM templates (templates directly written in an HTML file), you should also avoid naming keys with uppercase characters, as browsers will coerce attribute names into lowercase:\ntemplate\n<a :[someAttr]=\"value\"> ... </a>\nThe above will be converted to :[someattr]\nin in-DOM templates. If your component has a someAttr\nproperty instead of someattr\n, your code won't work. Templates inside Single-File Components are not subject to this constraint.\nModifiers\nModifiers are special postfixes denoted by a dot, which indicate that a directive should be bound in some special way. For example, the .prevent\nmodifier tells the v-on\ndirective to call event.preventDefault()\non the triggered event:\ntemplate\n<form @submit.prevent=\"onSubmit\">...</form>\nYou'll see other examples of modifiers later, for v-on\nand for v-model\n, when we explore those features.\nAnd finally, here's the full directive syntax visualized:",
    "metadata": {
      "source": "https://vuejs.org/guide/essentials/template-syntax",
      "title": "Template Syntax | Vue.js"
    }
  },
  {
    "page_content": "Conditional Rendering\nv-if\nThe directive v-if\nis used to conditionally render a block. The block will only be rendered if the directive's expression returns a truthy value.\ntemplate\n<h1 v-if=\"awesome\">Vue is awesome!</h1>\nv-else\nYou can use the v-else\ndirective to indicate an \"else block\" for v-if\n:\ntemplate\n<button @click=\"awesome = !awesome\">Toggle</button>\n<h1 v-if=\"awesome\">Vue is awesome!</h1>\n<h1 v-else>Oh no 😢</h1>\nVue is awesome!\nA v-else\nelement must immediately follow a v-if\nor a v-else-if\nelement - otherwise it will not be recognized.\nv-else-if\nThe v-else-if\n, as the name suggests, serves as an \"else if block\" for v-if\n. It can also be chained multiple times:\ntemplate\n<div v-if=\"type === 'A'\">\nA\n</div>\n<div v-else-if=\"type === 'B'\">\nB\n</div>\n<div v-else-if=\"type === 'C'\">\nC\n</div>\n<div v-else>\nNot A/B/C\n</div>\nSimilar to v-else\n, a v-else-if\nelement must immediately follow a v-if\nor a v-else-if\nelement.\nv-if\non <template>\nBecause v-if\nis a directive, it has to be attached to a single element. But what if we want to toggle more than one element? In this case we can use v-if\non a <template>\nelement, which serves as an invisible wrapper. The final rendered result will not include the <template>\nelement.\ntemplate\n<template v-if=\"ok\">\n<h1>Title</h1>\n<p>Paragraph 1</p>\n<p>Paragraph 2</p>\n</template>\nv-else\nand v-else-if\ncan also be used on <template>\n.\nv-show\nAnother option for conditionally displaying an element is the v-show\ndirective. The usage is largely the same:\ntemplate\n<h1 v-show=\"ok\">Hello!</h1>\nThe difference is that an element with v-show\nwill always be rendered and remain in the DOM; v-show\nonly toggles the display\nCSS property of the element.\nv-show\ndoesn't support the <template>\nelement, nor does it work with v-else\n.\nv-if\nvs. v-show\nv-if\nis \"real\" conditional rendering because it ensures that event listeners and child components inside the conditional block are properly destroyed and re-created during toggles.\nv-if\nis also lazy: if the condition is false on initial render, it will not do anything - the conditional block won't be rendered until the condition becomes true for the first time.\nIn comparison, v-show\nis much simpler - the element is always rendered regardless of initial condition, with CSS-based toggling.\nGenerally speaking, v-if\nhas higher toggle costs while v-show\nhas higher initial render costs. So prefer v-show\nif you need to toggle something very often, and prefer v-if\nif the condition is unlikely to change at runtime.\nv-if\nwith v-for\nNote\nIt's not recommended to use v-if\nand v-for\non the same element due to implicit precedence. Refer to style guide for details.\nWhen v-if\nand v-for\nare both used on the same element, v-if\nwill be evaluated first. See the list rendering guide for details.",
    "metadata": {
      "source": "https://vuejs.org/guide/essentials/conditional",
      "title": "Conditional Rendering | Vue.js"
    }
  },
  {
    "page_content": "Custom Directives\nIntroduction\nIn addition to the default set of directives shipped in core (like v-model\nor v-show\n), Vue also allows you to register your own custom directives.\nWe have introduced two forms of code reuse in Vue: components and composables. Components are the main building blocks, while composables are focused on reusing stateful logic. Custom directives, on the other hand, are mainly intended for reusing logic that involves low-level DOM access on plain elements.\nA custom directive is defined as an object containing lifecycle hooks similar to those of a component. The hooks receive the element the directive is bound to. Here is an example of a directive that focuses an input when the element is inserted into the DOM by Vue:\nvue\n<script setup>\n// enables v-focus in templates\nconst vFocus = {\nmounted: (el) => el.focus()\n}\n</script>\n<template>\n<input v-focus />\n</template>\nAssuming you haven't clicked elsewhere on the page, the input above should be auto-focused. This directive is more useful than the autofocus\nattribute because it works not just on page load - it also works when the element is dynamically inserted by Vue.\nIn <script setup>\n, any camelCase variable that starts with the v\nprefix can be used as a custom directive. In the example above, vFocus\ncan be used in the template as v-focus\n.\nIf not using <script setup>\n, custom directives can be registered using the directives\noption:\njs\nexport default {\nsetup() {\n/*...*/\n},\ndirectives: {\n// enables v-focus in template\nfocus: {\n/* ... */\n}\n}\n}\nIt is also common to globally register custom directives at the app level:\njs\nconst app = createApp({})\n// make v-focus usable in all components\napp.directive('focus', {\n/* ... */\n})\nTIP\nCustom directives should only be used when the desired functionality can only be achieved via direct DOM manipulation. Prefer declarative templating using built-in directives such as v-bind\nwhen possible because they are more efficient and server-rendering friendly.\nDirective Hooks\nA directive definition object can provide several hook functions (all optional):\njs\nconst myDirective = {\n// called before bound element's attributes\n// or event listeners are applied\ncreated(el, binding, vnode) {\n// see below for details on arguments\n},\n// called right before the element is inserted into the DOM.\nbeforeMount(el, binding, vnode) {},\n// called when the bound element's parent component\n// and all its children are mounted.\nmounted(el, binding, vnode) {},\n// called before the parent component is updated\nbeforeUpdate(el, binding, vnode, prevVnode) {},\n// called after the parent component and\n// all of its children have updated\nupdated(el, binding, vnode, prevVnode) {},\n// called before the parent component is unmounted\nbeforeUnmount(el, binding, vnode) {},\n// called when the parent component is unmounted\nunmounted(el, binding, vnode) {}\n}\nHook Arguments\nDirective hooks are passed these arguments:\nel\n: the element the directive is bound to. This can be used to directly manipulate the DOM.binding\n: an object containing the following properties.value\n: The value passed to the directive. For example inv-my-directive=\"1 + 1\"\n, the value would be2\n.oldValue\n: The previous value, only available inbeforeUpdate\nandupdated\n. It is available whether or not the value has changed.arg\n: The argument passed to the directive, if any. For example inv-my-directive:foo\n, the arg would be\"foo\"\n.modifiers\n: An object containing modifiers, if any. For example inv-my-directive.foo.bar\n, the modifiers object would be{ foo: true, bar: true }\n.instance\n: The instance of the component where the directive is used.dir\n: the directive definition object.\nvnode\n: the underlying VNode representing the bound element.prevVnode\n: the VNode representing the bound element from the previous render. Only available in thebeforeUpdate\nandupdated\nhooks.\nAs an example, consider the following directive usage:\ntemplate\n<div v-example:foo.bar=\"baz\">\nThe binding\nargument would be an object in the shape of:\njs\n{\narg: 'foo',\nmodifiers: { bar: true },\nvalue: /* value of `baz` */,\noldValue: /* value of `baz` from previous update */\n}\nSimilar to built-in directives, custom directive arguments can be dynamic. For example:\ntemplate\n<div v-example:[arg]=\"value\"></div>\nHere the directive argument will be reactively updated based on arg\nproperty in our component state.\nNote\nApart from el\n, you should treat these arguments as read-only and never modify them. If you need to share information across hooks, it is recommended to do so through element's dataset.\nFunction Shorthand\nIt's common for a custom directive to have the same behavior for mounted\nand updated\n, with no need for the other hooks. In such cases we can define the directive as a function:\ntemplate\n<div v-color=\"color\"></div>\njs\napp.directive('color', (el, binding) => {\n// this will be called for both `mounted` and `updated`\nel.style.color = binding.value\n})\nObject Literals\nIf your directive needs multiple values, you can also pass in a JavaScript object literal. Remember, directives can take any valid JavaScript expression.\ntemplate\n<div v-demo=\"{ color: 'white', text: 'hello!' }\"></div>\njs\napp.directive('demo', (el, binding) => {\nconsole.log(binding.value.color) // => \"white\"\nconsole.log(binding.value.text) // => \"hello!\"\n})\nUsage on Components\nNot recommended\nUsing custom directives on components is not recommended. Unexpected behaviour may occur when a component has multiple root nodes.\nWhen used on components, custom directives will always apply to a component's root node, similar to Fallthrough Attributes.\ntemplate\n<MyComponent v-demo=\"test\" />\ntemplate\n<!-- template of MyComponent -->\n<div> <!-- v-demo directive will be applied here -->\n<span>My component content</span>\n</div>\nNote that components can potentially have more than one root node. When applied to a multi-root component, a directive will be ignored and a warning will be thrown. Unlike attributes, directives can't be passed to a different element with v-bind=\"$attrs\"\n.",
    "metadata": {
      "source": "https://vuejs.org/guide/reusability/custom-directives",
      "title": "Custom Directives | Vue.js"
    }
  },
  {
    "page_content": "Component v-model\nBasic Usage\nv-model\ncan be used on a component to implement a two-way binding.\nStarting in Vue 3.4, the recommended approach to achieve this is using the defineModel()\nmacro:\nvue\n<!-- Child.vue -->\n<script setup>\nconst model = defineModel()\nfunction update() {\nmodel.value++\n}\n</script>\n<template>\n<div>Parent bound v-model is: {{ model }}</div>\n<button @click=\"update\">Increment</button>\n</template>\nThe parent can then bind a value with v-model\n:\ntemplate\n<!-- Parent.vue -->\n<Child v-model=\"countModel\" />\nThe value returned by defineModel()\nis a ref. It can be accessed and mutated like any other ref, except that it acts as a two-way binding between a parent value and a local one:\n- Its\n.value\nis synced with the value bound by the parentv-model\n; - When it is mutated by the child, it causes the parent bound value to be updated as well.\nThis means you can also bind this ref to a native input element with v-model\n, making it straightforward to wrap native input elements while providing the same v-model\nusage:\nvue\n<script setup>\nconst model = defineModel()\n</script>\n<template>\n<input v-model=\"model\" />\n</template>\nUnder the Hood\ndefineModel\nis a convenience macro. The compiler expands it to the following:\n- A prop named\nmodelValue\n, which the local ref's value is synced with; - An event named\nupdate:modelValue\n, which is emitted when the local ref's value is mutated.\nThis is how you would implement the same child component shown above prior to 3.4:\nvue\n<!-- Child.vue -->\n<script setup>\nconst props = defineProps(['modelValue'])\nconst emit = defineEmits(['update:modelValue'])\n</script>\n<template>\n<input\n:value=\"props.modelValue\"\n@input=\"emit('update:modelValue', $event.target.value)\"\n/>\n</template>\nThen, v-model=\"foo\"\nin the parent component will be compiled to:\ntemplate\n<!-- Parent.vue -->\n<Child\n:modelValue=\"foo\"\n@update:modelValue=\"$event => (foo = $event)\"\n/>\nAs you can see, it is quite a bit more verbose. However, it is helpful to understand what is happening under the hood.\nBecause defineModel\ndeclares a prop, you can therefore declare the underlying prop's options by passing it to defineModel\n:\njs\n// making the v-model required\nconst model = defineModel({ required: true })\n// providing a default value\nconst model = defineModel({ default: 0 })\nWARNING\nIf you have a default\nvalue for defineModel\nprop and you don't provide any value for this prop from the parent component, it can cause a de-synchronization between parent and child components. In the example below, the parent's myRef\nis undefined, but the child's model\nis 1:\njs\n// child component:\nconst model = defineModel({ default: 1 })\n// parent component:\nconst myRef = ref()\nhtml\n<Child v-model=\"myRef\"></Child>\nv-model\narguments\nv-model\non a component can also accept an argument:\ntemplate\n<MyComponent v-model:title=\"bookTitle\" />\nIn the child component, we can support the corresponding argument by passing a string to defineModel()\nas its first argument:\nvue\n<!-- MyComponent.vue -->\n<script setup>\nconst title = defineModel('title')\n</script>\n<template>\n<input type=\"text\" v-model=\"title\" />\n</template>\nIf prop options are also needed, they should be passed after the model name:\njs\nconst title = defineModel('title', { required: true })\nPre 3.4 Usage\nvue\n<!-- MyComponent.vue -->\n<script setup>\ndefineProps({\ntitle: {\nrequired: true\n}\n})\ndefineEmits(['update:title'])\n</script>\n<template>\n<input\ntype=\"text\"\n:value=\"title\"\n@input=\"$emit('update:title', $event.target.value)\"\n/>\n</template>\nMultiple v-model\nbindings\nBy leveraging the ability to target a particular prop and event as we learned before with v-model\narguments, we can now create multiple v-model\nbindings on a single component instance.\nEach v-model\nwill sync to a different prop, without the need for extra options in the component:\ntemplate\n<UserName\nv-model:first-name=\"first\"\nv-model:last-name=\"last\"\n/>\nvue\n<script setup>\nconst firstName = defineModel('firstName')\nconst lastName = defineModel('lastName')\n</script>\n<template>\n<input type=\"text\" v-model=\"firstName\" />\n<input type=\"text\" v-model=\"lastName\" />\n</template>\nPre 3.4 Usage\nvue\n<script setup>\ndefineProps({\nfirstName: String,\nlastName: String\n})\ndefineEmits(['update:firstName', 'update:lastName'])\n</script>\n<template>\n<input\ntype=\"text\"\n:value=\"firstName\"\n@input=\"$emit('update:firstName', $event.target.value)\"\n/>\n<input\ntype=\"text\"\n:value=\"lastName\"\n@input=\"$emit('update:lastName', $event.target.value)\"\n/>\n</template>\nHandling v-model\nmodifiers\nWhen we were learning about form input bindings, we saw that v-model\nhas built-in modifiers - .trim\n, .number\nand .lazy\n. In some cases, you might also want the v-model\non your custom input component to support custom modifiers.\nLet's create an example custom modifier, capitalize\n, that capitalizes the first letter of the string provided by the v-model\nbinding:\ntemplate\n<MyComponent v-model.capitalize=\"myText\" />\nModifiers added to a component v-model\ncan be accessed in the child component by destructuring the defineModel()\nreturn value like this:\nvue\n<script setup>\nconst [model, modifiers] = defineModel()\nconsole.log(modifiers) // { capitalize: true }\n</script>\n<template>\n<input type=\"text\" v-model=\"model\" />\n</template>\nTo conditionally adjust how the value should be read / written based on modifiers, we can pass get\nand set\noptions to defineModel()\n. These two options receive the value on get / set of the model ref and should return a transformed value. This is how we can use the set\noption to implement the capitalize\nmodifier:\nvue\n<script setup>\nconst [model, modifiers] = defineModel({\nset(value) {\nif (modifiers.capitalize) {\nreturn value.charAt(0).toUpperCase() + value.slice(1)\n}\nreturn value\n}\n})\n</script>\n<template>\n<input type=\"text\" v-model=\"model\" />\n</template>\nPre 3.4 Usage\nvue\n<script setup>\nconst props = defineProps({\nmodelValue: String,\nmodelModifiers: { default: () => ({}) }\n})\nconst emit = defineEmits(['update:modelValue'])\nfunction emitValue(e) {\nlet value = e.target.value\nif (props.modelModifiers.capitalize) {\nvalue = value.charAt(0).toUpperCase() + value.slice(1)\n}\nemit('update:modelValue', value)\n}\n</script>\n<template>\n<input type=\"text\" :value=\"modelValue\" @input=\"emitValue\" />\n</template>\nModifiers for v-model\nwith arguments\nHere's another example of using modifiers with multiple v-model\nwith different arguments:\ntemplate\n<UserName\nv-model:first-name.capitalize=\"first\"\nv-model:last-name.uppercase=\"last\"\n/>\nvue\n<script setup>\nconst [firstName, firstNameModifiers] = defineModel('firstName')\nconst [lastName, lastNameModifiers] = defineModel('lastName')\nconsole.log(firstNameModifiers) // { capitalize: true }\nconsole.log(lastNameModifiers) // { uppercase: true }\n</script>\nPre 3.4 Usage\nvue\n<script setup>\nconst props = defineProps({\nfirstName: String,\nlastName: String,\nfirstNameModifiers: { default: () => ({}) },\nlastNameModifiers: { default: () => ({}) }\n})\ndefineEmits(['update:firstName', 'update:lastName'])\nconsole.log(props.firstNameModifiers) // { capitalize: true }\nconsole.log(props.lastNameModifiers) // { uppercase: true }\n</script>",
    "metadata": {
      "source": "https://vuejs.org/guide/components/v-model",
      "title": "Component v-model | Vue.js"
    }
  },
  {
    "page_content": "TypeScript with Composition API\nThis page assumes you've already read the overview on Using Vue with TypeScript.\nTyping Component Props\nUsing <script setup>\nWhen using <script setup>\n, the defineProps()\nmacro supports inferring the props types based on its argument:\nvue\n<script setup lang=\"ts\">\nconst props = defineProps({\nfoo: { type: String, required: true },\nbar: Number\n})\nprops.foo // string\nprops.bar // number | undefined\n</script>\nThis is called \"runtime declaration\", because the argument passed to defineProps()\nwill be used as the runtime props\noption.\nHowever, it is usually more straightforward to define props with pure types via a generic type argument:\nvue\n<script setup lang=\"ts\">\nconst props = defineProps<{\nfoo: string\nbar?: number\n}>()\n</script>\nThis is called \"type-based declaration\". The compiler will try to do its best to infer the equivalent runtime options based on the type argument. In this case, our second example compiles into the exact same runtime options as the first example.\nYou can use either type-based declaration OR runtime declaration, but you cannot use both at the same time.\nWe can also move the props types into a separate interface:\nvue\n<script setup lang=\"ts\">\ninterface Props {\nfoo: string\nbar?: number\n}\nconst props = defineProps<Props>()\n</script>\nThis also works if Props\nis imported from an external source. This feature requires TypeScript to be a peer dependency of Vue.\nvue\n<script setup lang=\"ts\">\nimport type { Props } from './foo'\nconst props = defineProps<Props>()\n</script>\nSyntax Limitations\nIn version 3.2 and below, the generic type parameter for defineProps()\nwere limited to a type literal or a reference to a local interface.\nThis limitation has been resolved in 3.3. The latest version of Vue supports referencing imported and a limited set of complex types in the type parameter position. However, because the type to runtime conversion is still AST-based, some complex types that require actual type analysis, e.g. conditional types, are not supported. You can use conditional types for the type of a single prop, but not the entire props object.\nProps Default Values\nWhen using type-based declaration, we lose the ability to declare default values for the props. This can be resolved by the withDefaults\ncompiler macro:\nts\nexport interface Props {\nmsg?: string\nlabels?: string[]\n}\nconst props = withDefaults(defineProps<Props>(), {\nmsg: 'hello',\nlabels: () => ['one', 'two']\n})\nThis will be compiled to equivalent runtime props default\noptions. In addition, the withDefaults\nhelper provides type checks for the default values, and ensures the returned props\ntype has the optional flags removed for properties that do have default values declared.\nINFO\nNote that default values for mutable reference types (like arrays or objects) should be wrapped in functions to avoid accidental modification and external side effects. This ensures each component instance gets its own copy of the default value.\nWithout <script setup>\nIf not using <script setup>\n, it is necessary to use defineComponent()\nto enable props type inference. The type of the props object passed to setup()\nis inferred from the props\noption.\nts\nimport { defineComponent } from 'vue'\nexport default defineComponent({\nprops: {\nmessage: String\n},\nsetup(props) {\nprops.message // <-- type: string\n}\n})\nComplex prop types\nWith type-based declaration, a prop can use a complex type much like any other type:\nvue\n<script setup lang=\"ts\">\ninterface Book {\ntitle: string\nauthor: string\nyear: number\n}\nconst props = defineProps<{\nbook: Book\n}>()\n</script>\nFor runtime declaration, we can use the PropType\nutility type:\nts\nimport type { PropType } from 'vue'\nconst props = defineProps({\nbook: Object as PropType<Book>\n})\nThis works in much the same way if we're specifying the props\noption directly:\nts\nimport { defineComponent } from 'vue'\nimport type { PropType } from 'vue'\nexport default defineComponent({\nprops: {\nbook: Object as PropType<Book>\n}\n})\nThe props\noption is more commonly used with the Options API, so you'll find more detailed examples in the guide to TypeScript with Options API. The techniques shown in those examples also apply to runtime declarations using defineProps()\n.\nTyping Component Emits\nIn <script setup>\n, the emit\nfunction can also be typed using either runtime declaration OR type declaration:\nvue\n<script setup lang=\"ts\">\n// runtime\nconst emit = defineEmits(['change', 'update'])\n// options based\nconst emit = defineEmits({\nchange: (id: number) => {\n// return `true` or `false` to indicate\n// validation pass / fail\n},\nupdate: (value: string) => {\n// return `true` or `false` to indicate\n// validation pass / fail\n}\n})\n// type-based\nconst emit = defineEmits<{\n(e: 'change', id: number): void\n(e: 'update', value: string): void\n}>()\n// 3.3+: alternative, more succinct syntax\nconst emit = defineEmits<{\nchange: [id: number]\nupdate: [value: string]\n}>()\n</script>\nThe type argument can be one of the following:\n- A callable function type, but written as a type literal with Call Signatures. It will be used as the type of the returned\nemit\nfunction. - A type literal where the keys are the event names, and values are array / tuple types representing the additional accepted parameters for the event. The example above is using named tuples so each argument can have an explicit name.\nAs we can see, the type declaration gives us much finer-grained control over the type constraints of emitted events.\nWhen not using <script setup>\n, defineComponent()\nis able to infer the allowed events for the emit\nfunction exposed on the setup context:\nts\nimport { defineComponent } from 'vue'\nexport default defineComponent({\nemits: ['change'],\nsetup(props, { emit }) {\nemit('change') // <-- type check / auto-completion\n}\n})\nTyping ref()\nRefs infer the type from the initial value:\nts\nimport { ref } from 'vue'\n// inferred type: Ref<number>\nconst year = ref(2020)\n// => TS Error: Type 'string' is not assignable to type 'number'.\nyear.value = '2020'\nSometimes we may need to specify complex types for a ref's inner value. We can do that by using the Ref\ntype:\nts\nimport { ref } from 'vue'\nimport type { Ref } from 'vue'\nconst year: Ref<string | number> = ref('2020')\nyear.value = 2020 // ok!\nOr, by passing a generic argument when calling ref()\nto override the default inference:\nts\n// resulting type: Ref<string | number>\nconst year = ref<string | number>('2020')\nyear.value = 2020 // ok!\nIf you specify a generic type argument but omit the initial value, the resulting type will be a union type that includes undefined\n:\nts\n// inferred type: Ref<number | undefined>\nconst n = ref<number>()\nTyping reactive()\nreactive()\nalso implicitly infers the type from its argument:\nts\nimport { reactive } from 'vue'\n// inferred type: { title: string }\nconst book = reactive({ title: 'Vue 3 Guide' })\nTo explicitly type a reactive\nproperty, we can use interfaces:\nts\nimport { reactive } from 'vue'\ninterface Book {\ntitle: string\nyear?: number\n}\nconst book: Book = reactive({ title: 'Vue 3 Guide' })\nTIP\nIt's not recommended to use the generic argument of reactive()\nbecause the returned type, which handles nested ref unwrapping, is different from the generic argument type.\nTyping computed()\ncomputed()\ninfers its type based on the getter's return value:\nts\nimport { ref, computed } from 'vue'\nconst count = ref(0)\n// inferred type: ComputedRef<number>\nconst double = computed(() => count.value * 2)\n// => TS Error: Property 'split' does not exist on type 'number'\nconst result = double.value.split('')\nYou can also specify an explicit type via a generic argument:\nts\nconst double = computed<number>(() => {\n// type error if this doesn't return a number\n})\nTyping Event Handlers\nWhen dealing with native DOM events, it might be useful to type the argument we pass to the handler correctly. Let's take a look at this example:\nvue\n<script setup lang=\"ts\">\nfunction handleChange(event) {\n// `event` implicitly has `any` type\nconsole.log(event.target.value)\n}\n</script>\n<template>\n<input type=\"text\" @change=\"handleChange\" />\n</template>\nWithout type annotation, the event\nargument will implicitly have a type of any\n. This will also result in a TS error if \"strict\": true\nor \"noImplicitAny\": true\nare used in tsconfig.json\n. It is therefore recommended to explicitly annotate the argument of event handlers. In addition, you may need to use type assertions when accessing the properties of event\n:\nts\nfunction handleChange(event: Event) {\nconsole.log((event.target as HTMLInputElement).value)\n}\nTyping Provide / Inject\nProvide and inject are usually performed in separate components. To properly type injected values, Vue provides an InjectionKey\ninterface, which is a generic type that extends Symbol\n. It can be used to sync the type of the injected value between the provider and the consumer:\nts\nimport { provide, inject } from 'vue'\nimport type { InjectionKey } from 'vue'\nconst key = Symbol() as InjectionKey<string>\nprovide(key, 'foo') // providing non-string value will result in error\nconst foo = inject(key) // type of foo: string | undefined\nIt's recommended to place the injection key in a separate file so that it can be imported in multiple components.\nWhen using string injection keys, the type of the injected value will be unknown\n, and needs to be explicitly declared via a generic type argument:\nts\nconst foo = inject<string>('foo') // type: string | undefined\nNotice the injected value can still be undefined\n, because there is no guarantee that a provider will provide this value at runtime.\nThe undefined\ntype can be removed by providing a default value:\nts\nconst foo = inject<string>('foo', 'bar') // type: string\nIf you are sure that the value is always provided, you can also force cast the value:\nts\nconst foo = inject('foo') as string\nTyping Template Refs\nTemplate refs should be created with an explicit generic type argument and an initial value of null\n:\nvue\n<script setup lang=\"ts\">\nimport { ref, onMounted } from 'vue'\nconst el = ref<HTMLInputElement | null>(null)\nonMounted(() => {\nel.value?.focus()\n})\n</script>\n<template>\n<input ref=\"el\" />\n</template>\nTo get the right DOM interface you can check pages like MDN.\nNote that for strict type safety, it is necessary to use optional chaining or type guards when accessing el.value\n. This is because the initial ref value is null\nuntil the component is mounted, and it can also be set to null\nif the referenced element is unmounted by v-if\n.\nTyping Component Template Refs\nSometimes you might need to annotate a template ref for a child component in order to call its public method. For example, we have a MyModal\nchild component with a method that opens the modal:\nvue\n<!-- MyModal.vue -->\n<script setup lang=\"ts\">\nimport { ref } from 'vue'\nconst isContentShown = ref(false)\nconst open = () => (isContentShown.value = true)\ndefineExpose({\nopen\n})\n</script>\nIn order to get the instance type of MyModal\n, we need to first get its type via typeof\n, then use TypeScript's built-in InstanceType\nutility to extract its instance type:\nvue\n<!-- App.vue -->\n<script setup lang=\"ts\">\nimport MyModal from './MyModal.vue'\nconst modal = ref<InstanceType<typeof MyModal> | null>(null)\nconst openModal = () => {\nmodal.value?.open()\n}\n</script>\nIn cases where the exact type of the component isn't available or isn't important, ComponentPublicInstance\ncan be used instead. This will only include properties that are shared by all components, such as $el\n:\nts\nimport { ref } from 'vue'\nimport type { ComponentPublicInstance } from 'vue'\nconst child = ref<ComponentPublicInstance | null>(null)",
    "metadata": {
      "source": "https://vuejs.org/guide/typescript/composition-api",
      "title": "TypeScript with Composition API | Vue.js"
    }
  },
  {
    "page_content": "State Management\nWhat is State Management?\nTechnically, every Vue component instance already \"manages\" its own reactive state. Take a simple counter component as an example:\nvue\n<script setup>\nimport { ref } from 'vue'\n// state\nconst count = ref(0)\n// actions\nfunction increment() {\ncount.value++\n}\n</script>\n<!-- view -->\n<template>{{ count }}</template>\nIt is a self-contained unit with the following parts:\n- The state, the source of truth that drives our app;\n- The view, a declarative mapping of the state;\n- The actions, the possible ways the state could change in reaction to user inputs from the view.\nThis is a simple representation of the concept of \"one-way data flow\":\nHowever, the simplicity starts to break down when we have multiple components that share a common state:\n- Multiple views may depend on the same piece of state.\n- Actions from different views may need to mutate the same piece of state.\nFor case one, a possible workaround is by \"lifting\" the shared state up to a common ancestor component, and then pass it down as props. However, this quickly gets tedious in component trees with deep hierarchies, leading to another problem known as Prop Drilling.\nFor case two, we often find ourselves resorting to solutions such as reaching for direct parent / child instances via template refs, or trying to mutate and synchronize multiple copies of the state via emitted events. Both of these patterns are brittle and quickly lead to unmaintainable code.\nA simpler and more straightforward solution is to extract the shared state out of the components, and manage it in a global singleton. With this, our component tree becomes a big \"view\", and any component can access the state or trigger actions, no matter where they are in the tree!\nSimple State Management with Reactivity API\nIf you have a piece of state that should be shared by multiple instances, you can use reactive()\nto create a reactive object, and then import it into multiple components:\njs\n// store.js\nimport { reactive } from 'vue'\nexport const store = reactive({\ncount: 0\n})\nvue\n<!-- ComponentA.vue -->\n<script setup>\nimport { store } from './store.js'\n</script>\n<template>From A: {{ store.count }}</template>\nvue\n<!-- ComponentB.vue -->\n<script setup>\nimport { store } from './store.js'\n</script>\n<template>From B: {{ store.count }}</template>\nNow whenever the store\nobject is mutated, both <ComponentA>\nand <ComponentB>\nwill update their views automatically - we have a single source of truth now.\nHowever, this also means any component importing store\ncan mutate it however they want:\ntemplate\n<template>\n<button @click=\"store.count++\">\nFrom B: {{ store.count }}\n</button>\n</template>\nWhile this works in simple cases, global state that can be arbitrarily mutated by any component is not going to be very maintainable in the long run. To ensure the state-mutating logic is centralized like the state itself, it is recommended to define methods on the store with names that express the intention of the actions:\njs\n// store.js\nimport { reactive } from 'vue'\nexport const store = reactive({\ncount: 0,\nincrement() {\nthis.count++\n}\n})\ntemplate\n<template>\n<button @click=\"store.increment()\">\nFrom B: {{ store.count }}\n</button>\n</template>\nTIP\nNote the click handler uses store.increment()\nwith parentheses - this is necessary to call the method with the proper this\ncontext since it's not a component method.\nAlthough here we are using a single reactive object as a store, you can also share reactive state created using other Reactivity APIs such as ref()\nor computed()\n, or even return global state from a Composable:\njs\nimport { ref } from 'vue'\n// global state, created in module scope\nconst globalCount = ref(1)\nexport function useCount() {\n// local state, created per-component\nconst localCount = ref(1)\nreturn {\nglobalCount,\nlocalCount\n}\n}\nThe fact that Vue's reactivity system is decoupled from the component model makes it extremely flexible.\nSSR Considerations\nIf you are building an application that leverages Server-Side Rendering (SSR), the above pattern can lead to issues due to the store being a singleton shared across multiple requests. This is discussed in more details in the SSR guide.\nPinia\nWhile our hand-rolled state management solution will suffice in simple scenarios, there are many more things to consider in large-scale production applications:\n- Stronger conventions for team collaboration\n- Integrating with the Vue DevTools, including timeline, in-component inspection, and time-travel debugging\n- Hot Module Replacement\n- Server-Side Rendering support\nPinia is a state management library that implements all of the above. It is maintained by the Vue core team, and works with both Vue 2 and Vue 3.\nExisting users may be familiar with Vuex, the previous official state management library for Vue. With Pinia serving the same role in the ecosystem, Vuex is now in maintenance mode. It still works, but will no longer receive new features. It is recommended to use Pinia for new applications.\nPinia started out as an exploration of what the next iteration of Vuex could look like, incorporating many ideas from core team discussions for Vuex 5. Eventually, we realized that Pinia already implements most of what we wanted in Vuex 5, and decided to make it the new recommendation instead.\nCompared to Vuex, Pinia provides a simpler API with less ceremony, offers Composition-API-style APIs, and most importantly, has solid type inference support when used with TypeScript.",
    "metadata": {
      "source": "https://vuejs.org/guide/scaling-up/state-management",
      "title": "State Management | Vue.js"
    }
  },
  {
    "page_content": "Server-Side Rendering (SSR)\nOverview\nWhat is SSR?\nVue.js is a framework for building client-side applications. By default, Vue components produce and manipulate DOM in the browser as output. However, it is also possible to render the same components into HTML strings on the server, send them directly to the browser, and finally \"hydrate\" the static markup into a fully interactive app on the client.\nA server-rendered Vue.js app can also be considered \"isomorphic\" or \"universal\", in the sense that the majority of your app's code runs on both the server and the client.\nWhy SSR?\nCompared to a client-side Single-Page Application (SPA), the advantage of SSR primarily lies in:\nFaster time-to-content: this is more prominent on slow internet or slow devices. Server-rendered markup doesn't need to wait until all JavaScript has been downloaded and executed to be displayed, so your user will see a fully-rendered page sooner. In addition, data fetching is done on the server-side for the initial visit, which likely has a faster connection to your database than the client. This generally results in improved Core Web Vitals metrics, better user experience, and can be critical for applications where time-to-content is directly associated with conversion rate.\nUnified mental model: you get to use the same language and the same declarative, component-oriented mental model for developing your entire app, instead of jumping back and forth between a backend templating system and a frontend framework.\nBetter SEO: the search engine crawlers will directly see the fully rendered page.\nTIP\nAs of now, Google and Bing can index synchronous JavaScript applications just fine. Synchronous being the key word there. If your app starts with a loading spinner, then fetches content via Ajax, the crawler will not wait for you to finish. This means if you have content fetched asynchronously on pages where SEO is important, SSR might be necessary.\nThere are also some trade-offs to consider when using SSR:\nDevelopment constraints. Browser-specific code can only be used inside certain lifecycle hooks; some external libraries may need special treatment to be able to run in a server-rendered app.\nMore involved build setup and deployment requirements. Unlike a fully static SPA that can be deployed on any static file server, a server-rendered app requires an environment where a Node.js server can run.\nMore server-side load. Rendering a full app in Node.js is going to be more CPU-intensive than just serving static files, so if you expect high traffic, be prepared for corresponding server load and wisely employ caching strategies.\nBefore using SSR for your app, the first question you should ask is whether you actually need it. It mostly depends on how important time-to-content is for your app. For example, if you are building an internal dashboard where an extra few hundred milliseconds on initial load doesn't matter that much, SSR would be an overkill. However, in cases where time-to-content is absolutely critical, SSR can help you achieve the best possible initial load performance.\nSSR vs. SSG\nStatic Site Generation (SSG), also referred to as pre-rendering, is another popular technique for building fast websites. If the data needed to server-render a page is the same for every user, then instead of rendering the page every time a request comes in, we can render it only once, ahead of time, during the build process. Pre-rendered pages are generated and served as static HTML files.\nSSG retains the same performance characteristics of SSR apps: it provides great time-to-content performance. At the same time, it is cheaper and easier to deploy than SSR apps because the output is static HTML and assets. The keyword here is static: SSG can only be applied to pages providing static data, i.e. data that is known at build time and can not change between requests. Every time the data changes, a new deployment is needed.\nIf you're only investigating SSR to improve the SEO of a handful of marketing pages (e.g. /\n, /about\n, /contact\n, etc.), then you probably want SSG instead of SSR. SSG is also great for content-based websites such as documentation sites or blogs. In fact, this website you are reading right now is statically generated using VitePress, a Vue-powered static site generator.\nBasic Tutorial\nRendering an App\nLet's take a look at the most bare-bones example of Vue SSR in action.\n- Create a new directory and\ncd\ninto it - Run\nnpm init -y\n- Add\n\"type\": \"module\"\ninpackage.json\nso that Node.js runs in ES modules mode. - Run\nnpm install vue\n- Create an\nexample.js\nfile:\njs\n// this runs in Node.js on the server.\nimport { createSSRApp } from 'vue'\n// Vue's server-rendering API is exposed under `vue/server-renderer`.\nimport { renderToString } from 'vue/server-renderer'\nconst app = createSSRApp({\ndata: () => ({ count: 1 }),\ntemplate: `<button @click=\"count++\">{{ count }}</button>`\n})\nrenderToString(app).then((html) => {\nconsole.log(html)\n})\nThen run:\nsh\n> node example.js\nIt should print the following to the command line:\n<button>1</button>\nrenderToString()\ntakes a Vue app instance and returns a Promise that resolves to the rendered HTML of the app. It is also possible to stream rendering using the Node.js Stream API or Web Streams API. Check out the SSR API Reference for full details.\nWe can then move the Vue SSR code into a server request handler, which wraps the application markup with the full page HTML. We will be using express\nfor the next steps:\n- Run\nnpm install express\n- Create the following\nserver.js\nfile:\njs\nimport express from 'express'\nimport { createSSRApp } from 'vue'\nimport { renderToString } from 'vue/server-renderer'\nconst server = express()\nserver.get('/', (req, res) => {\nconst app = createSSRApp({\ndata: () => ({ count: 1 }),\ntemplate: `<button @click=\"count++\">{{ count }}</button>`\n})\nrenderToString(app).then((html) => {\nres.send(`\n<!DOCTYPE html>\n<html>\n<head>\n<title>Vue SSR Example</title>\n</head>\n<body>\n<div id=\"app\">${html}</div>\n</body>\n</html>\n`)\n})\n})\nserver.listen(3000, () => {\nconsole.log('ready')\n})\nFinally, run node server.js\nand visit http://localhost:3000\n. You should see the page working with the button.\nClient Hydration\nIf you click the button, you'll notice the number doesn't change. The HTML is completely static on the client since we are not loading Vue in the browser.\nTo make the client-side app interactive, Vue needs to perform the hydration step. During hydration, it creates the same Vue application that was run on the server, matches each component to the DOM nodes it should control, and attaches DOM event listeners.\nTo mount an app in hydration mode, we need to use createSSRApp()\ninstead of createApp()\n:\njs\n// this runs in the browser.\nimport { createSSRApp } from 'vue'\nconst app = createSSRApp({\n// ...same app as on server\n})\n// mounting an SSR app on the client assumes\n// the HTML was pre-rendered and will perform\n// hydration instead of mounting new DOM nodes.\napp.mount('#app')\nCode Structure\nNotice how we need to reuse the same app implementation as on the server. This is where we need to start thinking about code structure in an SSR app - how do we share the same application code between the server and the client?\nHere we will demonstrate the most bare-bones setup. First, let's split the app creation logic into a dedicated file, app.js\n:\njs\n// app.js (shared between server and client)\nimport { createSSRApp } from 'vue'\nexport function createApp() {\nreturn createSSRApp({\ndata: () => ({ count: 1 }),\ntemplate: `<button @click=\"count++\">{{ count }}</button>`\n})\n}\nThis file and its dependencies are shared between the server and the client - we call them universal code. There are a number of things you need to pay attention to when writing universal code, as we will discuss below.\nOur client entry imports the universal code, creates the app, and performs the mount:\njs\n// client.js\nimport { createApp } from './app.js'\ncreateApp().mount('#app')\nAnd the server uses the same app creation logic in the request handler:\njs\n// server.js (irrelevant code omitted)\nimport { createApp } from './app.js'\nserver.get('/', (req, res) => {\nconst app = createApp()\nrenderToString(app).then(html => {\n// ...\n})\n})\nIn addition, in order to load the client files in the browser, we also need to:\n- Serve client files by adding\nserver.use(express.static('.'))\ninserver.js\n. - Load the client entry by adding\n<script type=\"module\" src=\"/client.js\"></script>\nto the HTML shell. - Support usage like\nimport * from 'vue'\nin the browser by adding an Import Map to the HTML shell.\nTry the completed example on StackBlitz. The button is now interactive!\nHigher Level Solutions\nMoving from the example to a production-ready SSR app involves a lot more. We will need to:\nSupport Vue SFCs and other build step requirements. In fact, we will need to coordinate two builds for the same app: one for the client, and one for the server.\nTIP\nVue components are compiled differently when used for SSR - templates are compiled into string concatenations instead of Virtual DOM render functions for more efficient rendering performance.\nIn the server request handler, render the HTML with the correct client-side asset links and optimal resource hints. We may also need to switch between SSR and SSG mode, or even mix both in the same app.\nManage routing, data fetching, and state management stores in a universal manner.\nA complete implementation would be quite complex and depends on the build toolchain you have chosen to work with. Therefore, we highly recommend going with a higher-level, opinionated solution that abstracts away the complexity for you. Below we will introduce a few recommended SSR solutions in the Vue ecosystem.\nNuxt\nNuxt is a higher-level framework built on top of the Vue ecosystem which provides a streamlined development experience for writing universal Vue applications. Better yet, you can also use it as a static site generator! We highly recommend giving it a try.\nQuasar\nQuasar is a complete Vue-based solution that allows you to target SPA, SSR, PWA, mobile app, desktop app, and browser extension all using one codebase. It not only handles the build setup, but also provides a full collection of Material Design compliant UI components.\nVite SSR\nVite provides built-in support for Vue server-side rendering, but it is intentionally low-level. If you wish to go directly with Vite, check out vite-plugin-ssr, a community plugin that abstracts away many challenging details for you.\nYou can also find an example Vue + Vite SSR project using manual setup here, which can serve as a base to build upon. Note this is only recommended if you are experienced with SSR / build tools and really want to have complete control over the higher-level architecture.\nWriting SSR-friendly Code\nRegardless of your build setup or higher-level framework choice, there are some principles that apply in all Vue SSR applications.\nReactivity on the Server\nDuring SSR, each request URL maps to a desired state of our application. There is no user interaction and no DOM updates, so reactivity is unnecessary on the server. By default, reactivity is disabled during SSR for better performance.\nComponent Lifecycle Hooks\nSince there are no dynamic updates, lifecycle hooks such as onMounted\nor onUpdated\nwill NOT be called during SSR and will only be executed on the client.\nYou should avoid code that produces side effects that need cleanup in setup()\nor the root scope of <script setup>\n. An example of such side effects is setting up timers with setInterval\n. In client-side only code we may setup a timer and then tear it down in onBeforeUnmount\nor onUnmounted\n. However, because the unmount hooks will never be called during SSR, the timers will stay around forever. To avoid this, move your side-effect code into onMounted\ninstead.\nAccess to Platform-Specific APIs\nUniversal code cannot assume access to platform-specific APIs, so if your code directly uses browser-only globals like window\nor document\n, they will throw errors when executed in Node.js, and vice-versa.\nFor tasks that are shared between server and client but with different platform APIs, it's recommended to wrap the platform-specific implementations inside a universal API, or use libraries that do this for you. For example, you can use node-fetch\nto use the same fetch API on both server and client.\nFor browser-only APIs, the common approach is to lazily access them inside client-only lifecycle hooks such as onMounted\n.\nNote that if a third-party library is not written with universal usage in mind, it could be tricky to integrate it into a server-rendered app. You might be able to get it working by mocking some of the globals, but it would be hacky and may interfere with the environment detection code of other libraries.\nCross-Request State Pollution\nIn the State Management chapter, we introduced a simple state management pattern using Reactivity APIs. In an SSR context, this pattern requires some additional adjustments.\nThe pattern declares shared state in a JavaScript module's root scope. This makes them singletons - i.e. there is only one instance of the reactive object throughout the entire lifecycle of our application. This works as expected in a pure client-side Vue application, since the modules in our application are initialized fresh for each browser page visit.\nHowever, in an SSR context, the application modules are typically initialized only once on the server, when the server boots up. The same module instances will be reused across multiple server requests, and so will our singleton state objects. If we mutate the shared singleton state with data specific to one user, it can be accidentally leaked to a request from another user. We call this cross-request state pollution.\nWe can technically re-initialize all the JavaScript modules on each request, just like we do in browsers. However, initializing JavaScript modules can be costly, so this would significantly affect server performance.\nThe recommended solution is to create a new instance of the entire application - including the router and global stores - on each request. Then, instead of directly importing it in our components, we provide the shared state using app-level provide and inject it in components that need it:\njs\n// app.js (shared between server and client)\nimport { createSSRApp } from 'vue'\nimport { createStore } from './store.js'\n// called on each request\nexport function createApp() {\nconst app = createSSRApp(/* ... */)\n// create new instance of store per request\nconst store = createStore(/* ... */)\n// provide store at the app level\napp.provide('store', store)\n// also expose store for hydration purposes\nreturn { app, store }\n}\nState Management libraries like Pinia are designed with this in mind. Consult Pinia's SSR guide for more details.\nHydration Mismatch\nIf the DOM structure of the pre-rendered HTML does not match the expected output of the client-side app, there will be a hydration mismatch error. Hydration mismatch is most commonly introduced by the following causes:\nThe template contains invalid HTML nesting structure, and the rendered HTML got \"corrected\" by the browser's native HTML parsing behavior. For example, a common gotcha is that\n<div>\ncannot be placed inside<p>\n:html<p><div>hi</div></p>\nIf we produce this in our server-rendered HTML, the browser will terminate the first\n<p>\nwhen<div>\nis encountered and parse it into the following DOM structure:html<p></p> <div>hi</div> <p></p>\nThe data used during render contains randomly generated values. Since the same application will run twice - once on the server, and once on the client - the random values are not guaranteed to be the same between the two runs. There are two ways to avoid random-value-induced mismatches:\nUse\nv-if\n+onMounted\nto render the part that depends on random values only on the client. Your framework may also have built-in features to make this easier, for example the<ClientOnly>\ncomponent in VitePress.Use a random number generator library that supports generating with seeds, and guarantee the server run and the client run are using the same seed (e.g. by including the seed in serialized state and retrieving it on the client).\nThe server and the client are in different time zones. Sometimes, we may want to convert a timestamp into the user's local time. However, the timezone during the server run and the timezone during the client run are not always the same, and we may not reliably know the user's timezone during the server run. In such cases, the local time conversion should also be performed as a client-only operation.\nWhen Vue encounters a hydration mismatch, it will attempt to automatically recover and adjust the pre-rendered DOM to match the client-side state. This will lead to some rendering performance loss due to incorrect nodes being discarded and new nodes being mounted, but in most cases, the app should continue to work as expected. That said, it is still best to eliminate hydration mismatches during development.\nCustom Directives\nSince most custom directives involve direct DOM manipulation, they are ignored during SSR. However, if you want to specify how a custom directive should be rendered (i.e. what attributes it should add to the rendered element), you can use the getSSRProps\ndirective hook:\njs\nconst myDirective = {\nmounted(el, binding) {\n// client-side implementation:\n// directly update the DOM\nel.id = binding.value\n},\ngetSSRProps(binding) {\n// server-side implementation:\n// return the props to be rendered.\n// getSSRProps only receives the directive binding.\nreturn {\nid: binding.value\n}\n}\n}\nTeleports\nTeleports require special handling during SSR. If the rendered app contains Teleports, the teleported content will not be part of the rendered string. An easier solution is to conditionally render the Teleport on mount.\nIf you do need to hydrate teleported content, they are exposed under the teleports\nproperty of the ssr context object:\njs\nconst ctx = {}\nconst html = await renderToString(app, ctx)\nconsole.log(ctx.teleports) // { '#teleported': 'teleported content' }\nYou need to inject the teleport markup into the correct location in your final page HTML similar to how you need to inject the main app markup.\nTIP\nAvoid targeting body\nwhen using Teleports and SSR together - usually, <body>\nwill contain other server-rendered content which makes it impossible for Teleports to determine the correct starting location for hydration.\nInstead, prefer a dedicated container, e.g. <div id=\"teleported\"></div>\nwhich contains only teleported content.",
    "metadata": {
      "source": "https://vuejs.org/guide/scaling-up/ssr",
      "title": "Server-Side Rendering (SSR) | Vue.js"
    }
  },
  {
    "page_content": "Quick Start\nTry Vue Online\nTo quickly get a taste of Vue, you can try it directly in our Playground.\nIf you prefer a plain HTML setup without any build steps, you can use this JSFiddle as your starting point.\nIf you are already familiar with Node.js and the concept of build tools, you can also try a complete build setup right within your browser on StackBlitz.\nCreating a Vue Application\nPrerequisites\n- Familiarity with the command line\n- Install Node.js version 18.3 or higher\nIn this section we will introduce how to scaffold a Vue Single Page Application on your local machine. The created project will be using a build setup based on Vite and allow us to use Vue Single-File Components (SFCs).\nMake sure you have an up-to-date version of Node.js installed and your current working directory is the one where you intend to create a project. Run the following command in your command line (without the $\nsign):\nnpm\npnpm\nyarn\nbun\nsh\n$ npm create vue@latest\nThis command will install and execute create-vue, the official Vue project scaffolding tool. You will be presented with prompts for several optional features such as TypeScript and testing support:\n✔ Project name: … <your-project-name>\n✔ Add TypeScript? … No / Yes\n✔ Add JSX Support? … No / Yes\n✔ Add Vue Router for Single Page Application development? … No / Yes\n✔ Add Pinia for state management? … No / Yes\n✔ Add Vitest for Unit testing? … No / Yes\n✔ Add an End-to-End Testing Solution? … No / Cypress / Nightwatch / Playwright\n✔ Add ESLint for code quality? … No / Yes\n✔ Add Prettier for code formatting? … No / Yes\n✔ Add Vue DevTools 7 extension for debugging? (experimental) … No / Yes\nScaffolding project in ./<your-project-name>...\nDone.\nIf you are unsure about an option, simply choose No\nby hitting enter for now. Once the project is created, follow the instructions to install dependencies and start the dev server:\nnpm\npnpm\nyarn\nbun\nsh\n$ cd <your-project-name>\n$ npm install\n$ npm run dev\nYou should now have your first Vue project running! Note that the example components in the generated project are written using the Composition API and <script setup>\n, rather than the Options API. Here are some additional tips:\n- The recommended IDE setup is Visual Studio Code + Vue - Official extension. If you use other editors, check out the IDE support section.\n- More tooling details, including integration with backend frameworks, are discussed in the Tooling Guide.\n- To learn more about the underlying build tool Vite, check out the Vite docs.\n- If you choose to use TypeScript, check out the TypeScript Usage Guide.\nWhen you are ready to ship your app to production, run the following:\nnpm\npnpm\nyarn\nbun\nsh\n$ npm run build\nThis will create a production-ready build of your app in the project's ./dist\ndirectory. Check out the Production Deployment Guide to learn more about shipping your app to production.\nUsing Vue from CDN\nYou can use Vue directly from a CDN via a script tag:\nhtml\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\nHere we are using unpkg, but you can also use any CDN that serves npm packages, for example jsdelivr or cdnjs. Of course, you can also download this file and serve it yourself.\nWhen using Vue from a CDN, there is no \"build step\" involved. This makes the setup a lot simpler, and is suitable for enhancing static HTML or integrating with a backend framework. However, you won't be able to use the Single-File Component (SFC) syntax.\nUsing the Global Build\nThe above link loads the global build of Vue, where all top-level APIs are exposed as properties on the global Vue\nobject. Here is a full example using the global build:\nhtml\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<div id=\"app\">{{ message }}</div>\n<script>\nconst { createApp, ref } = Vue\ncreateApp({\nsetup() {\nconst message = ref('Hello vue!')\nreturn {\nmessage\n}\n}\n}).mount('#app')\n</script>\nTIP\nMany of the examples for Composition API throughout the guide will be using the <script setup>\nsyntax, which requires build tools. If you intend to use Composition API without a build step, consult the usage of the setup()\noption.\nUsing the ES Module Build\nThroughout the rest of the documentation, we will be primarily using ES modules syntax. Most modern browsers now support ES modules natively, so we can use Vue from a CDN via native ES modules like this:\nhtml\n<div id=\"app\">{{ message }}</div>\n<script type=\"module\">\nimport { createApp, ref } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js'\ncreateApp({\nsetup() {\nconst message = ref('Hello Vue!')\nreturn {\nmessage\n}\n}\n}).mount('#app')\n</script>\nNotice that we are using <script type=\"module\">\n, and the imported CDN URL is pointing to the ES modules build of Vue instead.\nEnabling Import maps\nIn the above example, we are importing from the full CDN URL, but in the rest of the documentation you will see code like this:\njs\nimport { createApp } from 'vue'\nWe can teach the browser where to locate the vue\nimport by using Import Maps:\nhtml\n<script type=\"importmap\">\n{\n\"imports\": {\n\"vue\": \"https://unpkg.com/vue@3/dist/vue.esm-browser.js\"\n}\n}\n</script>\n<div id=\"app\">{{ message }}</div>\n<script type=\"module\">\nimport { createApp, ref } from 'vue'\ncreateApp({\nsetup() {\nconst message = ref('Hello Vue!')\nreturn {\nmessage\n}\n}\n}).mount('#app')\n</script>\nYou can also add entries for other dependencies to the import map - but make sure they point to the ES modules version of the library you intend to use.\nImport Maps Browser Support\nImport Maps is a relatively new browser feature. Make sure to use a browser within its support range. In particular, it is only supported in Safari 16.4+.\nNotes on Production Use\nThe examples so far are using the development build of Vue - if you intend to use Vue from a CDN in production, make sure to check out the Production Deployment Guide.\nWhile it is possible to use Vue without a build system, an alternative approach to consider is using vuejs/petite-vue\nthat could better suit the context where jquery/jquery\n(in the past) or alpinejs/alpine\n(in the present) might be used instead.\nSplitting Up the Modules\nAs we dive deeper into the guide, we may need to split our code into separate JavaScript files so that they are easier to manage. For example:\nhtml\n<!-- index.html -->\n<div id=\"app\"></div>\n<script type=\"module\">\nimport { createApp } from 'vue'\nimport MyComponent from './my-component.js'\ncreateApp(MyComponent).mount('#app')\n</script>\njs\n// my-component.js\nimport { ref } from 'vue'\nexport default {\nsetup() {\nconst count = ref(0)\nreturn { count }\n},\ntemplate: `<div>Count is: {{ count }}</div>`\n}\nIf you directly open the above index.html\nin your browser, you will find that it throws an error because ES modules cannot work over the file://\nprotocol, which is the protocol the browser uses when you open a local file.\nDue to security reasons, ES modules can only work over the http://\nprotocol, which is what the browsers use when opening pages on the web. In order for ES modules to work on our local machine, we need to serve the index.html\nover the http://\nprotocol, with a local HTTP server.\nTo start a local HTTP server, first make sure you have Node.js installed, then run npx serve\nfrom the command line in the same directory where your HTML file is. You can also use any other HTTP server that can serve static files with the correct MIME types.\nYou may have noticed that the imported component's template is inlined as a JavaScript string. If you are using VS Code, you can install the es6-string-html extension and prefix the strings with a /*html*/\ncomment to get syntax highlighting for them.\nNext Steps\nIf you skipped the Introduction, we strongly recommend reading it before moving on to the rest of the documentation.",
    "metadata": {
      "source": "https://vuejs.org/guide/quick-start",
      "title": "Quick Start | Vue.js"
    }
  },
  {
    "page_content": "Introduction\nYou are reading the documentation for Vue 3!\n- Vue 2 support has ended on Dec 31, 2023. Learn more about Vue 2 EOL.\n- Upgrading from Vue 2? Check out the Migration Guide.\nWhat is Vue?\nVue (pronounced /vjuː/, like view) is a JavaScript framework for building user interfaces. It builds on top of standard HTML, CSS, and JavaScript and provides a declarative, component-based programming model that helps you efficiently develop user interfaces of any complexity.\nHere is a minimal example:\njs\nimport { createApp, ref } from 'vue'\ncreateApp({\nsetup() {\nreturn {\ncount: ref(0)\n}\n}\n}).mount('#app')\ntemplate\n<div id=\"app\">\n<button @click=\"count++\">\nCount is: {{ count }}\n</button>\n</div>\nResult\nThe above example demonstrates the two core features of Vue:\nDeclarative Rendering: Vue extends standard HTML with a template syntax that allows us to declaratively describe HTML output based on JavaScript state.\nReactivity: Vue automatically tracks JavaScript state changes and efficiently updates the DOM when changes happen.\nYou may already have questions - don't worry. We will cover every little detail in the rest of the documentation. For now, please read along so you can have a high-level understanding of what Vue offers.\nPrerequisites\nThe rest of the documentation assumes basic familiarity with HTML, CSS, and JavaScript. If you are totally new to frontend development, it might not be the best idea to jump right into a framework as your first step - grasp the basics and then come back! You can check your knowledge level with these overviews for JavaScript, HTML and CSS if needed. Prior experience with other frameworks helps, but is not required.\nThe Progressive Framework\nVue is a framework and ecosystem that covers most of the common features needed in frontend development. But the web is extremely diverse - the things we build on the web may vary drastically in form and scale. With that in mind, Vue is designed to be flexible and incrementally adoptable. Depending on your use case, Vue can be used in different ways:\n- Enhancing static HTML without a build step\n- Embedding as Web Components on any page\n- Single-Page Application (SPA)\n- Fullstack / Server-Side Rendering (SSR)\n- Jamstack / Static Site Generation (SSG)\n- Targeting desktop, mobile, WebGL, and even the terminal\nIf you find these concepts intimidating, don't worry! The tutorial and guide only require basic HTML and JavaScript knowledge, and you should be able to follow along without being an expert in any of these.\nIf you are an experienced developer interested in how to best integrate Vue into your stack, or you are curious about what these terms mean, we discuss them in more detail in Ways of Using Vue.\nDespite the flexibility, the core knowledge about how Vue works is shared across all these use cases. Even if you are just a beginner now, the knowledge gained along the way will stay useful as you grow to tackle more ambitious goals in the future. If you are a veteran, you can pick the optimal way to leverage Vue based on the problems you are trying to solve, while retaining the same productivity. This is why we call Vue \"The Progressive Framework\": it's a framework that can grow with you and adapt to your needs.\nSingle-File Components\nIn most build-tool-enabled Vue projects, we author Vue components using an HTML-like file format called Single-File Component (also known as *.vue\nfiles, abbreviated as SFC). A Vue SFC, as the name suggests, encapsulates the component's logic (JavaScript), template (HTML), and styles (CSS) in a single file. Here's the previous example, written in SFC format:\nvue\n<script setup>\nimport { ref } from 'vue'\nconst count = ref(0)\n</script>\n<template>\n<button @click=\"count++\">Count is: {{ count }}</button>\n</template>\n<style scoped>\nbutton {\nfont-weight: bold;\n}\n</style>\nSFC is a defining feature of Vue and is the recommended way to author Vue components if your use case warrants a build setup. You can learn more about the how and why of SFC in its dedicated section - but for now, just know that Vue will handle all the build tools setup for you.\nAPI Styles\nVue components can be authored in two different API styles: Options API and Composition API.\nOptions API\nWith Options API, we define a component's logic using an object of options such as data\n, methods\n, and mounted\n. Properties defined by options are exposed on this\ninside functions, which points to the component instance:\nvue\n<script>\nexport default {\n// Properties returned from data() become reactive state\n// and will be exposed on `this`.\ndata() {\nreturn {\ncount: 0\n}\n},\n// Methods are functions that mutate state and trigger updates.\n// They can be bound as event handlers in templates.\nmethods: {\nincrement() {\nthis.count++\n}\n},\n// Lifecycle hooks are called at different stages\n// of a component's lifecycle.\n// This function will be called when the component is mounted.\nmounted() {\nconsole.log(`The initial count is ${this.count}.`)\n}\n}\n</script>\n<template>\n<button @click=\"increment\">Count is: {{ count }}</button>\n</template>\nComposition API\nWith Composition API, we define a component's logic using imported API functions. In SFCs, Composition API is typically used with <script setup>\n. The setup\nattribute is a hint that makes Vue perform compile-time transforms that allow us to use Composition API with less boilerplate. For example, imports and top-level variables / functions declared in <script setup>\nare directly usable in the template.\nHere is the same component, with the exact same template, but using Composition API and <script setup>\ninstead:\nvue\n<script setup>\nimport { ref, onMounted } from 'vue'\n// reactive state\nconst count = ref(0)\n// functions that mutate state and trigger updates\nfunction increment() {\ncount.value++\n}\n// lifecycle hooks\nonMounted(() => {\nconsole.log(`The initial count is ${count.value}.`)\n})\n</script>\n<template>\n<button @click=\"increment\">Count is: {{ count }}</button>\n</template>\nWhich to Choose?\nBoth API styles are fully capable of covering common use cases. They are different interfaces powered by the exact same underlying system. In fact, the Options API is implemented on top of the Composition API! The fundamental concepts and knowledge about Vue are shared across the two styles.\nThe Options API is centered around the concept of a \"component instance\" (this\nas seen in the example), which typically aligns better with a class-based mental model for users coming from OOP language backgrounds. It is also more beginner-friendly by abstracting away the reactivity details and enforcing code organization via option groups.\nThe Composition API is centered around declaring reactive state variables directly in a function scope and composing state from multiple functions together to handle complexity. It is more free-form and requires an understanding of how reactivity works in Vue to be used effectively. In return, its flexibility enables more powerful patterns for organizing and reusing logic.\nYou can learn more about the comparison between the two styles and the potential benefits of Composition API in the Composition API FAQ.\nIf you are new to Vue, here's our general recommendation:\nFor learning purposes, go with the style that looks easier to understand to you. Again, most of the core concepts are shared between the two styles. You can always pick up the other style later.\nFor production use:\nGo with Options API if you are not using build tools, or plan to use Vue primarily in low-complexity scenarios, e.g. progressive enhancement.\nGo with Composition API + Single-File Components if you plan to build full applications with Vue.\nYou don't have to commit to only one style during the learning phase. The rest of the documentation will provide code samples in both styles where applicable, and you can toggle between them at any time using the API Preference switches at the top of the left sidebar.\nStill Got Questions?\nCheck out our FAQ.\nPick Your Learning Path\nDifferent developers have different learning styles. Feel free to pick a learning path that suits your preference - although we do recommend going over all of the content, if possible!",
    "metadata": {
      "source": "https://vuejs.org/guide/introduction",
      "title": "Introduction | Vue.js"
    }
  },
  {
    "page_content": "Accessibility\nWeb accessibility (also known as a11y) refers to the practice of creating websites that can be used by anyone — be that a person with a disability, a slow connection, outdated or broken hardware or simply someone in an unfavorable environment. For example, adding subtitles to a video would help both your deaf and hard-of-hearing users and your users who are in a loud environment and can't hear their phone. Similarly, making sure your text isn't too low contrast will help both your low-vision users and your users who are trying to use their phone in bright sunlight.\nReady to start but aren’t sure where?\nCheckout the Planning and managing web accessibility guide provided by World Wide Web Consortium (W3C)\nSkip link\nYou should add a link at the top of each page that goes directly to the main content area so users can skip content that is repeated on multiple Web pages.\nTypically this is done on the top of App.vue\nas it will be the first focusable element on all your pages:\ntemplate\n<ul class=\"skip-links\">\n<li>\n<a href=\"#main\" ref=\"skipLink\" class=\"skip-link\">Skip to main content</a>\n</li>\n</ul>\nTo hide the link unless it is focused, you can add the following style:\ncss\n.skip-link {\nwhite-space: nowrap;\nmargin: 1em auto;\ntop: 0;\nposition: fixed;\nleft: 50%;\nmargin-left: -72px;\nopacity: 0;\n}\n.skip-link:focus {\nopacity: 1;\nbackground-color: white;\npadding: 0.5em;\nborder: 1px solid black;\n}\nOnce a user changes route, bring focus back to the skip link. This can be achieved by calling focus on the skip link's template ref (assuming usage of vue-router\n):\nvue\n<script setup>\nimport { ref, watch } from 'vue'\nimport { useRoute } from 'vue-router'\nconst route = useRoute()\nconst skipLink = ref()\nwatch(\n() => route.path,\n() => {\nskipLink.value.focus()\n}\n)\n</script>\nRead documentation on skip link to main content\nContent Structure\nOne of the most important pieces of accessibility is making sure that design can support accessible implementation. Design should consider not only color contrast, font selection, text sizing, and language, but also how the content is structured in the application.\nHeadings\nUsers can navigate an application through headings. Having descriptive headings for every section of your application makes it easier for users to predict the content of each section. When it comes to headings, there are a couple of recommended accessibility practices:\n- Nest headings in their ranking order:\n<h1>\n-<h6>\n- Don’t skip headings within a section\n- Use actual heading tags instead of styling text to give the visual appearance of headings\ntemplate\n<main role=\"main\" aria-labelledby=\"main-title\">\n<h1 id=\"main-title\">Main title</h1>\n<section aria-labelledby=\"section-title-1\">\n<h2 id=\"section-title-1\"> Section Title </h2>\n<h3>Section Subtitle</h3>\n<!-- Content -->\n</section>\n<section aria-labelledby=\"section-title-2\">\n<h2 id=\"section-title-2\"> Section Title </h2>\n<h3>Section Subtitle</h3>\n<!-- Content -->\n<h3>Section Subtitle</h3>\n<!-- Content -->\n</section>\n</main>\nLandmarks\nLandmarks provide programmatic access to sections within an application. Users who rely on assistive technology can navigate to each section of the application and skip over content. You can use ARIA roles to help you achieve this.\nHTML | ARIA Role | Landmark Purpose |\n---|---|---|\nheader | role=\"banner\" | Prime heading: title of the page |\nnav | role=\"navigation\" | Collection of links suitable for use when navigating the document or related documents |\nmain | role=\"main\" | The main or central content of the document. |\nfooter | role=\"contentinfo\" | Information about the parent document: footnotes/copyrights/links to privacy statement |\naside | role=\"complementary\" | Supports the main content, yet is separated and meaningful on its own content |\nsearch | role=\"search\" | This section contains the search functionality for the application |\nform | role=\"form\" | Collection of form-associated elements |\nsection | role=\"region\" | Content that is relevant and that users will likely want to navigate to. Label must be provided for this element |\nTip:\nIt is recommended to use landmark HTML elements with redundant landmark role attributes in order to maximize compatibility with legacy browsers that don’t support HTML5 semantic elements.\nSemantic Forms\nWhen creating a form, you can use the following elements: <form>\n, <label>\n, <input>\n, <textarea>\n, and <button>\nLabels are typically placed on top or to the left of the form fields:\ntemplate\n<form action=\"/dataCollectionLocation\" method=\"post\" autocomplete=\"on\">\n<div v-for=\"item in formItems\" :key=\"item.id\" class=\"form-item\">\n<label :for=\"item.id\">{{ item.label }}: </label>\n<input\n:type=\"item.type\"\n:id=\"item.id\"\n:name=\"item.id\"\nv-model=\"item.value\"\n/>\n</div>\n<button type=\"submit\">Submit</button>\n</form>\nNotice how you can include autocomplete='on'\non the form element and it will apply to all inputs in your form. You can also set different values for autocomplete attribute for each input.\nLabels\nProvide labels to describe the purpose of all form control; linking for\nand id\n:\ntemplate\n<label for=\"name\">Name: </label>\n<input type=\"text\" name=\"name\" id=\"name\" v-model=\"name\" />\nIf you inspect this element in your Chrome DevTools and open the Accessibility tab inside the Elements tab, you will see how the input gets its name from the label:\nWarning:\nThough you might have seen labels wrapping the input fields like this:\ntemplate\n<label>\nName:\n<input type=\"text\" name=\"name\" id=\"name\" v-model=\"name\" />\n</label>\nExplicitly setting the labels with a matching id is better supported by assistive technology.\naria-label\nYou can also give the input an accessible name with aria-label\n.\ntemplate\n<label for=\"name\">Name: </label>\n<input\ntype=\"text\"\nname=\"name\"\nid=\"name\"\nv-model=\"name\"\n:aria-label=\"nameLabel\"\n/>\nFeel free to inspect this element in Chrome DevTools to see how the accessible name has changed:\naria-labelledby\nUsing aria-labelledby\nis similar to aria-label\nexcept it is used if the label text is visible on screen. It is paired to other elements by their id\nand you can link multiple id\ns:\ntemplate\n<form\nclass=\"demo\"\naction=\"/dataCollectionLocation\"\nmethod=\"post\"\nautocomplete=\"on\"\n>\n<h1 id=\"billing\">Billing</h1>\n<div class=\"form-item\">\n<label for=\"name\">Name: </label>\n<input\ntype=\"text\"\nname=\"name\"\nid=\"name\"\nv-model=\"name\"\naria-labelledby=\"billing name\"\n/>\n</div>\n<button type=\"submit\">Submit</button>\n</form>\naria-describedby\naria-describedby is used the same way as aria-labelledby\nexcept provides a description with additional information that the user might need. This can be used to describe the criteria for any input:\ntemplate\n<form\nclass=\"demo\"\naction=\"/dataCollectionLocation\"\nmethod=\"post\"\nautocomplete=\"on\"\n>\n<h1 id=\"billing\">Billing</h1>\n<div class=\"form-item\">\n<label for=\"name\">Full Name: </label>\n<input\ntype=\"text\"\nname=\"name\"\nid=\"name\"\nv-model=\"name\"\naria-labelledby=\"billing name\"\naria-describedby=\"nameDescription\"\n/>\n<p id=\"nameDescription\">Please provide first and last name.</p>\n</div>\n<button type=\"submit\">Submit</button>\n</form>\nYou can see the description by inspecting Chrome DevTools:\nPlaceholder\nAvoid using placeholders as they can confuse many users.\nOne of the issues with placeholders is that they don't meet the color contrast criteria by default; fixing the color contrast makes the placeholder look like pre-populated data in the input fields. Looking at the following example, you can see that the Last Name placeholder which meets the color contrast criteria looks like pre-populated data:\ntemplate\n<form\nclass=\"demo\"\naction=\"/dataCollectionLocation\"\nmethod=\"post\"\nautocomplete=\"on\"\n>\n<div v-for=\"item in formItems\" :key=\"item.id\" class=\"form-item\">\n<label :for=\"item.id\">{{ item.label }}: </label>\n<input\ntype=\"text\"\n:id=\"item.id\"\n:name=\"item.id\"\nv-model=\"item.value\"\n:placeholder=\"item.placeholder\"\n/>\n</div>\n<button type=\"submit\">Submit</button>\n</form>\ncss\n/* https://www.w3schools.com/howto/howto_css_placeholder.asp */\n#lastName::placeholder {\n/* Chrome, Firefox, Opera, Safari 10.1+ */\ncolor: black;\nopacity: 1; /* Firefox */\n}\n#lastName:-ms-input-placeholder {\n/* Internet Explorer 10-11 */\ncolor: black;\n}\n#lastName::-ms-input-placeholder {\n/* Microsoft Edge */\ncolor: black;\n}\nIt is best to provide all the information the user needs to fill out forms outside any inputs.\nInstructions\nWhen adding instructions for your input fields, make sure to link it correctly to the input. You can provide additional instructions and bind multiple ids inside an aria-labelledby\n. This allows for more flexible design.\ntemplate\n<fieldset>\n<legend>Using aria-labelledby</legend>\n<label id=\"date-label\" for=\"date\">Current Date: </label>\n<input\ntype=\"date\"\nname=\"date\"\nid=\"date\"\naria-labelledby=\"date-label date-instructions\"\n/>\n<p id=\"date-instructions\">MM/DD/YYYY</p>\n</fieldset>\nAlternatively, you can attach the instructions to the input with aria-describedby\n:\ntemplate\n<fieldset>\n<legend>Using aria-describedby</legend>\n<label id=\"dob\" for=\"dob\">Date of Birth: </label>\n<input type=\"date\" name=\"dob\" id=\"dob\" aria-describedby=\"dob-instructions\" />\n<p id=\"dob-instructions\">MM/DD/YYYY</p>\n</fieldset>\nHiding Content\nUsually it is not recommended to visually hide labels, even if the input has an accessible name. However, if the functionality of the input can be understood with surrounding content, then we can hide the visual label.\nLet's look at this search field:\ntemplate\n<form role=\"search\">\n<label for=\"search\" class=\"hidden-visually\">Search: </label>\n<input type=\"text\" name=\"search\" id=\"search\" v-model=\"search\" />\n<button type=\"submit\">Search</button>\n</form>\nWe can do this because the search button will help visual users identify the purpose of the input field.\nWe can use CSS to visually hide elements but keep them available for assistive technology:\ncss\n.hidden-visually {\nposition: absolute;\noverflow: hidden;\nwhite-space: nowrap;\nmargin: 0;\npadding: 0;\nheight: 1px;\nwidth: 1px;\nclip: rect(0 0 0 0);\nclip-path: inset(100%);\n}\naria-hidden=\"true\"\nAdding aria-hidden=\"true\"\nwill hide the element from assistive technology but leave it visually available for other users. Do not use it on focusable elements, purely on decorative, duplicated or offscreen content.\ntemplate\n<p>This is not hidden from screen readers.</p>\n<p aria-hidden=\"true\">This is hidden from screen readers.</p>\nButtons\nWhen using buttons inside a form, you must set the type to prevent submitting the form. You can also use an input to create buttons:\ntemplate\n<form action=\"/dataCollectionLocation\" method=\"post\" autocomplete=\"on\">\n<!-- Buttons -->\n<button type=\"button\">Cancel</button>\n<button type=\"submit\">Submit</button>\n<!-- Input buttons -->\n<input type=\"button\" value=\"Cancel\" />\n<input type=\"submit\" value=\"Submit\" />\n</form>\nFunctional Images\nYou can use this technique to create functional images.\nInput fields\n- These images will act as a submit type button on forms\ntemplate<form role=\"search\"> <label for=\"search\" class=\"hidden-visually\">Search: </label> <input type=\"text\" name=\"search\" id=\"search\" v-model=\"search\" /> <input type=\"image\" class=\"btnImg\" src=\"https://img.icons8.com/search\" alt=\"Search\" /> </form>\nIcons\ntemplate\n<form role=\"search\">\n<label for=\"searchIcon\" class=\"hidden-visually\">Search: </label>\n<input type=\"text\" name=\"searchIcon\" id=\"searchIcon\" v-model=\"searchIcon\" />\n<button type=\"submit\">\n<i class=\"fas fa-search\" aria-hidden=\"true\"></i>\n<span class=\"hidden-visually\">Search</span>\n</button>\n</form>\nStandards\nThe World Wide Web Consortium (W3C) Web Accessibility Initiative (WAI) develops web accessibility standards for the different components:\n- User Agent Accessibility Guidelines (UAAG)\n- web browsers and media players, including some aspects of assistive technologies\n- Authoring Tool Accessibility Guidelines (ATAG)\n- authoring tools\n- Web Content Accessibility Guidelines (WCAG)\n- web content - used by developers, authoring tools, and accessibility evaluation tools\nWeb Content Accessibility Guidelines (WCAG)\nWCAG 2.1 extends on WCAG 2.0 and allows implementation of new technologies by addressing changes to the web. The W3C encourages use of the most current version of WCAG when developing or updating Web accessibility policies.\nWCAG 2.1 Four Main Guiding Principles (abbreviated as POUR):\n- Perceivable\n- Users must be able to perceive the information being presented\n- Operable\n- Interface forms, controls, and navigation are operable\n- Understandable\n- Information and the operation of user interface must be understandable to all users\n- Robust\n- Users must be able to access the content as technologies advance\nWeb Accessibility Initiative – Accessible Rich Internet Applications (WAI-ARIA)\nW3C's WAI-ARIA provides guidance on how to build dynamic content and advanced user interface controls.\nResources\nDocumentation\n- WCAG 2.0\n- WCAG 2.1\n- Accessible Rich Internet Applications (WAI-ARIA) 1.2\n- WAI-ARIA Authoring Practices 1.2\nAssistive Technologies\nTesting\n- Automated Tools\n- Color Tools\n- Other Helpful Tools\nUsers\nThe World Health Organization estimates that 15% of the world's population has some form of disability, 2-4% of them severely so. That is an estimated 1 billion people worldwide; making people with disabilities the largest minority group in the world.\nThere are a huge range of disabilities, which can be divided roughly into four categories:\n- Visual - These users can benefit from the use of screen readers, screen magnification, controlling screen contrast, or braille display.\n- Auditory - These users can benefit from captioning, transcripts or sign language video.\n- Motor - These users can benefit from a range of assistive technologies for motor impairments: voice recognition software, eye tracking, single-switch access, head wand, sip and puff switch, oversized trackball mouse, adaptive keyboard or other assistive technologies.\n- Cognitive - These users can benefit from supplemental media, structural organization of content, clear and simple writing.\nCheck out the following links from WebAim to understand from users:",
    "metadata": {
      "source": "https://vuejs.org/guide/best-practices/accessibility",
      "title": "Accessibility | Vue.js"
    }
  },
  {
    "page_content": "Teleport\n<Teleport>\nis a built-in component that allows us to \"teleport\" a part of a component's template into a DOM node that exists outside the DOM hierarchy of that component.\nBasic Usage\nSometimes we may run into the following scenario: a part of a component's template belongs to it logically, but from a visual standpoint, it should be displayed somewhere else in the DOM, outside of the Vue application.\nThe most common example of this is when building a full-screen modal. Ideally, we want the modal's button and the modal itself to live within the same component, since they are both related to the open / close state of the modal. But that means the modal will be rendered alongside the button, deeply nested in the application's DOM hierarchy. This can create some tricky issues when positioning the modal via CSS.\nConsider the following HTML structure.\ntemplate\n<div class=\"outer\">\n<h3>Vue Teleport Example</h3>\n<div>\n<MyModal />\n</div>\n</div>\nAnd here is the implementation of <MyModal>\n:\nvue\n<script setup>\nimport { ref } from 'vue'\nconst open = ref(false)\n</script>\n<template>\n<button @click=\"open = true\">Open Modal</button>\n<div v-if=\"open\" class=\"modal\">\n<p>Hello from the modal!</p>\n<button @click=\"open = false\">Close</button>\n</div>\n</template>\n<style scoped>\n.modal {\nposition: fixed;\nz-index: 999;\ntop: 20%;\nleft: 50%;\nwidth: 300px;\nmargin-left: -150px;\n}\n</style>\nThe component contains a <button>\nto trigger the opening of the modal, and a <div>\nwith a class of .modal\n, which will contain the modal's content and a button to self-close.\nWhen using this component inside the initial HTML structure, there are a number of potential issues:\nposition: fixed\nonly places the element relative to the viewport when no ancestor element hastransform\n,perspective\norfilter\nproperty set. If, for example, we intend to animate the ancestor<div class=\"outer\">\nwith a CSS transform, it would break the modal layout!The modal's\nz-index\nis constrained by its containing elements. If there is another element that overlaps with<div class=\"outer\">\nand has a higherz-index\n, it would cover our modal.\n<Teleport>\nprovides a clean way to work around these, by allowing us to break out of the nested DOM structure. Let's modify <MyModal>\nto use <Teleport>\n:\ntemplate\n<button @click=\"open = true\">Open Modal</button>\n<Teleport to=\"body\">\n<div v-if=\"open\" class=\"modal\">\n<p>Hello from the modal!</p>\n<button @click=\"open = false\">Close</button>\n</div>\n</Teleport>\nThe to\ntarget of <Teleport>\nexpects a CSS selector string or an actual DOM node. Here, we are essentially telling Vue to \"teleport this template fragment to the body\ntag\".\nYou can click the button below and inspect the <body>\ntag via your browser's devtools:\nYou can combine <Teleport>\nwith <Transition>\nto create animated modals - see Example here.\nTIP\nThe teleport to\ntarget must be already in the DOM when the <Teleport>\ncomponent is mounted. Ideally, this should be an element outside the entire Vue application. If targeting another element rendered by Vue, you need to make sure that element is mounted before the <Teleport>\n.\nUsing with Components\n<Teleport>\nonly alters the rendered DOM structure - it does not affect the logical hierarchy of the components. That is to say, if <Teleport>\ncontains a component, that component will remain a logical child of the parent component containing the <Teleport>\n. Props passing and event emitting will continue to work the same way.\nThis also means that injections from a parent component work as expected, and that the child component will be nested below the parent component in the Vue Devtools, instead of being placed where the actual content moved to.\nDisabling Teleport\nIn some cases, we may want to conditionally disable <Teleport>\n. For example, we may want to render a component as an overlay for desktop, but inline on mobile. <Teleport>\nsupports the disabled\nprop which can be dynamically toggled:\ntemplate\n<Teleport :disabled=\"isMobile\">\n...\n</Teleport>\nWhere the isMobile\nstate can be dynamically updated by detecting media query changes.\nMultiple Teleports on the Same Target\nA common use case would be a reusable <Modal>\ncomponent, with the potential for multiple instances to be active at the same time. For this kind of scenario, multiple <Teleport>\ncomponents can mount their content to the same target element. The order will be a simple append - later mounts will be located after earlier ones within the target element.\nGiven the following usage:\ntemplate\n<Teleport to=\"#modals\">\n<div>A</div>\n</Teleport>\n<Teleport to=\"#modals\">\n<div>B</div>\n</Teleport>\nThe rendered result would be:\nhtml\n<div id=\"modals\">\n<div>A</div>\n<div>B</div>\n</div>\nRelated",
    "metadata": {
      "source": "https://vuejs.org/guide/built-ins/teleport",
      "title": "Teleport | Vue.js"
    }
  },
  {
    "page_content": "Slots\nThis page assumes you've already read the Components Basics. Read that first if you are new to components.\nSlot Content and Outlet\nWe have learned that components can accept props, which can be JavaScript values of any type. But how about template content? In some cases, we may want to pass a template fragment to a child component, and let the child component render the fragment within its own template.\nFor example, we may have a <FancyButton>\ncomponent that supports usage like this:\ntemplate\n<FancyButton>\nClick me! <!-- slot content -->\n</FancyButton>\nThe template of <FancyButton>\nlooks like this:\ntemplate\n<button class=\"fancy-btn\">\n<slot></slot> <!-- slot outlet -->\n</button>\nThe <slot>\nelement is a slot outlet that indicates where the parent-provided slot content should be rendered.\nAnd the final rendered DOM:\nhtml\n<button class=\"fancy-btn\">Click me!</button>\nWith slots, the <FancyButton>\nis responsible for rendering the outer <button>\n(and its fancy styling), while the inner content is provided by the parent component.\nAnother way to understand slots is by comparing them to JavaScript functions:\njs\n// parent component passing slot content\nFancyButton('Click me!')\n// FancyButton renders slot content in its own template\nfunction FancyButton(slotContent) {\nreturn `<button class=\"fancy-btn\">\n${slotContent}\n</button>`\n}\nSlot content is not just limited to text. It can be any valid template content. For example, we can pass in multiple elements, or even other components:\ntemplate\n<FancyButton>\n<span style=\"color:red\">Click me!</span>\n<AwesomeIcon name=\"plus\" />\n</FancyButton>\nBy using slots, our <FancyButton>\nis more flexible and reusable. We can now use it in different places with different inner content, but all with the same fancy styling.\nVue components' slot mechanism is inspired by the native Web Component <slot>\nelement, but with additional capabilities that we will see later.\nRender Scope\nSlot content has access to the data scope of the parent component, because it is defined in the parent. For example:\ntemplate\n<span>{{ message }}</span>\n<FancyButton>{{ message }}</FancyButton>\nHere both {{ message }}\ninterpolations will render the same content.\nSlot content does not have access to the child component's data. Expressions in Vue templates can only access the scope it is defined in, consistent with JavaScript's lexical scoping. In other words:\nExpressions in the parent template only have access to the parent scope; expressions in the child template only have access to the child scope.\nFallback Content\nThere are cases when it's useful to specify fallback (i.e. default) content for a slot, to be rendered only when no content is provided. For example, in a <SubmitButton>\ncomponent:\ntemplate\n<button type=\"submit\">\n<slot></slot>\n</button>\nWe might want the text \"Submit\" to be rendered inside the <button>\nif the parent didn't provide any slot content. To make \"Submit\" the fallback content, we can place it in between the <slot>\ntags:\ntemplate\n<button type=\"submit\">\n<slot>\nSubmit <!-- fallback content -->\n</slot>\n</button>\nNow when we use <SubmitButton>\nin a parent component, providing no content for the slot:\ntemplate\n<SubmitButton />\nThis will render the fallback content, \"Submit\":\nhtml\n<button type=\"submit\">Submit</button>\nBut if we provide content:\ntemplate\n<SubmitButton>Save</SubmitButton>\nThen the provided content will be rendered instead:\nhtml\n<button type=\"submit\">Save</button>\nNamed Slots\nThere are times when it's useful to have multiple slot outlets in a single component. For example, in a <BaseLayout>\ncomponent with the following template:\ntemplate\n<div class=\"container\">\n<header>\n<!-- We want header content here -->\n</header>\n<main>\n<!-- We want main content here -->\n</main>\n<footer>\n<!-- We want footer content here -->\n</footer>\n</div>\nFor these cases, the <slot>\nelement has a special attribute, name\n, which can be used to assign a unique ID to different slots so you can determine where content should be rendered:\ntemplate\n<div class=\"container\">\n<header>\n<slot name=\"header\"></slot>\n</header>\n<main>\n<slot></slot>\n</main>\n<footer>\n<slot name=\"footer\"></slot>\n</footer>\n</div>\nA <slot>\noutlet without name\nimplicitly has the name \"default\".\nIn a parent component using <BaseLayout>\n, we need a way to pass multiple slot content fragments, each targeting a different slot outlet. This is where named slots come in.\nTo pass a named slot, we need to use a <template>\nelement with the v-slot\ndirective, and then pass the name of the slot as an argument to v-slot\n:\ntemplate\n<BaseLayout>\n<template v-slot:header>\n<!-- content for the header slot -->\n</template>\n</BaseLayout>\nv-slot\nhas a dedicated shorthand #\n, so <template v-slot:header>\ncan be shortened to just <template #header>\n. Think of it as \"render this template fragment in the child component's 'header' slot\".\nHere's the code passing content for all three slots to <BaseLayout>\nusing the shorthand syntax:\ntemplate\n<BaseLayout>\n<template #header>\n<h1>Here might be a page title</h1>\n</template>\n<template #default>\n<p>A paragraph for the main content.</p>\n<p>And another one.</p>\n</template>\n<template #footer>\n<p>Here's some contact info</p>\n</template>\n</BaseLayout>\nWhen a component accepts both a default slot and named slots, all top-level non-<template>\nnodes are implicitly treated as content for the default slot. So the above can also be written as:\ntemplate\n<BaseLayout>\n<template #header>\n<h1>Here might be a page title</h1>\n</template>\n<!-- implicit default slot -->\n<p>A paragraph for the main content.</p>\n<p>And another one.</p>\n<template #footer>\n<p>Here's some contact info</p>\n</template>\n</BaseLayout>\nNow everything inside the <template>\nelements will be passed to the corresponding slots. The final rendered HTML will be:\nhtml\n<div class=\"container\">\n<header>\n<h1>Here might be a page title</h1>\n</header>\n<main>\n<p>A paragraph for the main content.</p>\n<p>And another one.</p>\n</main>\n<footer>\n<p>Here's some contact info</p>\n</footer>\n</div>\nAgain, it may help you understand named slots better using the JavaScript function analogy:\njs\n// passing multiple slot fragments with different names\nBaseLayout({\nheader: `...`,\ndefault: `...`,\nfooter: `...`\n})\n// <BaseLayout> renders them in different places\nfunction BaseLayout(slots) {\nreturn `<div class=\"container\">\n<header>${slots.header}</header>\n<main>${slots.default}</main>\n<footer>${slots.footer}</footer>\n</div>`\n}\nConditional Slots\nSometimes you want to render something based on whether or not a slot is present.\nYou can use the $slots property in combination with a v-if to achieve this.\nIn the example below we define a Card component with three conditional slots: header\n, footer\nand the default\none. When the header / footer / default is present we want to wrap them to provide additional styling:\ntemplate\n<template>\n<div class=\"card\">\n<div v-if=\"$slots.header\" class=\"card-header\">\n<slot name=\"header\" />\n</div>\n<div v-if=\"$slots.default\" class=\"card-content\">\n<slot />\n</div>\n<div v-if=\"$slots.footer\" class=\"card-footer\">\n<slot name=\"footer\" />\n</div>\n</div>\n</template>\nDynamic Slot Names\nDynamic directive arguments also work on v-slot\n, allowing the definition of dynamic slot names:\ntemplate\n<base-layout>\n<template v-slot:[dynamicSlotName]>\n...\n</template>\n<!-- with shorthand -->\n<template #[dynamicSlotName]>\n...\n</template>\n</base-layout>\nDo note the expression is subject to the syntax constraints of dynamic directive arguments.\nScoped Slots\nAs discussed in Render Scope, slot content does not have access to state in the child component.\nHowever, there are cases where it could be useful if a slot's content can make use of data from both the parent scope and the child scope. To achieve that, we need a way for the child to pass data to a slot when rendering it.\nIn fact, we can do exactly that - we can pass attributes to a slot outlet just like passing props to a component:\ntemplate\n<!-- <MyComponent> template -->\n<div>\n<slot :text=\"greetingMessage\" :count=\"1\"></slot>\n</div>\nReceiving the slot props is a bit different when using a single default slot vs. using named slots. We are going to show how to receive props using a single default slot first, by using v-slot\ndirectly on the child component tag:\ntemplate\n<MyComponent v-slot=\"slotProps\">\n{{ slotProps.text }} {{ slotProps.count }}\n</MyComponent>\nThe props passed to the slot by the child are available as the value of the corresponding v-slot\ndirective, which can be accessed by expressions inside the slot.\nYou can think of a scoped slot as a function being passed into the child component. The child component then calls it, passing props as arguments:\njs\nMyComponent({\n// passing the default slot, but as a function\ndefault: (slotProps) => {\nreturn `${slotProps.text} ${slotProps.count}`\n}\n})\nfunction MyComponent(slots) {\nconst greetingMessage = 'hello'\nreturn `<div>${\n// call the slot function with props!\nslots.default({ text: greetingMessage, count: 1 })\n}</div>`\n}\nIn fact, this is very close to how scoped slots are compiled, and how you would use scoped slots in manual render functions.\nNotice how v-slot=\"slotProps\"\nmatches the slot function signature. Just like with function arguments, we can use destructuring in v-slot\n:\ntemplate\n<MyComponent v-slot=\"{ text, count }\">\n{{ text }} {{ count }}\n</MyComponent>\nNamed Scoped Slots\nNamed scoped slots work similarly - slot props are accessible as the value of the v-slot\ndirective: v-slot:name=\"slotProps\"\n. When using the shorthand, it looks like this:\ntemplate\n<MyComponent>\n<template #header=\"headerProps\">\n{{ headerProps }}\n</template>\n<template #default=\"defaultProps\">\n{{ defaultProps }}\n</template>\n<template #footer=\"footerProps\">\n{{ footerProps }}\n</template>\n</MyComponent>\nPassing props to a named slot:\ntemplate\n<slot name=\"header\" message=\"hello\"></slot>\nNote the name\nof a slot won't be included in the props because it is reserved - so the resulting headerProps\nwould be { message: 'hello' }\n.\nIf you are mixing named slots with the default scoped slot, you need to use an explicit <template>\ntag for the default slot. Attempting to place the v-slot\ndirective directly on the component will result in a compilation error. This is to avoid any ambiguity about the scope of the props of the default slot. For example:\ntemplate\n<!-- <MyComponent> template -->\n<div>\n<slot :message=\"hello\"></slot>\n<slot name=\"footer\" />\n</div>\ntemplate\n<!-- This template won't compile -->\n<MyComponent v-slot=\"{ message }\">\n<p>{{ message }}</p>\n<template #footer>\n<!-- message belongs to the default slot, and is not available here -->\n<p>{{ message }}</p>\n</template>\n</MyComponent>\nUsing an explicit <template>\ntag for the default slot helps to make it clear that the message\nprop is not available inside the other slot:\ntemplate\n<MyComponent>\n<!-- Use explicit default slot -->\n<template #default=\"{ message }\">\n<p>{{ message }}</p>\n</template>\n<template #footer>\n<p>Here's some contact info</p>\n</template>\n</MyComponent>\nFancy List Example\nYou may be wondering what would be a good use case for scoped slots. Here's an example: imagine a <FancyList>\ncomponent that renders a list of items - it may encapsulate the logic for loading remote data, using the data to display a list, or even advanced features like pagination or infinite scrolling. However, we want it to be flexible with how each item looks and leave the styling of each item to the parent component consuming it. So the desired usage may look like this:\ntemplate\n<FancyList :api-url=\"url\" :per-page=\"10\">\n<template #item=\"{ body, username, likes }\">\n<div class=\"item\">\n<p>{{ body }}</p>\n<p>by {{ username }} | {{ likes }} likes</p>\n</div>\n</template>\n</FancyList>\nInside <FancyList>\n, we can render the same <slot>\nmultiple times with different item data (notice we are using v-bind\nto pass an object as slot props):\ntemplate\n<ul>\n<li v-for=\"item in items\">\n<slot name=\"item\" v-bind=\"item\"></slot>\n</li>\n</ul>\nRenderless Components\nThe <FancyList>\nuse case we discussed above encapsulates both reusable logic (data fetching, pagination etc.) and visual output, while delegating part of the visual output to the consumer component via scoped slots.\nIf we push this concept a bit further, we can come up with components that only encapsulate logic and do not render anything by themselves - visual output is fully delegated to the consumer component with scoped slots. We call this type of component a Renderless Component.\nAn example renderless component could be one that encapsulates the logic of tracking the current mouse position:\ntemplate\n<MouseTracker v-slot=\"{ x, y }\">\nMouse is at: {{ x }}, {{ y }}\n</MouseTracker>\nWhile an interesting pattern, most of what can be achieved with Renderless Components can be achieved in a more efficient fashion with Composition API, without incurring the overhead of extra component nesting. Later, we will see how we can implement the same mouse tracking functionality as a Composable.\nThat said, scoped slots are still useful in cases where we need to both encapsulate logic and compose visual output, like in the <FancyList>\nexample.",
    "metadata": {
      "source": "https://vuejs.org/guide/components/slots",
      "title": "Slots | Vue.js"
    }
  },
  {
    "page_content": "Animation Techniques\nVue provides the <Transition>\nand <TransitionGroup>\ncomponents for handling enter / leave and list transitions. However, there are many other ways of using animations on the web, even in a Vue application. Here we will discuss a few additional techniques.\nClass-based Animations\nFor elements that are not entering / leaving the DOM, we can trigger animations by dynamically adding a CSS class:\njs\nconst disabled = ref(false)\nfunction warnDisabled() {\ndisabled.value = true\nsetTimeout(() => {\ndisabled.value = false\n}, 1500)\n}\ntemplate\n<div :class=\"{ shake: disabled }\">\n<button @click=\"warnDisabled\">Click me</button>\n<span v-if=\"disabled\">This feature is disabled!</span>\n</div>\ncss\n.shake {\nanimation: shake 0.82s cubic-bezier(0.36, 0.07, 0.19, 0.97) both;\ntransform: translate3d(0, 0, 0);\n}\n@keyframes shake {\n10%,\n90% {\ntransform: translate3d(-1px, 0, 0);\n}\n20%,\n80% {\ntransform: translate3d(2px, 0, 0);\n}\n30%,\n50%,\n70% {\ntransform: translate3d(-4px, 0, 0);\n}\n40%,\n60% {\ntransform: translate3d(4px, 0, 0);\n}\n}\nState-driven Animations\nSome transition effects can be applied by interpolating values, for instance by binding a style to an element while an interaction occurs. Take this example for instance:\njs\nconst x = ref(0)\nfunction onMousemove(e) {\nx.value = e.clientX\n}\ntemplate\n<div\n@mousemove=\"onMousemove\"\n:style=\"{ backgroundColor: `hsl(${x}, 80%, 50%)` }\"\nclass=\"movearea\"\n>\n<p>Move your mouse across this div...</p>\n<p>x: {{ x }}</p>\n</div>\ncss\n.movearea {\ntransition: 0.3s background-color ease;\n}\nMove your mouse across this div...\nx: 0\nIn addition to color, you can also use style bindings to animate transform, width, or height. You can even animate SVG paths using spring physics - after all, they are all attribute data bindings:\nDrag Me\nAnimating with Watchers\nWith some creativity, we can use watchers to animate anything based on some numerical state. For example, we can animate the number itself:\njs\nimport { ref, reactive, watch } from 'vue'\nimport gsap from 'gsap'\nconst number = ref(0)\nconst tweened = reactive({\nnumber: 0\n})\nwatch(number, (n) => {\ngsap.to(tweened, { duration: 0.5, number: Number(n) || 0 })\n})\ntemplate\nType a number: <input v-model.number=\"number\" />\n<p>{{ tweened.number.toFixed(0) }}</p>\nType a number:\n0",
    "metadata": {
      "source": "https://vuejs.org/guide/extras/animation",
      "title": "Animation Techniques | Vue.js"
    }
  },
  {
    "page_content": "Class and Style Bindings\nA common need for data binding is manipulating an element's class list and inline styles. Since class\nand style\nare both attributes, we can use v-bind\nto assign them a string value dynamically, much like with other attributes. However, trying to generate those values using string concatenation can be annoying and error-prone. For this reason, Vue provides special enhancements when v-bind\nis used with class\nand style\n. In addition to strings, the expressions can also evaluate to objects or arrays.\nBinding HTML Classes\nBinding to Objects\nWe can pass an object to :class\n(short for v-bind:class\n) to dynamically toggle classes:\ntemplate\n<div :class=\"{ active: isActive }\"></div>\nThe above syntax means the presence of the active\nclass will be determined by the truthiness of the data property isActive\n.\nYou can have multiple classes toggled by having more fields in the object. In addition, the :class\ndirective can also co-exist with the plain class\nattribute. So given the following state:\njs\nconst isActive = ref(true)\nconst hasError = ref(false)\nAnd the following template:\ntemplate\n<div\nclass=\"static\"\n:class=\"{ active: isActive, 'text-danger': hasError }\"\n></div>\nIt will render:\ntemplate\n<div class=\"static active\"></div>\nWhen isActive\nor hasError\nchanges, the class list will be updated accordingly. For example, if hasError\nbecomes true\n, the class list will become \"static active text-danger\"\n.\nThe bound object doesn't have to be inline:\njs\nconst classObject = reactive({\nactive: true,\n'text-danger': false\n})\ntemplate\n<div :class=\"classObject\"></div>\nThis will render:\ntemplate\n<div class=\"active\"></div>\nWe can also bind to a computed property that returns an object. This is a common and powerful pattern:\njs\nconst isActive = ref(true)\nconst error = ref(null)\nconst classObject = computed(() => ({\nactive: isActive.value && !error.value,\n'text-danger': error.value && error.value.type === 'fatal'\n}))\ntemplate\n<div :class=\"classObject\"></div>\nBinding to Arrays\nWe can bind :class\nto an array to apply a list of classes:\njs\nconst activeClass = ref('active')\nconst errorClass = ref('text-danger')\ntemplate\n<div :class=\"[activeClass, errorClass]\"></div>\nWhich will render:\ntemplate\n<div class=\"active text-danger\"></div>\nIf you would like to also toggle a class in the list conditionally, you can do it with a ternary expression:\ntemplate\n<div :class=\"[isActive ? activeClass : '', errorClass]\"></div>\nThis will always apply errorClass\n, but activeClass\nwill only be applied when isActive\nis truthy.\nHowever, this can be a bit verbose if you have multiple conditional classes. That's why it's also possible to use the object syntax inside the array syntax:\ntemplate\n<div :class=\"[{ [activeClass]: isActive }, errorClass]\"></div>\nWith Components\nThis section assumes knowledge of Components. Feel free to skip it and come back later.\nWhen you use the class\nattribute on a component with a single root element, those classes will be added to the component's root element and merged with any existing class already on it.\nFor example, if we have a component named MyComponent\nwith the following template:\ntemplate\n<!-- child component template -->\n<p class=\"foo bar\">Hi!</p>\nThen add some classes when using it:\ntemplate\n<!-- when using the component -->\n<MyComponent class=\"baz boo\" />\nThe rendered HTML will be:\ntemplate\n<p class=\"foo bar baz boo\">Hi!</p>\nThe same is true for class bindings:\ntemplate\n<MyComponent :class=\"{ active: isActive }\" />\nWhen isActive\nis truthy, the rendered HTML will be:\ntemplate\n<p class=\"foo bar active\">Hi!</p>\nIf your component has multiple root elements, you would need to define which element will receive this class. You can do this using the $attrs\ncomponent property:\ntemplate\n<!-- MyComponent template using $attrs -->\n<p :class=\"$attrs.class\">Hi!</p>\n<span>This is a child component</span>\ntemplate\n<MyComponent class=\"baz\" />\nWill render:\nhtml\n<p class=\"baz\">Hi!</p>\n<span>This is a child component</span>\nYou can learn more about component attribute inheritance in Fallthrough Attributes section.\nBinding Inline Styles\nBinding to Objects\n:style\nsupports binding to JavaScript object values - it corresponds to an HTML element's style\nproperty:\njs\nconst activeColor = ref('red')\nconst fontSize = ref(30)\ntemplate\n<div :style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"></div>\nAlthough camelCase keys are recommended, :style\nalso supports kebab-cased CSS property keys (corresponds to how they are used in actual CSS) - for example:\ntemplate\n<div :style=\"{ 'font-size': fontSize + 'px' }\"></div>\nIt is often a good idea to bind to a style object directly so that the template is cleaner:\njs\nconst styleObject = reactive({\ncolor: 'red',\nfontSize: '30px'\n})\ntemplate\n<div :style=\"styleObject\"></div>\nAgain, object style binding is often used in conjunction with computed properties that return objects.\nBinding to Arrays\nWe can bind :style\nto an array of multiple style objects. These objects will be merged and applied to the same element:\ntemplate\n<div :style=\"[baseStyles, overridingStyles]\"></div>\nAuto-prefixing\nWhen you use a CSS property that requires a vendor prefix in :style\n, Vue will automatically add the appropriate prefix. Vue does this by checking at runtime to see which style properties are supported in the current browser. If the browser doesn't support a particular property then various prefixed variants will be tested to try to find one that is supported.\nMultiple Values\nYou can provide an array of multiple (prefixed) values to a style property, for example:\ntemplate\n<div :style=\"{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }\"></div>\nThis will only render the last value in the array which the browser supports. In this example, it will render display: flex\nfor browsers that support the unprefixed version of flexbox.",
    "metadata": {
      "source": "https://vuejs.org/guide/essentials/class-and-style",
      "title": "Class and Style Bindings | Vue.js"
    }
  },
  {
    "page_content": "Template Refs\nWhile Vue's declarative rendering model abstracts away most of the direct DOM operations for you, there may still be cases where we need direct access to the underlying DOM elements. To achieve this, we can use the special ref\nattribute:\ntemplate\n<input ref=\"input\">\nref\nis a special attribute, similar to the key\nattribute discussed in the v-for\nchapter. It allows us to obtain a direct reference to a specific DOM element or child component instance after it's mounted. This may be useful when you want to, for example, programmatically focus an input on component mount, or initialize a 3rd party library on an element.\nAccessing the Refs\nTo obtain the reference with Composition API, we need to declare a ref with a name that matches the template ref attribute's value:\nvue\n<script setup>\nimport { ref, onMounted } from 'vue'\n// declare a ref to hold the element reference\n// the name must match template ref value\nconst input = ref(null)\nonMounted(() => {\ninput.value.focus()\n})\n</script>\n<template>\n<input ref=\"input\" />\n</template>\nIf not using <script setup>\n, make sure to also return the ref from setup()\n:\njs\nexport default {\nsetup() {\nconst input = ref(null)\n// ...\nreturn {\ninput\n}\n}\n}\nNote that you can only access the ref after the component is mounted. If you try to access input\nin a template expression, it will be null\non the first render. This is because the element doesn't exist until after the first render!\nIf you are trying to watch the changes of a template ref, make sure to account for the case where the ref has null\nvalue:\njs\nwatchEffect(() => {\nif (input.value) {\ninput.value.focus()\n} else {\n// not mounted yet, or the element was unmounted (e.g. by v-if)\n}\n})\nSee also: Typing Template Refs\nRefs inside v-for\nRequires v3.2.25 or above\nWhen ref\nis used inside v-for\n, the corresponding ref should contain an Array value, which will be populated with the elements after mount:\nvue\n<script setup>\nimport { ref, onMounted } from 'vue'\nconst list = ref([\n/* ... */\n])\nconst itemRefs = ref([])\nonMounted(() => console.log(itemRefs.value))\n</script>\n<template>\n<ul>\n<li v-for=\"item in list\" ref=\"itemRefs\">\n{{ item }}\n</li>\n</ul>\n</template>\nIt should be noted that the ref array does not guarantee the same order as the source array.\nFunction Refs\nInstead of a string key, the ref\nattribute can also be bound to a function, which will be called on each component update and gives you full flexibility on where to store the element reference. The function receives the element reference as the first argument:\ntemplate\n<input :ref=\"(el) => { /* assign el to a property or ref */ }\">\nNote we are using a dynamic :ref\nbinding so we can pass it a function instead of a ref name string. When the element is unmounted, the argument will be null\n. You can, of course, use a method instead of an inline function.\nRef on Component\nThis section assumes knowledge of Components. Feel free to skip it and come back later.\nref\ncan also be used on a child component. In this case the reference will be that of a component instance:\nvue\n<script setup>\nimport { ref, onMounted } from 'vue'\nimport Child from './Child.vue'\nconst child = ref(null)\nonMounted(() => {\n// child.value will hold an instance of <Child />\n})\n</script>\n<template>\n<Child ref=\"child\" />\n</template>\nIf the child component is using Options API or not using <script setup>\n, the referenced instance will be identical to the child component's this\n, which means the parent component will have full access to every property and method of the child component. This makes it easy to create tightly coupled implementation details between the parent and the child, so component refs should be only used when absolutely needed - in most cases, you should try to implement parent / child interactions using the standard props and emit interfaces first.\nAn exception here is that components using <script setup>\nare private by default: a parent component referencing a child component using <script setup>\nwon't be able to access anything unless the child component chooses to expose a public interface using the defineExpose\nmacro:\nvue\n<script setup>\nimport { ref } from 'vue'\nconst a = 1\nconst b = ref(2)\n// Compiler macros, such as defineExpose, don't need to be imported\ndefineExpose({\na,\nb\n})\n</script>\nWhen a parent gets an instance of this component via template refs, the retrieved instance will be of the shape { a: number, b: number }\n(refs are automatically unwrapped just like on normal instances).\nSee also: Typing Component Template Refs",
    "metadata": {
      "source": "https://vuejs.org/guide/essentials/template-refs",
      "title": "Template Refs | Vue.js"
    }
  },
  {
    "page_content": "Composition API FAQ\nTIP\nThis FAQ assumes prior experience with Vue - in particular, experience with Vue 2 while primarily using Options API.\nWhat is Composition API?\nComposition API is a set of APIs that allows us to author Vue components using imported functions instead of declaring options. It is an umbrella term that covers the following APIs:\nReactivity API, e.g.\nref()\nandreactive()\n, that allows us to directly create reactive state, computed state, and watchers.Lifecycle Hooks, e.g.\nonMounted()\nandonUnmounted()\n, that allow us to programmatically hook into the component lifecycle.Dependency Injection, i.e.\nprovide()\nandinject()\n, that allow us to leverage Vue's dependency injection system while using Reactivity APIs.\nComposition API is a built-in feature of Vue 3 and Vue 2.7. For older Vue 2 versions, use the officially maintained @vue/composition-api\nplugin. In Vue 3, it is also primarily used together with the <script setup>\nsyntax in Single-File Components. Here's a basic example of a component using Composition API:\nvue\n<script setup>\nimport { ref, onMounted } from 'vue'\n// reactive state\nconst count = ref(0)\n// functions that mutate state and trigger updates\nfunction increment() {\ncount.value++\n}\n// lifecycle hooks\nonMounted(() => {\nconsole.log(`The initial count is ${count.value}.`)\n})\n</script>\n<template>\n<button @click=\"increment\">Count is: {{ count }}</button>\n</template>\nDespite an API style based on function composition, Composition API is NOT functional programming. Composition API is based on Vue's mutable, fine-grained reactivity paradigm, whereas functional programming emphasizes immutability.\nIf you are interested in learning how to use Vue with Composition API, you can set the site-wide API preference to Composition API using the toggle at the top of the left sidebar, and then go through the guide from the beginning.\nWhy Composition API?\nBetter Logic Reuse\nThe primary advantage of Composition API is that it enables clean, efficient logic reuse in the form of Composable functions. It solves all the drawbacks of mixins, the primary logic reuse mechanism for Options API.\nComposition API's logic reuse capability has given rise to impressive community projects such as VueUse, an ever-growing collection of composable utilities. It also serves as a clean mechanism for easily integrating stateful third-party services or libraries into Vue's reactivity system, for example immutable data, state machines, and RxJS.\nMore Flexible Code Organization\nMany users love that we write organized code by default with Options API: everything has its place based on the option it falls under. However, Options API poses serious limitations when a single component's logic grows beyond a certain complexity threshold. This limitation is particularly prominent in components that need to deal with multiple logical concerns, which we have witnessed first hand in many production Vue 2 apps.\nTake the folder explorer component from Vue CLI's GUI as an example: this component is responsible for the following logical concerns:\n- Tracking current folder state and displaying its content\n- Handling folder navigation (opening, closing, refreshing...)\n- Handling new folder creation\n- Toggling show favorite folders only\n- Toggling show hidden folders\n- Handling current working directory changes\nThe original version of the component was written in Options API. If we give each line of code a color based on the logical concern it is dealing with, this is how it looks:\nNotice how code dealing with the same logical concern is forced to be split under different options, located in different parts of the file. In a component that is several hundred lines long, understanding and navigating a single logical concern requires constantly scrolling up and down the file, making it much more difficult than it should be. In addition, if we ever intend to extract a logical concern into a reusable utility, it takes quite a bit of work to find and extract the right pieces of code from different parts of the file.\nHere's the same component, before and after the refactor into Composition API:\nNotice how the code related to the same logical concern can now be grouped together: we no longer need to jump between different options blocks while working on a specific logical concern. Moreover, we can now move a group of code into an external file with minimal effort, since we no longer need to shuffle the code around in order to extract them. This reduced friction for refactoring is key to the long-term maintainability in large codebases.\nBetter Type Inference\nIn recent years, more and more frontend developers are adopting TypeScript as it helps us write more robust code, make changes with more confidence, and provides a great development experience with IDE support. However, the Options API, originally conceived in 2013, was designed without type inference in mind. We had to implement some absurdly complex type gymnastics to make type inference work with the Options API. Even with all this effort, type inference for Options API can still break down for mixins and dependency injection.\nThis had led many developers who wanted to use Vue with TS to lean towards Class API powered by vue-class-component\n. However, a class-based API heavily relies on ES decorators, a language feature that was only a stage 2 proposal when Vue 3 was being developed in 2019. We felt it was too risky to base an official API on an unstable proposal. Since then, the decorators proposal has gone through yet another complete overhaul, and finally reached stage 3 in 2022. In addition, class-based API suffers from logic reuse and organization limitations similar to Options API.\nIn comparison, Composition API utilizes mostly plain variables and functions, which are naturally type friendly. Code written in Composition API can enjoy full type inference with little need for manual type hints. Most of the time, Composition API code will look largely identical in TypeScript and plain JavaScript. This also makes it possible for plain JavaScript users to benefit from partial type inference.\nSmaller Production Bundle and Less Overhead\nCode written in Composition API and <script setup>\nis also more efficient and minification-friendly than Options API equivalent. This is because the template in a <script setup>\ncomponent is compiled as a function inlined in the same scope of the <script setup>\ncode. Unlike property access from this\n, the compiled template code can directly access variables declared inside <script setup>\n, without an instance proxy in between. This also leads to better minification because all the variable names can be safely shortened.\nRelationship with Options API\nTrade-offs\nSome users moving from Options API found their Composition API code less organized, and concluded that Composition API is \"worse\" in terms of code organization. We recommend users with such opinions to look at that problem from a different perspective.\nIt is true that Composition API no longer provides the \"guard rails\" that guide you to put your code into respective buckets. In return, you get to author component code like how you would write normal JavaScript. This means you can and should apply any code organization best practices to your Composition API code as you would when writing normal JavaScript. If you can write well-organized JavaScript, you should also be able to write well-organized Composition API code.\nOptions API does allow you to \"think less\" when writing component code, which is why many users love it. However, in reducing the mental overhead, it also locks you into the prescribed code organization pattern with no escape hatch, which can make it difficult to refactor or improve code quality in larger scale projects. In this regard, Composition API provides better long term scalability.\nDoes Composition API cover all use cases?\nYes in terms of stateful logic. When using Composition API, there are only a few options that may still be needed: props\n, emits\n, name\n, and inheritAttrs\n.\nTIP\nSince 3.3 you can directly use defineOptions\nin <script setup>\nto set the component name or inheritAttrs\nproperty\nIf you intend to exclusively use Composition API (along with the options listed above), you can shave a few kbs off your production bundle via a compile-time flag that drops Options API related code from Vue. Note this also affects Vue components in your dependencies.\nCan I use both APIs in the same component?\nYes. You can use Composition API via the setup()\noption in an Options API component.\nHowever, we only recommend doing so if you have an existing Options API codebase that needs to integrate with new features / external libraries written with Composition API.\nWill Options API be deprecated?\nNo, we do not have any plan to do so. Options API is an integral part of Vue and the reason many developers love it. We also realize that many of the benefits of Composition API only manifest in larger-scale projects, and Options API remains a solid choice for many low-to-medium-complexity scenarios.\nRelationship with Class API\nWe no longer recommend using Class API with Vue 3, given that Composition API provides great TypeScript integration with additional logic reuse and code organization benefits.\nComparison with React Hooks\nComposition API provides the same level of logic composition capabilities as React Hooks, but with some important differences.\nReact Hooks are invoked repeatedly every time a component updates. This creates a number of caveats that can confuse even seasoned React developers. It also leads to performance optimization issues that can severely affect development experience. Here are some examples:\nHooks are call-order sensitive and cannot be conditional.\nVariables declared in a React component can be captured by a hook closure and become \"stale\" if the developer fails to pass in the correct dependencies array. This leads to React developers relying on ESLint rules to ensure correct dependencies are passed. However, the rule is often not smart enough and over-compensates for correctness, which leads to unnecessary invalidation and headaches when edge cases are encountered.\nExpensive computations require the use of\nuseMemo\n, which again requires manually passing in the correct dependencies array.Event handlers passed to child components cause unnecessary child updates by default, and require explicit\nuseCallback\nas an optimization. This is almost always needed, and again requires a correct dependencies array. Neglecting this leads to over-rendering apps by default and can cause performance issues without realizing it.The stale closure problem, combined with Concurrent features, makes it difficult to reason about when a piece of hooks code is run, and makes working with mutable state that should persist across renders (via\nuseRef\n) cumbersome.\nNote: some of the above issues that are related to memoization can be resolved by the upcoming React Compiler.\nIn comparison, Vue Composition API:\nInvokes\nsetup()\nor<script setup>\ncode only once. This makes the code align better with the intuitions of idiomatic JavaScript usage as there are no stale closures to worry about. Composition API calls are also not sensitive to call order and can be conditional.Vue's runtime reactivity system automatically collects reactive dependencies used in computed properties and watchers, so there's no need to manually declare dependencies.\nNo need to manually cache callback functions to avoid unnecessary child updates. In general, Vue's fine-grained reactivity system ensures child components only update when they need to. Manual child-update optimizations are rarely a concern for Vue developers.\nWe acknowledge the creativity of React Hooks, and it is a major source of inspiration for Composition API. However, the issues mentioned above do exist in its design and we noticed Vue's reactivity model happens to provide a way around them.",
    "metadata": {
      "source": "https://vuejs.org/guide/extras/composition-api-faq",
      "title": "Composition API FAQ | Vue.js"
    }
  },
  {
    "page_content": "Component Registration\nThis page assumes you've already read the Components Basics. Read that first if you are new to components.\nA Vue component needs to be \"registered\" so that Vue knows where to locate its implementation when it is encountered in a template. There are two ways to register components: global and local.\nGlobal Registration\nWe can make components available globally in the current Vue application using the .component()\nmethod:\njs\nimport { createApp } from 'vue'\nconst app = createApp({})\napp.component(\n// the registered name\n'MyComponent',\n// the implementation\n{\n/* ... */\n}\n)\nIf using SFCs, you will be registering the imported .vue\nfiles:\njs\nimport MyComponent from './App.vue'\napp.component('MyComponent', MyComponent)\nThe .component()\nmethod can be chained:\njs\napp\n.component('ComponentA', ComponentA)\n.component('ComponentB', ComponentB)\n.component('ComponentC', ComponentC)\nGlobally registered components can be used in the template of any component within this application:\ntemplate\n<!-- this will work in any component inside the app -->\n<ComponentA/>\n<ComponentB/>\n<ComponentC/>\nThis even applies to all subcomponents, meaning all three of these components will also be available inside each other.\nLocal Registration\nWhile convenient, global registration has a few drawbacks:\nGlobal registration prevents build systems from removing unused components (a.k.a \"tree-shaking\"). If you globally register a component but end up not using it anywhere in your app, it will still be included in the final bundle.\nGlobal registration makes dependency relationships less explicit in large applications. It makes it difficult to locate a child component's implementation from a parent component using it. This can affect long-term maintainability similar to using too many global variables.\nLocal registration scopes the availability of the registered components to the current component only. It makes the dependency relationship more explicit, and is more tree-shaking friendly.\nWhen using SFC with <script setup>\n, imported components can be locally used without registration:\nvue\n<script setup>\nimport ComponentA from './ComponentA.vue'\n</script>\n<template>\n<ComponentA />\n</template>\nIn non-<script setup>\n, you will need to use the components\noption:\njs\nimport ComponentA from './ComponentA.js'\nexport default {\ncomponents: {\nComponentA\n},\nsetup() {\n// ...\n}\n}\nFor each property in the components\nobject, the key will be the registered name of the component, while the value will contain the implementation of the component. The above example is using the ES2015 property shorthand and is equivalent to:\njs\nexport default {\ncomponents: {\nComponentA: ComponentA\n}\n// ...\n}\nNote that locally registered components are not also available in descendant components. In this case, ComponentA\nwill be made available to the current component only, not any of its child or descendant components.\nComponent Name Casing\nThroughout the guide, we are using PascalCase names when registering components. This is because:\nPascalCase names are valid JavaScript identifiers. This makes it easier to import and register components in JavaScript. It also helps IDEs with auto-completion.\n<PascalCase />\nmakes it more obvious that this is a Vue component instead of a native HTML element in templates. It also differentiates Vue components from custom elements (web components).\nThis is the recommended style when working with SFC or string templates. However, as discussed in in-DOM Template Parsing Caveats, PascalCase tags are not usable in in-DOM templates.\nLuckily, Vue supports resolving kebab-case tags to components registered using PascalCase. This means a component registered as MyComponent\ncan be referenced in the template via both <MyComponent>\nand <my-component>\n. This allows us to use the same JavaScript component registration code regardless of template source.",
    "metadata": {
      "source": "https://vuejs.org/guide/components/registration",
      "title": "Component Registration | Vue.js"
    }
  },
  {
    "page_content": "Props\nThis page assumes you've already read the Components Basics. Read that first if you are new to components.\nProps Declaration\nVue components require explicit props declaration so that Vue knows what external props passed to the component should be treated as fallthrough attributes (which will be discussed in its dedicated section).\nIn SFCs using <script setup>\n, props can be declared using the defineProps()\nmacro:\nvue\n<script setup>\nconst props = defineProps(['foo'])\nconsole.log(props.foo)\n</script>\nIn non-<script setup>\ncomponents, props are declared using the props\noption:\njs\nexport default {\nprops: ['foo'],\nsetup(props) {\n// setup() receives props as the first argument.\nconsole.log(props.foo)\n}\n}\nNotice the argument passed to defineProps()\nis the same as the value provided to the props\noptions: the same props options API is shared between the two declaration styles.\nIn addition to declaring props using an array of strings, we can also use the object syntax:\njs\n// in <script setup>\ndefineProps({\ntitle: String,\nlikes: Number\n})\njs\n// in non-<script setup>\nexport default {\nprops: {\ntitle: String,\nlikes: Number\n}\n}\nFor each property in the object declaration syntax, the key is the name of the prop, while the value should be the constructor function of the expected type.\nThis not only documents your component, but will also warn other developers using your component in the browser console if they pass the wrong type. We will discuss more details about prop validation further down this page.\nIf you are using TypeScript with <script setup>\n, it's also possible to declare props using pure type annotations:\nvue\n<script setup lang=\"ts\">\ndefineProps<{\ntitle?: string\nlikes?: number\n}>()\n</script>\nMore details: Typing Component Props\nProp Passing Details\nProp Name Casing\nWe declare long prop names using camelCase because this avoids having to use quotes when using them as property keys, and allows us to reference them directly in template expressions because they are valid JavaScript identifiers:\njs\ndefineProps({\ngreetingMessage: String\n})\ntemplate\n<span>{{ greetingMessage }}</span>\nTechnically, you can also use camelCase when passing props to a child component (except in in-DOM templates). However, the convention is using kebab-case in all cases to align with HTML attributes:\ntemplate\n<MyComponent greeting-message=\"hello\" />\nWe use PascalCase for component tags when possible because it improves template readability by differentiating Vue components from native elements. However, there isn't as much practical benefit in using camelCase when passing props, so we choose to follow each language's conventions.\nStatic vs. Dynamic Props\nSo far, you've seen props passed as static values, like in:\ntemplate\n<BlogPost title=\"My journey with Vue\" />\nYou've also seen props assigned dynamically with v-bind\nor its :\nshortcut, such as in:\ntemplate\n<!-- Dynamically assign the value of a variable -->\n<BlogPost :title=\"post.title\" />\n<!-- Dynamically assign the value of a complex expression -->\n<BlogPost :title=\"post.title + ' by ' + post.author.name\" />\nPassing Different Value Types\nIn the two examples above, we happen to pass string values, but any type of value can be passed to a prop.\nNumber\ntemplate\n<!-- Even though `42` is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string. -->\n<BlogPost :likes=\"42\" />\n<!-- Dynamically assign to the value of a variable. -->\n<BlogPost :likes=\"post.likes\" />\nBoolean\ntemplate\n<!-- Including the prop with no value will imply `true`. -->\n<BlogPost is-published />\n<!-- Even though `false` is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string. -->\n<BlogPost :is-published=\"false\" />\n<!-- Dynamically assign to the value of a variable. -->\n<BlogPost :is-published=\"post.isPublished\" />\nArray\ntemplate\n<!-- Even though the array is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string. -->\n<BlogPost :comment-ids=\"[234, 266, 273]\" />\n<!-- Dynamically assign to the value of a variable. -->\n<BlogPost :comment-ids=\"post.commentIds\" />\nObject\ntemplate\n<!-- Even though the object is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string. -->\n<BlogPost\n:author=\"{\nname: 'Veronica',\ncompany: 'Veridian Dynamics'\n}\"\n/>\n<!-- Dynamically assign to the value of a variable. -->\n<BlogPost :author=\"post.author\" />\nBinding Multiple Properties Using an Object\nIf you want to pass all the properties of an object as props, you can use v-bind\nwithout an argument (v-bind\ninstead of :prop-name\n). For example, given a post\nobject:\njs\nconst post = {\nid: 1,\ntitle: 'My Journey with Vue'\n}\nThe following template:\ntemplate\n<BlogPost v-bind=\"post\" />\nWill be equivalent to:\ntemplate\n<BlogPost :id=\"post.id\" :title=\"post.title\" />\nOne-Way Data Flow\nAll props form a one-way-down binding between the child property and the parent one: when the parent property updates, it will flow down to the child, but not the other way around. This prevents child components from accidentally mutating the parent's state, which can make your app's data flow harder to understand.\nIn addition, every time the parent component is updated, all props in the child component will be refreshed with the latest value. This means you should not attempt to mutate a prop inside a child component. If you do, Vue will warn you in the console:\njs\nconst props = defineProps(['foo'])\n// ❌ warning, props are readonly!\nprops.foo = 'bar'\nThere are usually two cases where it's tempting to mutate a prop:\nThe prop is used to pass in an initial value; the child component wants to use it as a local data property afterwards. In this case, it's best to define a local data property that uses the prop as its initial value:\njsconst props = defineProps(['initialCounter']) // counter only uses props.initialCounter as the initial value; // it is disconnected from future prop updates. const counter = ref(props.initialCounter)\nThe prop is passed in as a raw value that needs to be transformed. In this case, it's best to define a computed property using the prop's value:\njsconst props = defineProps(['size']) // computed property that auto-updates when the prop changes const normalizedSize = computed(() => props.size.trim().toLowerCase())\nMutating Object / Array Props\nWhen objects and arrays are passed as props, while the child component cannot mutate the prop binding, it will be able to mutate the object or array's nested properties. This is because in JavaScript objects and arrays are passed by reference, and it is unreasonably expensive for Vue to prevent such mutations.\nThe main drawback of such mutations is that it allows the child component to affect parent state in a way that isn't obvious to the parent component, potentially making it more difficult to reason about the data flow in the future. As a best practice, you should avoid such mutations unless the parent and child are tightly coupled by design. In most cases, the child should emit an event to let the parent perform the mutation.\nProp Validation\nComponents can specify requirements for their props, such as the types you've already seen. If a requirement is not met, Vue will warn you in the browser's JavaScript console. This is especially useful when developing a component that is intended to be used by others.\nTo specify prop validations, you can provide an object with validation requirements to the defineProps()\nmacro , instead of an array of strings. For example:\njs\ndefineProps({\n// Basic type check\n// (`null` and `undefined` values will allow any type)\npropA: Number,\n// Multiple possible types\npropB: [String, Number],\n// Required string\npropC: {\ntype: String,\nrequired: true\n},\n// Required but nullable string\npropD: {\ntype: [String, null],\nrequired: true\n},\n// Number with a default value\npropE: {\ntype: Number,\ndefault: 100\n},\n// Object with a default value\npropF: {\ntype: Object,\n// Object or array defaults must be returned from\n// a factory function. The function receives the raw\n// props received by the component as the argument.\ndefault(rawProps) {\nreturn { message: 'hello' }\n}\n},\n// Custom validator function\n// full props passed as 2nd argument in 3.4+\npropG: {\nvalidator(value, props) {\n// The value must match one of these strings\nreturn ['success', 'warning', 'danger'].includes(value)\n}\n},\n// Function with a default value\npropH: {\ntype: Function,\n// Unlike object or array default, this is not a factory\n// function - this is a function to serve as a default value\ndefault() {\nreturn 'Default function'\n}\n}\n})\nTIP\nCode inside the defineProps()\nargument cannot access other variables declared in <script setup>\n, because the entire expression is moved to an outer function scope when compiled.\nAdditional details:\nAll props are optional by default, unless\nrequired: true\nis specified.An absent optional prop other than\nBoolean\nwill haveundefined\nvalue.The\nBoolean\nabsent props will be cast tofalse\n. You can change this by setting adefault\nfor it — i.e.:default: undefined\nto behave as a non-Boolean prop.If a\ndefault\nvalue is specified, it will be used if the resolved prop value isundefined\n- this includes both when the prop is absent, or an explicitundefined\nvalue is passed.\nWhen prop validation fails, Vue will produce a console warning (if using the development build).\nIf using Type-based props declarations , Vue will try its best to compile the type annotations into equivalent runtime prop declarations. For example, defineProps<{ msg: string }>\nwill be compiled into { msg: { type: String, required: true }}\n.\nRuntime Type Checks\nThe type\ncan be one of the following native constructors:\nString\nNumber\nBoolean\nArray\nObject\nDate\nFunction\nSymbol\nError\nIn addition, type\ncan also be a custom class or constructor function and the assertion will be made with an instanceof\ncheck. For example, given the following class:\njs\nclass Person {\nconstructor(firstName, lastName) {\nthis.firstName = firstName\nthis.lastName = lastName\n}\n}\nYou could use it as a prop's type:\njs\ndefineProps({\nauthor: Person\n})\nVue will use instanceof Person\nto validate whether the value of the author\nprop is indeed an instance of the Person\nclass.\nNullable Type\nIf the type is required but nullable, you can use the array syntax that includes null\n:\njs\ndefineProps({\nid: {\ntype: [String, null],\nrequired: true\n}\n})\nNote that if type\nis just null\nwithout using the array syntax, it will allow any type.\nBoolean Casting\nProps with Boolean\ntype have special casting rules to mimic the behavior of native boolean attributes. Given a <MyComponent>\nwith the following declaration:\njs\ndefineProps({\ndisabled: Boolean\n})\nThe component can be used like this:\ntemplate\n<!-- equivalent of passing :disabled=\"true\" -->\n<MyComponent disabled />\n<!-- equivalent of passing :disabled=\"false\" -->\n<MyComponent />\nWhen a prop is declared to allow multiple types, the casting rules for Boolean\nwill also be applied. However, there is an edge when both String\nand Boolean\nare allowed - the Boolean casting rule only applies if Boolean appears before String:\njs\n// disabled will be casted to true\ndefineProps({\ndisabled: [Boolean, Number]\n})\n// disabled will be casted to true\ndefineProps({\ndisabled: [Boolean, String]\n})\n// disabled will be casted to true\ndefineProps({\ndisabled: [Number, Boolean]\n})\n// disabled will be parsed as an empty string (disabled=\"\")\ndefineProps({\ndisabled: [String, Boolean]\n})",
    "metadata": {
      "source": "https://vuejs.org/guide/components/props",
      "title": "Props | Vue.js"
    }
  },
  {
    "page_content": "Lifecycle Hooks\nEach Vue component instance goes through a series of initialization steps when it's created - for example, it needs to set up data observation, compile the template, mount the instance to the DOM, and update the DOM when data changes. Along the way, it also runs functions called lifecycle hooks, giving users the opportunity to add their own code at specific stages.\nRegistering Lifecycle Hooks\nFor example, the onMounted\nhook can be used to run code after the component has finished the initial rendering and created the DOM nodes:\nvue\n<script setup>\nimport { onMounted } from 'vue'\nonMounted(() => {\nconsole.log(`the component is now mounted.`)\n})\n</script>\nThere are also other hooks which will be called at different stages of the instance's lifecycle, with the most commonly used being onMounted\n, onUpdated\n, and onUnmounted\n.\nWhen calling onMounted\n, Vue automatically associates the registered callback function with the current active component instance. This requires these hooks to be registered synchronously during component setup. For example, do not do this:\njs\nsetTimeout(() => {\nonMounted(() => {\n// this won't work.\n})\n}, 100)\nDo note this doesn't mean that the call must be placed lexically inside setup()\nor <script setup>\n. onMounted()\ncan be called in an external function as long as the call stack is synchronous and originates from within setup()\n.\nLifecycle Diagram\nBelow is a diagram for the instance lifecycle. You don't need to fully understand everything going on right now, but as you learn and build more, it will be a useful reference.\nConsult the Lifecycle Hooks API reference for details on all lifecycle hooks and their respective use cases.",
    "metadata": {
      "source": "https://vuejs.org/guide/essentials/lifecycle",
      "title": "Lifecycle Hooks | Vue.js"
    }
  },
  {
    "page_content": "Routing\nClient-Side vs. Server-Side Routing\nRouting on the server side means the server is sending a response based on the URL path that the user is visiting. When we click on a link in a traditional server-rendered web app, the browser receives an HTML response from the server and reloads the entire page with the new HTML.\nIn a Single-Page Application (SPA), however, the client-side JavaScript can intercept the navigation, dynamically fetch new data, and update the current page without full page reloads. This typically results in a more snappy user experience, especially for use cases that are more like actual \"applications\", where the user is expected to perform many interactions over a long period of time.\nIn such SPAs, the \"routing\" is done on the client side, in the browser. A client-side router is responsible for managing the application's rendered view using browser APIs such as History API or the hashchange\nevent.\nOfficial Router\nVue is well-suited for building SPAs. For most SPAs, it's recommended to use the officially-supported Vue Router library. For more details, see Vue Router's documentation.\nSimple Routing from Scratch\nIf you only need very simple routing and do not wish to involve a full-featured router library, you can do so with Dynamic Components and update the current component state by listening to browser hashchange\nevents or using the History API.\nHere's a bare-bone example:\nvue\n<script setup>\nimport { ref, computed } from 'vue'\nimport Home from './Home.vue'\nimport About from './About.vue'\nimport NotFound from './NotFound.vue'\nconst routes = {\n'/': Home,\n'/about': About\n}\nconst currentPath = ref(window.location.hash)\nwindow.addEventListener('hashchange', () => {\ncurrentPath.value = window.location.hash\n})\nconst currentView = computed(() => {\nreturn routes[currentPath.value.slice(1) || '/'] || NotFound\n})\n</script>\n<template>\n<a href=\"#/\">Home</a> |\n<a href=\"#/about\">About</a> |\n<a href=\"#/non-existent-path\">Broken Link</a>\n<component :is=\"currentView\" />\n</template>",
    "metadata": {
      "source": "https://vuejs.org/guide/scaling-up/routing",
      "title": "Routing | Vue.js"
    }
  },
  {
    "page_content": "Watchers\nBasic Example\nComputed properties allow us to declaratively compute derived values. However, there are cases where we need to perform \"side effects\" in reaction to state changes - for example, mutating the DOM, or changing another piece of state based on the result of an async operation.\nWith Composition API, we can use the watch\nfunction to trigger a callback whenever a piece of reactive state changes:\nvue\n<script setup>\nimport { ref, watch } from 'vue'\nconst question = ref('')\nconst answer = ref('Questions usually contain a question mark. ;-)')\nconst loading = ref(false)\n// watch works directly on a ref\nwatch(question, async (newQuestion, oldQuestion) => {\nif (newQuestion.includes('?')) {\nloading.value = true\nanswer.value = 'Thinking...'\ntry {\nconst res = await fetch('https://yesno.wtf/api')\nanswer.value = (await res.json()).answer\n} catch (error) {\nanswer.value = 'Error! Could not reach the API. ' + error\n} finally {\nloading.value = false\n}\n}\n})\n</script>\n<template>\n<p>\nAsk a yes/no question:\n<input v-model=\"question\" :disabled=\"loading\" />\n</p>\n<p>{{ answer }}</p>\n</template>\nWatch Source Types\nwatch\n's first argument can be different types of reactive \"sources\": it can be a ref (including computed refs), a reactive object, a getter function, or an array of multiple sources:\njs\nconst x = ref(0)\nconst y = ref(0)\n// single ref\nwatch(x, (newX) => {\nconsole.log(`x is ${newX}`)\n})\n// getter\nwatch(\n() => x.value + y.value,\n(sum) => {\nconsole.log(`sum of x + y is: ${sum}`)\n}\n)\n// array of multiple sources\nwatch([x, () => y.value], ([newX, newY]) => {\nconsole.log(`x is ${newX} and y is ${newY}`)\n})\nDo note that you can't watch a property of a reactive object like this:\njs\nconst obj = reactive({ count: 0 })\n// this won't work because we are passing a number to watch()\nwatch(obj.count, (count) => {\nconsole.log(`Count is: ${count}`)\n})\nInstead, use a getter:\njs\n// instead, use a getter:\nwatch(\n() => obj.count,\n(count) => {\nconsole.log(`Count is: ${count}`)\n}\n)\nDeep Watchers\nWhen you call watch()\ndirectly on a reactive object, it will implicitly create a deep watcher - the callback will be triggered on all nested mutations:\njs\nconst obj = reactive({ count: 0 })\nwatch(obj, (newValue, oldValue) => {\n// fires on nested property mutations\n// Note: `newValue` will be equal to `oldValue` here\n// because they both point to the same object!\n})\nobj.count++\nThis should be differentiated with a getter that returns a reactive object - in the latter case, the callback will only fire if the getter returns a different object:\njs\nwatch(\n() => state.someObject,\n() => {\n// fires only when state.someObject is replaced\n}\n)\nYou can, however, force the second case into a deep watcher by explicitly using the deep\noption:\njs\nwatch(\n() => state.someObject,\n(newValue, oldValue) => {\n// Note: `newValue` will be equal to `oldValue` here\n// *unless* state.someObject has been replaced\n},\n{ deep: true }\n)\nUse with Caution\nDeep watch requires traversing all nested properties in the watched object, and can be expensive when used on large data structures. Use it only when necessary and beware of the performance implications.\nEager Watchers\nwatch\nis lazy by default: the callback won't be called until the watched source has changed. But in some cases we may want the same callback logic to be run eagerly - for example, we may want to fetch some initial data, and then re-fetch the data whenever relevant state changes.\nWe can force a watcher's callback to be executed immediately by passing the immediate: true\noption:\njs\nwatch(\nsource,\n(newValue, oldValue) => {\n// executed immediately, then again when `source` changes\n},\n{ immediate: true }\n)\nOnce Watchers\nWatcher's callback will execute whenever the watched source changes. If you want the callback to trigger only once when the source changes, use the once: true\noption.\njs\nwatch(\nsource,\n(newValue, oldValue) => {\n// when `source` changes, triggers only once\n},\n{ once: true }\n)\nwatchEffect()\nIt is common for the watcher callback to use exactly the same reactive state as the source. For example, consider the following code, which uses a watcher to load a remote resource whenever the todoId\nref changes:\njs\nconst todoId = ref(1)\nconst data = ref(null)\nwatch(\ntodoId,\nasync () => {\nconst response = await fetch(\n`https://jsonplaceholder.typicode.com/todos/${todoId.value}`\n)\ndata.value = await response.json()\n},\n{ immediate: true }\n)\nIn particular, notice how the watcher uses todoId\ntwice, once as the source and then again inside the callback.\nThis can be simplified with watchEffect()\n. watchEffect()\nallows us to track the callback's reactive dependencies automatically. The watcher above can be rewritten as:\njs\nwatchEffect(async () => {\nconst response = await fetch(\n`https://jsonplaceholder.typicode.com/todos/${todoId.value}`\n)\ndata.value = await response.json()\n})\nHere, the callback will run immediately, there's no need to specify immediate: true\n. During its execution, it will automatically track todoId.value\nas a dependency (similar to computed properties). Whenever todoId.value\nchanges, the callback will be run again. With watchEffect()\n, we no longer need to pass todoId\nexplicitly as the source value.\nYou can check out this example of watchEffect()\nand reactive data-fetching in action.\nFor examples like these, with only one dependency, the benefit of watchEffect()\nis relatively small. But for watchers that have multiple dependencies, using watchEffect()\nremoves the burden of having to maintain the list of dependencies manually. In addition, if you need to watch several properties in a nested data structure, watchEffect()\nmay prove more efficient than a deep watcher, as it will only track the properties that are used in the callback, rather than recursively tracking all of them.\nTIP\nwatchEffect\nonly tracks dependencies during its synchronous execution. When using it with an async callback, only properties accessed before the first await\ntick will be tracked.\nwatch\nvs. watchEffect\nwatch\nand watchEffect\nboth allow us to reactively perform side effects. Their main difference is the way they track their reactive dependencies:\nwatch\nonly tracks the explicitly watched source. It won't track anything accessed inside the callback. In addition, the callback only triggers when the source has actually changed.watch\nseparates dependency tracking from the side effect, giving us more precise control over when the callback should fire.watchEffect\n, on the other hand, combines dependency tracking and side effect into one phase. It automatically tracks every reactive property accessed during its synchronous execution. This is more convenient and typically results in terser code, but makes its reactive dependencies less explicit.\nCallback Flush Timing\nWhen you mutate reactive state, it may trigger both Vue component updates and watcher callbacks created by you.\nSimilar to component updates, user-created watcher callbacks are batched to avoid duplicate invocations. For example, we probably don't want a watcher to fire a thousand times if we synchronously push a thousand items into an array being watched.\nBy default, a watcher's callback is called after parent component updates (if any), and before the owner component's DOM updates. This means if you attempt to access the owner component's own DOM inside a watcher callback, the DOM will be in a pre-update state.\nPost Watchers\nIf you want to access the owner component's DOM in a watcher callback after Vue has updated it, you need to specify the flush: 'post'\noption:\njs\nwatch(source, callback, {\nflush: 'post'\n})\nwatchEffect(callback, {\nflush: 'post'\n})\nPost-flush watchEffect()\nalso has a convenience alias, watchPostEffect()\n:\njs\nimport { watchPostEffect } from 'vue'\nwatchPostEffect(() => {\n/* executed after Vue updates */\n})\nSync Watchers\nIt's also possible to create a watcher that fires synchronously, before any Vue-managed updates:\njs\nwatch(source, callback, {\nflush: 'sync'\n})\nwatchEffect(callback, {\nflush: 'sync'\n})\nSync watchEffect()\nalso has a convenience alias, watchSyncEffect()\n:\njs\nimport { watchSyncEffect } from 'vue'\nwatchSyncEffect(() => {\n/* executed synchronously upon reactive data change */\n})\nUse with Caution\nSync watchers do not have batching and triggers every time a reactive mutation is detected. It's ok to use them to watch simple boolean values, but avoid using them on data sources that might be synchronously mutated many times, e.g. arrays.\nStopping a Watcher\nWatchers declared synchronously inside setup()\nor <script setup>\nare bound to the owner component instance, and will be automatically stopped when the owner component is unmounted. In most cases, you don't need to worry about stopping the watcher yourself.\nThe key here is that the watcher must be created synchronously: if the watcher is created in an async callback, it won't be bound to the owner component and must be stopped manually to avoid memory leaks. Here's an example:\nvue\n<script setup>\nimport { watchEffect } from 'vue'\n// this one will be automatically stopped\nwatchEffect(() => {})\n// ...this one will not!\nsetTimeout(() => {\nwatchEffect(() => {})\n}, 100)\n</script>\nTo manually stop a watcher, use the returned handle function. This works for both watch\nand watchEffect\n:\njs\nconst unwatch = watchEffect(() => {})\n// ...later, when no longer needed\nunwatch()\nNote that there should be very few cases where you need to create watchers asynchronously, and synchronous creation should be preferred whenever possible. If you need to wait for some async data, you can make your watch logic conditional instead:\njs\n// data to be loaded asynchronously\nconst data = ref(null)\nwatchEffect(() => {\nif (data.value) {\n// do something when data is loaded\n}\n})",
    "metadata": {
      "source": "https://vuejs.org/guide/essentials/watchers",
      "title": "Watchers | Vue.js"
    }
  },
  {
    "page_content": "Creating a Vue Application\nThe application instance\nEvery Vue application starts by creating a new application instance with the createApp\nfunction:\njs\nimport { createApp } from 'vue'\nconst app = createApp({\n/* root component options */\n})\nThe Root Component\nThe object we are passing into createApp\nis in fact a component. Every app requires a \"root component\" that can contain other components as its children.\nIf you are using Single-File Components, we typically import the root component from another file:\njs\nimport { createApp } from 'vue'\n// import the root component App from a single-file component.\nimport App from './App.vue'\nconst app = createApp(App)\nWhile many examples in this guide only need a single component, most real applications are organized into a tree of nested, reusable components. For example, a Todo application's component tree might look like this:\nApp (root component)\n├─ TodoList\n│ └─ TodoItem\n│ ├─ TodoDeleteButton\n│ └─ TodoEditButton\n└─ TodoFooter\n├─ TodoClearButton\n└─ TodoStatistics\nIn later sections of the guide, we will discuss how to define and compose multiple components together. Before that, we will focus on what happens inside a single component.\nMounting the App\nAn application instance won't render anything until its .mount()\nmethod is called. It expects a \"container\" argument, which can either be an actual DOM element or a selector string:\nhtml\n<div id=\"app\"></div>\njs\napp.mount('#app')\nThe content of the app's root component will be rendered inside the container element. The container element itself is not considered part of the app.\nThe .mount()\nmethod should always be called after all app configurations and asset registrations are done. Also note that its return value, unlike the asset registration methods, is the root component instance instead of the application instance.\nIn-DOM Root Component Template\nThe template for the root component is usually part of the component itself, but it is also possible to provide the template separately by writing it directly inside the mount container:\nhtml\n<div id=\"app\">\n<button @click=\"count++\">{{ count }}</button>\n</div>\njs\nimport { createApp } from 'vue'\nconst app = createApp({\ndata() {\nreturn {\ncount: 0\n}\n}\n})\napp.mount('#app')\nVue will automatically use the container's innerHTML\nas the template if the root component does not already have a template\noption.\nIn-DOM templates are often used in applications that are using Vue without a build step. They can also be used in conjunction with server-side frameworks, where the root template might be generated dynamically by the server.\nApp Configurations\nThe application instance exposes a .config\nobject that allows us to configure a few app-level options, for example, defining an app-level error handler that captures errors from all descendant components:\njs\napp.config.errorHandler = (err) => {\n/* handle error */\n}\nThe application instance also provides a few methods for registering app-scoped assets. For example, registering a component:\njs\napp.component('TodoDeleteButton', TodoDeleteButton)\nThis makes the TodoDeleteButton\navailable for use anywhere in our app. We will discuss registration for components and other types of assets in later sections of the guide. You can also browse the full list of application instance APIs in its API reference.\nMake sure to apply all app configurations before mounting the app!\nMultiple application instances\nYou are not limited to a single application instance on the same page. The createApp\nAPI allows multiple Vue applications to co-exist on the same page, each with its own scope for configuration and global assets:\njs\nconst app1 = createApp({\n/* ... */\n})\napp1.mount('#container-1')\nconst app2 = createApp({\n/* ... */\n})\napp2.mount('#container-2')\nIf you are using Vue to enhance server-rendered HTML and only need Vue to control specific parts of a large page, avoid mounting a single Vue application instance on the entire page. Instead, create multiple small application instances and mount them on the elements they are responsible for.",
    "metadata": {
      "source": "https://vuejs.org/guide/essentials/application",
      "title": "Creating a Vue Application | Vue.js"
    }
  },
  {
    "page_content": "Reactivity Transform\nRemoved Experimental Feature\nReactivity Transform was an experimental feature, and has been removed in the latest 3.4 release. Please read about the reasoning here.\nIf you still intend to use it, it is now available via the Vue Macros plugin.\nComposition-API-specific\nReactivity Transform is a Composition-API-specific feature and requires a build step.\nRefs vs. Reactive Variables\nEver since the introduction of the Composition API, one of the primary unresolved questions is the use of refs vs. reactive objects. It's easy to lose reactivity when destructuring reactive objects, while it can be cumbersome to use .value\neverywhere when using refs. Also, .value\nis easy to miss if not using a type system.\nVue Reactivity Transform is a compile-time transform that allows us to write code like this:\nvue\n<script setup>\nlet count = $ref(0)\nconsole.log(count)\nfunction increment() {\ncount++\n}\n</script>\n<template>\n<button @click=\"increment\">{{ count }}</button>\n</template>\nThe $ref()\nmethod here is a compile-time macro: it is not an actual method that will be called at runtime. Instead, the Vue compiler uses it as a hint to treat the resulting count\nvariable as a reactive variable.\nReactive variables can be accessed and re-assigned just like normal variables, but these operations are compiled into refs with .value\n. For example, the <script>\npart of the above component is compiled into:\njs\nimport { ref } from 'vue'\nlet count = ref(0)\nconsole.log(count.value)\nfunction increment() {\ncount.value++\n}\nEvery reactivity API that returns refs will have a $\n-prefixed macro equivalent. These APIs include:\nref\n->$ref\ncomputed\n->$computed\nshallowRef\n->$shallowRef\ncustomRef\n->$customRef\ntoRef\n->$toRef\nThese macros are globally available and do not need to be imported when Reactivity Transform is enabled, but you can optionally import them from vue/macros\nif you want to be more explicit:\njs\nimport { $ref } from 'vue/macros'\nlet count = $ref(0)\nDestructuring with $()\nIt is common for a composition function to return an object of refs, and use destructuring to retrieve these refs. For this purpose, reactivity transform provides the $()\nmacro:\njs\nimport { useMouse } from '@vueuse/core'\nconst { x, y } = $(useMouse())\nconsole.log(x, y)\nCompiled output:\njs\nimport { toRef } from 'vue'\nimport { useMouse } from '@vueuse/core'\nconst __temp = useMouse(),\nx = toRef(__temp, 'x'),\ny = toRef(__temp, 'y')\nconsole.log(x.value, y.value)\nNote that if x\nis already a ref, toRef(__temp, 'x')\nwill simply return it as-is and no additional ref will be created. If a destructured value is not a ref (e.g. a function), it will still work - the value will be wrapped in a ref so the rest of the code works as expected.\n$()\ndestructure works on both reactive objects and plain objects containing refs.\nConvert Existing Refs to Reactive Variables with $()\nIn some cases we may have wrapped functions that also return refs. However, the Vue compiler won't be able to know ahead of time that a function is going to return a ref. In such cases, the $()\nmacro can also be used to convert any existing refs into reactive variables:\njs\nfunction myCreateRef() {\nreturn ref(0)\n}\nlet count = $(myCreateRef())\nReactive Props Destructure\nThere are two pain points with the current defineProps()\nusage in <script setup>\n:\nSimilar to\n.value\n, you need to always access props asprops.x\nin order to retain reactivity. This means you cannot destructuredefineProps\nbecause the resulting destructured variables are not reactive and will not update.When using the type-only props declaration, there is no easy way to declare default values for the props. We introduced the\nwithDefaults()\nAPI for this exact purpose, but it's still clunky to use.\nWe can address these issues by applying a compile-time transform when defineProps\nis used with destructuring, similar to what we saw earlier with $()\n:\nhtml\n<script setup lang=\"ts\">\ninterface Props {\nmsg: string\ncount?: number\nfoo?: string\n}\nconst {\nmsg,\n// default value just works\ncount = 1,\n// local aliasing also just works\n// here we are aliasing `props.foo` to `bar`\nfoo: bar\n} = defineProps<Props>()\nwatchEffect(() => {\n// will log whenever the props change\nconsole.log(msg, count, bar)\n})\n</script>\nThe above will be compiled into the following runtime declaration equivalent:\njs\nexport default {\nprops: {\nmsg: { type: String, required: true },\ncount: { type: Number, default: 1 },\nfoo: String\n},\nsetup(props) {\nwatchEffect(() => {\nconsole.log(props.msg, props.count, props.foo)\n})\n}\n}\nRetaining Reactivity Across Function Boundaries\nWhile reactive variables relieve us from having to use .value\neverywhere, it creates an issue of \"reactivity loss\" when we pass reactive variables across function boundaries. This can happen in two cases:\nPassing into function as argument\nGiven a function that expects a ref as an argument, e.g.:\nts\nfunction trackChange(x: Ref<number>) {\nwatch(x, (x) => {\nconsole.log('x changed!')\n})\n}\nlet count = $ref(0)\ntrackChange(count) // doesn't work!\nThe above case will not work as expected because it compiles to:\nts\nlet count = ref(0)\ntrackChange(count.value)\nHere count.value\nis passed as a number, whereas trackChange\nexpects an actual ref. This can be fixed by wrapping count\nwith $$()\nbefore passing it:\ndiff\nlet count = $ref(0)\n- trackChange(count)\n+ trackChange($$(count))\nThe above compiles to:\njs\nimport { ref } from 'vue'\nlet count = ref(0)\ntrackChange(count)\nAs we can see, $$()\nis a macro that serves as an escape hint: reactive variables inside $$()\nwill not get .value\nappended.\nReturning inside function scope\nReactivity can also be lost if reactive variables are used directly in a returned expression:\nts\nfunction useMouse() {\nlet x = $ref(0)\nlet y = $ref(0)\n// listen to mousemove...\n// doesn't work!\nreturn {\nx,\ny\n}\n}\nThe above return statement compiles to:\nts\nreturn {\nx: x.value,\ny: y.value\n}\nIn order to retain reactivity, we should be returning the actual refs, not the current value at return time.\nAgain, we can use $$()\nto fix this. In this case, $$()\ncan be used directly on the returned object - any reference to reactive variables inside the $$()\ncall will retain the reference to their underlying refs:\nts\nfunction useMouse() {\nlet x = $ref(0)\nlet y = $ref(0)\n// listen to mousemove...\n// fixed\nreturn $$({\nx,\ny\n})\n}\nUsing $$()\non destructured props\n$$()\nworks on destructured props since they are reactive variables as well. The compiler will convert it with toRef\nfor efficiency:\nts\nconst { count } = defineProps<{ count: number }>()\npassAsRef($$(count))\ncompiles to:\njs\nsetup(props) {\nconst __props_count = toRef(props, 'count')\npassAsRef(__props_count)\n}\nTypeScript Integration\nVue provides typings for these macros (available globally) and all types will work as expected. There are no incompatibilities with standard TypeScript semantics, so the syntax will work with all existing tooling.\nThis also means the macros can work in any files where valid JS / TS are allowed - not just inside Vue SFCs.\nSince the macros are available globally, their types need to be explicitly referenced (e.g. in a env.d.ts\nfile):\nts\n/// <reference types=\"vue/macros-global\" />\nWhen explicitly importing the macros from vue/macros\n, the type will work without declaring the globals.\nExplicit Opt-in\nNo longer supported in core\nThe following only applies up to Vue version 3.3 and below. Support has been removed in Vue core 3.4 and above, and @vitejs/plugin-vue\n5.0 and above. If you intend to continue using the transform, please migrate to Vue Macros instead.\nVite\n- Requires\n@vitejs/plugin-vue@>=2.0.0\n- Applies to SFCs and js(x)/ts(x) files. A fast usage check is performed on files before applying the transform so there should be no performance cost for files not using the macros.\n- Note\nreactivityTransform\nis now a plugin root-level option instead of nested asscript.refSugar\n, since it affects not just SFCs.\njs\n// vite.config.js\nexport default {\nplugins: [\nvue({\nreactivityTransform: true\n})\n]\n}\nvue-cli\n- Currently only affects SFCs\n- Requires\nvue-loader@>=17.0.0\njs\n// vue.config.js\nmodule.exports = {\nchainWebpack: (config) => {\nconfig.module\n.rule('vue')\n.use('vue-loader')\n.tap((options) => {\nreturn {\n...options,\nreactivityTransform: true\n}\n})\n}\n}\nPlain webpack\n+ vue-loader\n- Currently only affects SFCs\n- Requires\nvue-loader@>=17.0.0\njs\n// webpack.config.js\nmodule.exports = {\nmodule: {\nrules: [\n{\ntest: /\\.vue$/,\nloader: 'vue-loader',\noptions: {\nreactivityTransform: true\n}\n}\n]\n}\n}",
    "metadata": {
      "source": "https://vuejs.org/guide/extras/reactivity-transform",
      "title": "Reactivity Transform | Vue.js"
    }
  },
  {
    "page_content": "Testing\nWhy Test?\nAutomated tests help you and your team build complex Vue applications quickly and confidently by preventing regressions and encouraging you to break apart your application into testable functions, modules, classes, and components. As with any application, your new Vue app can break in many ways, and it's important that you can catch these issues and fix them before releasing.\nIn this guide, we'll cover basic terminology and provide our recommendations on which tools to choose for your Vue 3 application.\nThere is one Vue-specific section covering composables. See Testing Composables below for more details.\nWhen to Test\nStart testing early! We recommend you begin writing tests as soon as you can. The longer you wait to add tests to your application, the more dependencies your application will have, and the harder it will be to start.\nTesting Types\nWhen designing your Vue application's testing strategy, you should leverage the following testing types:\n- Unit: Checks that inputs to a given function, class, or composable are producing the expected output or side effects.\n- Component: Checks that your component mounts, renders, can be interacted with, and behaves as expected. These tests import more code than unit tests, are more complex, and require more time to execute.\n- End-to-end: Checks features that span multiple pages and makes real network requests against your production-built Vue application. These tests often involve standing up a database or other backend.\nEach testing type plays a role in your application's testing strategy, and each will protect you against different types of issues.\nOverview\nWe will briefly discuss what each of these are, how they can be implemented for Vue applications, and provide some general recommendations.\nUnit Testing\nUnit tests are written to verify that small, isolated units of code are working as expected. A unit test usually covers a single function, class, composable, or module. Unit tests focus on logical correctness and only concern themselves with a small portion of the application's overall functionality. They may mock large parts of your application's environment (e.g. initial state, complex classes, 3rd party modules, and network requests).\nIn general, unit tests will catch issues with a function's business logic and logical correctness.\nTake for example this increment\nfunction:\njs\n// helpers.js\nexport function increment (current, max = 10) {\nif (current < max) {\nreturn current + 1\n}\nreturn current\n}\nBecause it's very self-contained, it'll be easy to invoke the increment function and assert that it returns what it's supposed to, so we'll write a Unit Test.\nIf any of these assertions fail, it's clear that the issue is contained within the increment\nfunction.\njs\n// helpers.spec.js\nimport { increment } from './helpers'\ndescribe('increment', () => {\ntest('increments the current number by 1', () => {\nexpect(increment(0, 10)).toBe(1)\n})\ntest('does not increment the current number over the max', () => {\nexpect(increment(10, 10)).toBe(10)\n})\ntest('has a default max of 10', () => {\nexpect(increment(10)).toBe(10)\n})\n})\nAs mentioned previously, unit testing is typically applied to self-contained business logic, components, classes, modules, or functions that do not involve UI rendering, network requests, or other environmental concerns.\nThese are typically plain JavaScript / TypeScript modules unrelated to Vue. In general, writing unit tests for business logic in Vue applications does not differ significantly from applications using other frameworks.\nThere are two instances where you DO unit test Vue-specific features:\n- Composables\n- Components\nComposables\nOne category of functions specific to Vue applications is Composables, which may require special handling during tests. See Testing Composables below for more details.\nUnit Testing Components\nA component can be tested in two ways:\nWhitebox: Unit Testing\nTests that are \"Whitebox tests\" are aware of the implementation details and dependencies of a component. They are focused on isolating the component under test. These tests will usually involve mocking some, if not all of your component's children, as well as setting up plugin state and dependencies (e.g. Pinia).\nBlackbox: Component Testing\nTests that are \"Blackbox tests\" are unaware of the implementation details of a component. These tests mock as little as possible to test the integration of your component and the entire system. They usually render all child components and are considered more of an \"integration test\". See the Component Testing recommendations below.\nRecommendation\nSince the official setup created by\ncreate-vue\nis based on Vite, we recommend using a unit testing framework that can leverage the same configuration and transform pipeline directly from Vite. Vitest is a unit testing framework designed specifically for this purpose, created and maintained by Vue / Vite team members. It integrates with Vite-based projects with minimal effort, and is blazing fast.\nOther Options\n- Jest is a popular unit testing framework. However, we only recommend Jest if you have an existing Jest test suite that needs to be migrated over to a Vite-based project, as Vitest offers a more seamless integration and better performance.\nComponent Testing\nIn Vue applications, components are the main building blocks of the UI. Components are therefore the natural unit of isolation when it comes to validating your application's behavior. From a granularity perspective, component testing sits somewhere above unit testing and can be considered a form of integration testing. Much of your Vue Application should be covered by a component test and we recommend that each Vue component has its own spec file.\nComponent tests should catch issues relating to your component's props, events, slots that it provides, styles, classes, lifecycle hooks, and more.\nComponent tests should not mock child components, but instead test the interactions between your component and its children by interacting with the components as a user would. For example, a component test should click on an element like a user would instead of programmatically interacting with the component.\nComponent tests should focus on the component's public interfaces rather than internal implementation details. For most components, the public interface is limited to: events emitted, props, and slots. When testing, remember to test what a component does, not how it does it.\nDO\nFor Visual logic: assert correct render output based on inputted props and slots.\nFor Behavioral logic: assert correct render updates or emitted events in response to user input events.\nIn the below example, we demonstrate a Stepper component that has a DOM element labeled \"increment\" and can be clicked. We pass a prop called\nmax\nthat prevents the Stepper from being incremented past2\n, so if we click the button 3 times, the UI should still say2\n.We know nothing about the implementation of Stepper, only that the \"input\" is the\nmax\nprop and the \"output\" is the state of the DOM as the user will see it.\nVue Test Utils\nCypress\nTesting Library\njs\nconst valueSelector = '[data-testid=stepper-value]'\nconst buttonSelector = '[data-testid=increment]'\nconst wrapper = mount(Stepper, {\nprops: {\nmax: 1\n}\n})\nexpect(wrapper.find(valueSelector).text()).toContain('0')\nawait wrapper.find(buttonSelector).trigger('click')\nexpect(wrapper.find(valueSelector).text()).toContain('1')\nDON'T\nDon't assert the private state of a component instance or test the private methods of a component. Testing implementation details makes the tests brittle, as they are more likely to break and require updates when the implementation changes.\nThe component's ultimate job is rendering the correct DOM output, so tests focusing on the DOM output provide the same level of correctness assurance (if not more) while being more robust and resilient to change.\nDon't rely exclusively on snapshot tests. Asserting HTML strings does not describe correctness. Write tests with intentionality.\nIf a method needs to be tested thoroughly, consider extracting it into a standalone utility function and write a dedicated unit test for it. If it cannot be extracted cleanly, it may be tested as a part of a component, integration, or end-to-end test that covers it.\nRecommendation\nVitest for components or composables that render headlessly (e.g. the\nuseFavicon\nfunction in VueUse). Components and DOM can be tested using@vue/test-utils\n.Cypress Component Testing for components whose expected behavior depends on properly rendering styles or triggering native DOM events. It can be used with Testing Library via @testing-library/cypress.\nThe main differences between Vitest and browser-based runners are speed and execution context. In short, browser-based runners, like Cypress, can catch issues that node-based runners, like Vitest, cannot (e.g. style issues, real native DOM events, cookies, local storage, and network failures), but browser-based runners are orders of magnitude slower than Vitest because they do open a browser, compile your stylesheets, and more. Cypress is a browser-based runner that supports component testing. Please read Vitest's comparison page for the latest information comparing Vitest and Cypress.\nMounting Libraries\nComponent testing often involves mounting the component being tested in isolation, triggering simulated user input events, and asserting on the rendered DOM output. There are dedicated utility libraries that make these tasks simpler.\n@vue/test-utils\nis the official low-level component testing library that was written to provide users access to Vue specific APIs. It's also the lower-level library@testing-library/vue\nis built on top of.@testing-library/vue\nis a Vue testing library focused on testing components without relying on implementation details. Its guiding principle is that the more tests resemble the way software is used, the more confidence they can provide.\nWe recommend using @vue/test-utils\nfor testing components in applications. @testing-library/vue\nhas issues with testing asynchronous component with Suspense, so it should be used with caution.\nOther Options\nNightwatch is an E2E test runner with Vue Component Testing support. (Example Project)\nWebdriverIO for cross-browser component testing that relies on native user interaction based on standardized automation. It can also be used with Testing Library.\nE2E Testing\nWhile unit tests provide developers with some degree of confidence, unit and component tests are limited in their abilities to provide holistic coverage of an application when deployed to production. As a result, end-to-end (E2E) tests provide coverage on what is arguably the most important aspect of an application: what happens when users actually use your applications.\nEnd-to-end tests focus on multi-page application behavior that makes network requests against your production-built Vue application. They often involve standing up a database or other backend and may even be run against a live staging environment.\nEnd-to-end tests will often catch issues with your router, state management library, top-level components (e.g. an App or Layout), public assets, or any request handling. As stated above, they catch critical issues that may be impossible to catch with unit tests or component tests.\nEnd-to-end tests do not import any of your Vue application's code but instead rely completely on testing your application by navigating through entire pages in a real browser.\nEnd-to-end tests validate many of the layers in your application. They can either target your locally built application or even a live Staging environment. Testing against your Staging environment not only includes your frontend code and static server but all associated backend services and infrastructure.\nThe more your tests resemble how your software is used, the more confidence they can give you. - Kent C. Dodds - Author of the Testing Library\nBy testing how user actions impact your application, E2E tests are often the key to higher confidence in whether an application is functioning properly or not.\nChoosing an E2E Testing Solution\nWhile end-to-end (E2E) testing on the web has gained a negative reputation for unreliable (flaky) tests and slowing down development processes, modern E2E tools have made strides forward to create more reliable, interactive, and useful tests. When choosing an E2E testing framework, the following sections provide some guidance on things to keep in mind when choosing a testing framework for your application.\nCross-browser testing\nOne of the primary benefits that end-to-end (E2E) testing is known for is its ability to test your application across multiple browsers. While it may seem desirable to have 100% cross-browser coverage, it is important to note that cross browser testing has diminishing returns on a team's resources due to the additional time and machine power required to run them consistently. As a result, it is important to be mindful of this trade-off when choosing the amount of cross-browser testing your application needs.\nFaster feedback loops\nOne of the primary problems with end-to-end (E2E) tests and development is that running the entire suite takes a long time. Typically, this is only done in continuous integration and deployment (CI/CD) pipelines. Modern E2E testing frameworks have helped to solve this by adding features like parallelization, which allows for CI/CD pipelines to often run magnitudes faster than before. In addition, when developing locally, the ability to selectively run a single test for the page you are working on while also providing hot reloading of tests can help boost a developer's workflow and productivity.\nFirst-class debugging experience\nWhile developers have traditionally relied on scanning logs in a terminal window to help determine what went wrong in a test, modern end-to-end (E2E) test frameworks allow developers to leverage tools they are already familiar with, e.g. browser developer tools.\nVisibility in headless mode\nWhen end-to-end (E2E) tests are run in continuous integration/deployment pipelines, they are often run in headless browsers (i.e., no visible browser is opened for the user to watch). A critical feature of modern E2E testing frameworks is the ability to see snapshots and/or videos of the application during testing, providing some insight into why errors are happening. Historically, it was tedious to maintain these integrations.\nRecommendation\nOverall, we believe Cypress provides the most complete E2E solution with features like an informative graphical interface, excellent debuggability, built-in assertions, stubs, flake-resistance, parallelization, and snapshots. As mentioned above, it also provides support for Component Testing. It supports Chromium-based browsers, Firefox, and Electron. WebKit support is available, but marked experimental.\nOther Options\nPlaywright is also a great E2E testing solution that supports all modern rendering engines including Chromium, WebKit, and Firefox. Test on Windows, Linux, and macOS, locally or on CI, headless or headed with native mobile emulation of Google Chrome for Android and Mobile Safari.\nNightwatch is an E2E testing solution based on Selenium WebDriver. This gives it the widest browser support range, including native mobile testing. Selenium-based solutions will be slower than Playwright or Cypress.\nWebdriverIO is a test automation framework for web and mobile testing based on the WebDriver protocol.\nRecipes\nAdding Vitest to a Project\nIn a Vite-based Vue project, run:\nsh\n> npm install -D vitest happy-dom @testing-library/vue\nNext, update the Vite configuration to add the test\noption block:\njs\n// vite.config.js\nimport { defineConfig } from 'vite'\nexport default defineConfig({\n// ...\ntest: {\n// enable jest-like global test APIs\nglobals: true,\n// simulate DOM with happy-dom\n// (requires installing happy-dom as a peer dependency)\nenvironment: 'happy-dom'\n}\n})\nTIP\nIf you use TypeScript, add vitest/globals\nto the types\nfield in your tsconfig.json\n.\njson\n// tsconfig.json\n{\n\"compilerOptions\": {\n\"types\": [\"vitest/globals\"]\n}\n}\nThen, create a file ending in *.test.js\nin your project. You can place all test files in a test directory in the project root or in test directories next to your source files. Vitest will automatically search for them using the naming convention.\njs\n// MyComponent.test.js\nimport { render } from '@testing-library/vue'\nimport MyComponent from './MyComponent.vue'\ntest('it should work', () => {\nconst { getByText } = render(MyComponent, {\nprops: {\n/* ... */\n}\n})\n// assert output\ngetByText('...')\n})\nFinally, update package.json\nto add the test script and run it:\njson\n{\n// ...\n\"scripts\": {\n\"test\": \"vitest\"\n}\n}\nsh\n> npm test\nTesting Composables\nThis section assumes you have read the Composables section.\nWhen it comes to testing composables, we can divide them into two categories: composables that do not rely on a host component instance, and composables that do.\nA composable depends on a host component instance when it uses the following APIs:\n- Lifecycle hooks\n- Provide / Inject\nIf a composable only uses Reactivity APIs, then it can be tested by directly invoking it and asserting its returned state/methods:\njs\n// counter.js\nimport { ref } from 'vue'\nexport function useCounter() {\nconst count = ref(0)\nconst increment = () => count.value++\nreturn {\ncount,\nincrement\n}\n}\njs\n// counter.test.js\nimport { useCounter } from './counter.js'\ntest('useCounter', () => {\nconst { count, increment } = useCounter()\nexpect(count.value).toBe(0)\nincrement()\nexpect(count.value).toBe(1)\n})\nA composable that relies on lifecycle hooks or Provide / Inject needs to be wrapped in a host component to be tested. We can create a helper like the following:\njs\n// test-utils.js\nimport { createApp } from 'vue'\nexport function withSetup(composable) {\nlet result\nconst app = createApp({\nsetup() {\nresult = composable()\n// suppress missing template warning\nreturn () => {}\n}\n})\napp.mount(document.createElement('div'))\n// return the result and the app instance\n// for testing provide/unmount\nreturn [result, app]\n}\njs\nimport { withSetup } from './test-utils'\nimport { useFoo } from './foo'\ntest('useFoo', () => {\nconst [result, app] = withSetup(() => useFoo(123))\n// mock provide for testing injections\napp.provide(...)\n// run assertions\nexpect(result.foo.value).toBe(1)\n// trigger onUnmounted hook if needed\napp.unmount()\n})\nFor more complex composables, it could also be easier to test it by writing tests against the wrapper component using Component Testing techniques.",
    "metadata": {
      "source": "https://vuejs.org/guide/scaling-up/testing",
      "title": "Testing | Vue.js"
    }
  },
  {
    "page_content": "Composables\nTIP\nThis section assumes basic knowledge of Composition API. If you have been learning Vue with Options API only, you can set the API Preference to Composition API (using the toggle at the top of the left sidebar) and re-read the Reactivity Fundamentals and Lifecycle Hooks chapters.\nWhat is a \"Composable\"?\nIn the context of Vue applications, a \"composable\" is a function that leverages Vue's Composition API to encapsulate and reuse stateful logic.\nWhen building frontend applications, we often need to reuse logic for common tasks. For example, we may need to format dates in many places, so we extract a reusable function for that. This formatter function encapsulates stateless logic: it takes some input and immediately returns expected output. There are many libraries out there for reusing stateless logic - for example lodash and date-fns, which you may have heard of.\nBy contrast, stateful logic involves managing state that changes over time. A simple example would be tracking the current position of the mouse on a page. In real-world scenarios, it could also be more complex logic such as touch gestures or connection status to a database.\nMouse Tracker Example\nIf we were to implement the mouse tracking functionality using the Composition API directly inside a component, it would look like this:\nvue\n<script setup>\nimport { ref, onMounted, onUnmounted } from 'vue'\nconst x = ref(0)\nconst y = ref(0)\nfunction update(event) {\nx.value = event.pageX\ny.value = event.pageY\n}\nonMounted(() => window.addEventListener('mousemove', update))\nonUnmounted(() => window.removeEventListener('mousemove', update))\n</script>\n<template>Mouse position is at: {{ x }}, {{ y }}</template>\nBut what if we want to reuse the same logic in multiple components? We can extract the logic into an external file, as a composable function:\njs\n// mouse.js\nimport { ref, onMounted, onUnmounted } from 'vue'\n// by convention, composable function names start with \"use\"\nexport function useMouse() {\n// state encapsulated and managed by the composable\nconst x = ref(0)\nconst y = ref(0)\n// a composable can update its managed state over time.\nfunction update(event) {\nx.value = event.pageX\ny.value = event.pageY\n}\n// a composable can also hook into its owner component's\n// lifecycle to setup and teardown side effects.\nonMounted(() => window.addEventListener('mousemove', update))\nonUnmounted(() => window.removeEventListener('mousemove', update))\n// expose managed state as return value\nreturn { x, y }\n}\nAnd this is how it can be used in components:\nvue\n<script setup>\nimport { useMouse } from './mouse.js'\nconst { x, y } = useMouse()\n</script>\n<template>Mouse position is at: {{ x }}, {{ y }}</template>\nMouse position is at: 0, 0\nAs we can see, the core logic remains identical - all we had to do was move it into an external function and return the state that should be exposed. Just like inside a component, you can use the full range of Composition API functions in composables. The same useMouse()\nfunctionality can now be used in any component.\nThe cooler part about composables though, is that you can also nest them: one composable function can call one or more other composable functions. This enables us to compose complex logic using small, isolated units, similar to how we compose an entire application using components. In fact, this is why we decided to call the collection of APIs that make this pattern possible Composition API.\nFor example, we can extract the logic of adding and removing a DOM event listener into its own composable:\njs\n// event.js\nimport { onMounted, onUnmounted } from 'vue'\nexport function useEventListener(target, event, callback) {\n// if you want, you can also make this\n// support selector strings as target\nonMounted(() => target.addEventListener(event, callback))\nonUnmounted(() => target.removeEventListener(event, callback))\n}\nAnd now our useMouse()\ncomposable can be simplified to:\njs\n// mouse.js\nimport { ref } from 'vue'\nimport { useEventListener } from './event'\nexport function useMouse() {\nconst x = ref(0)\nconst y = ref(0)\nuseEventListener(window, 'mousemove', (event) => {\nx.value = event.pageX\ny.value = event.pageY\n})\nreturn { x, y }\n}\nTIP\nEach component instance calling useMouse()\nwill create its own copies of x\nand y\nstate so they won't interfere with one another. If you want to manage shared state between components, read the State Management chapter.\nAsync State Example\nThe useMouse()\ncomposable doesn't take any arguments, so let's take a look at another example that makes use of one. When doing async data fetching, we often need to handle different states: loading, success, and error:\nvue\n<script setup>\nimport { ref } from 'vue'\nconst data = ref(null)\nconst error = ref(null)\nfetch('...')\n.then((res) => res.json())\n.then((json) => (data.value = json))\n.catch((err) => (error.value = err))\n</script>\n<template>\n<div v-if=\"error\">Oops! Error encountered: {{ error.message }}</div>\n<div v-else-if=\"data\">\nData loaded:\n<pre>{{ data }}</pre>\n</div>\n<div v-else>Loading...</div>\n</template>\nIt would be tedious to have to repeat this pattern in every component that needs to fetch data. Let's extract it into a composable:\njs\n// fetch.js\nimport { ref } from 'vue'\nexport function useFetch(url) {\nconst data = ref(null)\nconst error = ref(null)\nfetch(url)\n.then((res) => res.json())\n.then((json) => (data.value = json))\n.catch((err) => (error.value = err))\nreturn { data, error }\n}\nNow in our component we can just do:\nvue\n<script setup>\nimport { useFetch } from './fetch.js'\nconst { data, error } = useFetch('...')\n</script>\nAccepting Reactive State\nuseFetch()\ntakes a static URL string as input - so it performs the fetch only once and is then done. What if we want it to re-fetch whenever the URL changes? In order to achieve this, we need to pass reactive state into the composable function, and let the composable create watchers that perform actions using the passed state.\nFor example, useFetch()\nshould be able to accept a ref:\njs\nconst url = ref('/initial-url')\nconst { data, error } = useFetch(url)\n// this should trigger a re-fetch\nurl.value = '/new-url'\nOr, accept a getter function:\njs\n// re-fetch when props.id changes\nconst { data, error } = useFetch(() => `/posts/${props.id}`)\nWe can refactor our existing implementation with the watchEffect()\nand toValue()\nAPIs:\njs\n// fetch.js\nimport { ref, watchEffect, toValue } from 'vue'\nexport function useFetch(url) {\nconst data = ref(null)\nconst error = ref(null)\nconst fetchData = () => {\n// reset state before fetching..\ndata.value = null\nerror.value = null\nfetch(toValue(url))\n.then((res) => res.json())\n.then((json) => (data.value = json))\n.catch((err) => (error.value = err))\n}\nwatchEffect(() => {\nfetchData()\n})\nreturn { data, error }\n}\ntoValue()\nis an API added in 3.3. It is designed to normalize refs or getters into values. If the argument is a ref, it returns the ref's value; if the argument is a function, it will call the function and return its return value. Otherwise, it returns the argument as-is. It works similarly to unref()\n, but with special treatment for functions.\nNotice that toValue(url)\nis called inside the watchEffect\ncallback. This ensures that any reactive dependencies accessed during the toValue()\nnormalization are tracked by the watcher.\nThis version of useFetch()\nnow accepts static URL strings, refs, and getters, making it much more flexible. The watch effect will run immediately, and will track any dependencies accessed during toValue(url)\n. If no dependencies are tracked (e.g. url is already a string), the effect runs only once; otherwise, it will re-run whenever a tracked dependency changes.\nHere's the updated version of useFetch()\n, with an artificial delay and randomized error for demo purposes.\nConventions and Best Practices\nNaming\nIt is a convention to name composable functions with camelCase names that start with \"use\".\nInput Arguments\nA composable can accept ref or getter arguments even if it doesn't rely on them for reactivity. If you are writing a composable that may be used by other developers, it's a good idea to handle the case of input arguments being refs or getters instead of raw values. The toValue()\nutility function will come in handy for this purpose:\njs\nimport { toValue } from 'vue'\nfunction useFeature(maybeRefOrGetter) {\n// If maybeRefOrGetter is a ref or a getter,\n// its normalized value will be returned.\n// Otherwise, it is returned as-is.\nconst value = toValue(maybeRefOrGetter)\n}\nIf your composable creates reactive effects when the input is a ref or a getter, make sure to either explicitly watch the ref / getter with watch()\n, or call toValue()\ninside a watchEffect()\nso that it is properly tracked.\nThe useFetch() implementation discussed earlier provides a concrete example of a composable that accepts refs, getters and plain values as input argument.\nReturn Values\nYou have probably noticed that we have been exclusively using ref()\ninstead of reactive()\nin composables. The recommended convention is for composables to always return a plain, non-reactive object containing multiple refs. This allows it to be destructured in components while retaining reactivity:\njs\n// x and y are refs\nconst { x, y } = useMouse()\nReturning a reactive object from a composable will cause such destructures to lose the reactivity connection to the state inside the composable, while the refs will retain that connection.\nIf you prefer to use returned state from composables as object properties, you can wrap the returned object with reactive()\nso that the refs are unwrapped. For example:\njs\nconst mouse = reactive(useMouse())\n// mouse.x is linked to original ref\nconsole.log(mouse.x)\ntemplate\nMouse position is at: {{ mouse.x }}, {{ mouse.y }}\nSide Effects\nIt is OK to perform side effects (e.g. adding DOM event listeners or fetching data) in composables, but pay attention to the following rules:\nIf you are working on an application that uses Server-Side Rendering (SSR), make sure to perform DOM-specific side effects in post-mount lifecycle hooks, e.g.\nonMounted()\n. These hooks are only called in the browser, so you can be sure that code inside them has access to the DOM.Remember to clean up side effects in\nonUnmounted()\n. For example, if a composable sets up a DOM event listener, it should remove that listener inonUnmounted()\nas we have seen in theuseMouse()\nexample. It can be a good idea to use a composable that automatically does this for you, like theuseEventListener()\nexample.\nUsage Restrictions\nComposables should only be called in <script setup>\nor the setup()\nhook. They should also be called synchronously in these contexts. In some cases, you can also call them in lifecycle hooks like onMounted()\n.\nThese restrictions are important because these are the contexts where Vue is able to determine the current active component instance. Access to an active component instance is necessary so that:\nLifecycle hooks can be registered to it.\nComputed properties and watchers can be linked to it, so that they can be disposed when the instance is unmounted to prevent memory leaks.\nTIP\n<script setup>\nis the only place where you can call composables after using await\n. The compiler automatically restores the active instance context for you after the async operation.\nExtracting Composables for Code Organization\nComposables can be extracted not only for reuse, but also for code organization. As the complexity of your components grow, you may end up with components that are too large to navigate and reason about. Composition API gives you the full flexibility to organize your component code into smaller functions based on logical concerns:\nvue\n<script setup>\nimport { useFeatureA } from './featureA.js'\nimport { useFeatureB } from './featureB.js'\nimport { useFeatureC } from './featureC.js'\nconst { foo, bar } = useFeatureA()\nconst { baz } = useFeatureB(foo)\nconst { qux } = useFeatureC(baz)\n</script>\nTo some extent, you can think of these extracted composables as component-scoped services that can talk to one another.\nUsing Composables in Options API\nIf you are using Options API, composables must be called inside setup()\n, and the returned bindings must be returned from setup()\nso that they are exposed to this\nand the template:\njs\nimport { useMouse } from './mouse.js'\nimport { useFetch } from './fetch.js'\nexport default {\nsetup() {\nconst { x, y } = useMouse()\nconst { data, error } = useFetch('...')\nreturn { x, y, data, error }\n},\nmounted() {\n// setup() exposed properties can be accessed on `this`\nconsole.log(this.x)\n}\n// ...other options\n}\nComparisons with Other Techniques\nvs. Mixins\nUsers coming from Vue 2 may be familiar with the mixins option, which also allows us to extract component logic into reusable units. There are three primary drawbacks to mixins:\nUnclear source of properties: when using many mixins, it becomes unclear which instance property is injected by which mixin, making it difficult to trace the implementation and understand the component's behavior. This is also why we recommend using the refs + destructure pattern for composables: it makes the property source clear in consuming components.\nNamespace collisions: multiple mixins from different authors can potentially register the same property keys, causing namespace collisions. With composables, you can rename the destructured variables if there are conflicting keys from different composables.\nImplicit cross-mixin communication: multiple mixins that need to interact with one another have to rely on shared property keys, making them implicitly coupled. With composables, values returned from one composable can be passed into another as arguments, just like normal functions.\nFor the above reasons, we no longer recommend using mixins in Vue 3. The feature is kept only for migration and familiarity reasons.\nvs. Renderless Components\nIn the component slots chapter, we discussed the Renderless Component pattern based on scoped slots. We even implemented the same mouse tracking demo using renderless components.\nThe main advantage of composables over renderless components is that composables do not incur the extra component instance overhead. When used across an entire application, the amount of extra component instances created by the renderless component pattern can become a noticeable performance overhead.\nThe recommendation is to use composables when reusing pure logic, and use components when reusing both logic and visual layout.\nvs. React Hooks\nIf you have experience with React, you may notice that this looks very similar to custom React hooks. Composition API was in part inspired by React hooks, and Vue composables are indeed similar to React hooks in terms of logic composition capabilities. However, Vue composables are based on Vue's fine-grained reactivity system, which is fundamentally different from React hooks' execution model. This is discussed in more detail in the Composition API FAQ.\nFurther Reading\n- Reactivity In Depth: for a low-level understanding of how Vue's reactivity system works.\n- State Management: for patterns of managing state shared by multiple components.\n- Testing Composables: tips on unit testing composables.\n- VueUse: an ever-growing collection of Vue composables. The source code is also a great learning resource.",
    "metadata": {
      "source": "https://vuejs.org/guide/reusability/composables",
      "title": "Composables | Vue.js"
    }
  },
  {
    "page_content": "Reactivity in Depth\nOne of Vue’s most distinctive features is the unobtrusive reactivity system. Component state consists of reactive JavaScript objects. When you modify them, the view updates. It makes state management simple and intuitive, but it’s also important to understand how it works to avoid some common gotchas. In this section, we are going to dig into some of the lower-level details of Vue’s reactivity system.\nWhat is Reactivity?\nThis term comes up in programming quite a bit these days, but what do people mean when they say it? Reactivity is a programming paradigm that allows us to adjust to changes in a declarative manner. The canonical example that people usually show, because it’s a great one, is an Excel spreadsheet:\nA | B | C | |\n---|---|---|---|\n0 | 1 | ||\n1 | 2 | ||\n2 | 3 |\nHere cell A2 is defined via a formula of = A0 + A1\n(you can click on A2 to view or edit the formula), so the spreadsheet gives us 3. No surprises there. But if you update A0 or A1, you'll notice that A2 automagically updates too.\nJavaScript doesn’t usually work like this. If we were to write something comparable in JavaScript:\njs\nlet A0 = 1\nlet A1 = 2\nlet A2 = A0 + A1\nconsole.log(A2) // 3\nA0 = 2\nconsole.log(A2) // Still 3\nWhen we mutate A0\n, A2\ndoes not change automatically.\nSo how would we do this in JavaScript? First, in order to re-run the code that updates A2\n, let's wrap it in a function:\njs\nlet A2\nfunction update() {\nA2 = A0 + A1\n}\nThen, we need to define a few terms:\nThe\nupdate()\nfunction produces a side effect, or effect for short, because it modifies the state of the program.A0\nandA1\nare considered dependencies of the effect, as their values are used to perform the effect. The effect is said to be a subscriber to its dependencies.\nWhat we need is a magic function that can invoke update()\n(the effect) whenever A0\nor A1\n(the dependencies) change:\njs\nwhenDepsChange(update)\nThis whenDepsChange()\nfunction has the following tasks:\nTrack when a variable is read. E.g. when evaluating the expression\nA0 + A1\n, bothA0\nandA1\nare read.If a variable is read when there is a currently running effect, make that effect a subscriber to that variable. E.g. because\nA0\nandA1\nare read whenupdate()\nis being executed,update()\nbecomes a subscriber to bothA0\nandA1\nafter the first call.Detect when a variable is mutated. E.g. when\nA0\nis assigned a new value, notify all its subscriber effects to re-run.\nHow Reactivity Works in Vue\nWe can't really track the reading and writing of local variables like in the example. There's just no mechanism for doing that in vanilla JavaScript. What we can do though, is intercept the reading and writing of object properties.\nThere are two ways of intercepting property access in JavaScript: getter / setters and Proxies. Vue 2 used getter / setters exclusively due to browser support limitations. In Vue 3, Proxies are used for reactive objects and getter / setters are used for refs. Here's some pseudo-code that illustrates how they work:\njs\nfunction reactive(obj) {\nreturn new Proxy(obj, {\nget(target, key) {\ntrack(target, key)\nreturn target[key]\n},\nset(target, key, value) {\ntarget[key] = value\ntrigger(target, key)\n}\n})\n}\nfunction ref(value) {\nconst refObject = {\nget value() {\ntrack(refObject, 'value')\nreturn value\n},\nset value(newValue) {\nvalue = newValue\ntrigger(refObject, 'value')\n}\n}\nreturn refObject\n}\nTIP\nCode snippets here and below are meant to explain the core concepts in the simplest form possible, so many details are omitted, and edge cases ignored.\nThis explains a few limitations of reactive objects that we have discussed in the fundamentals section:\nWhen you assign or destructure a reactive object's property to a local variable, accessing or assigning to that variable is non-reactive because it no longer triggers the get / set proxy traps on the source object. Note this \"disconnect\" only affects the variable binding - if the variable points to a non-primitive value such as an object, mutating the object would still be reactive.\nThe returned proxy from\nreactive()\n, although behaving just like the original, has a different identity if we compare it to the original using the===\noperator.\nInside track()\n, we check whether there is a currently running effect. If there is one, we lookup the subscriber effects (stored in a Set) for the property being tracked, and add the effect to the Set:\njs\n// This will be set right before an effect is about\n// to be run. We'll deal with this later.\nlet activeEffect\nfunction track(target, key) {\nif (activeEffect) {\nconst effects = getSubscribersForProperty(target, key)\neffects.add(activeEffect)\n}\n}\nEffect subscriptions are stored in a global WeakMap<target, Map<key, Set<effect>>>\ndata structure. If no subscribing effects Set was found for a property (tracked for the first time), it will be created. This is what the getSubscribersForProperty()\nfunction does, in short. For simplicity, we will skip its details.\nInside trigger()\n, we again lookup the subscriber effects for the property. But this time we invoke them instead:\njs\nfunction trigger(target, key) {\nconst effects = getSubscribersForProperty(target, key)\neffects.forEach((effect) => effect())\n}\nNow let's circle back to the whenDepsChange()\nfunction:\njs\nfunction whenDepsChange(update) {\nconst effect = () => {\nactiveEffect = effect\nupdate()\nactiveEffect = null\n}\neffect()\n}\nIt wraps the raw update\nfunction in an effect that sets itself as the current active effect before running the actual update. This enables track()\ncalls during the update to locate the current active effect.\nAt this point, we have created an effect that automatically tracks its dependencies, and re-runs whenever a dependency changes. We call this a Reactive Effect.\nVue provides an API that allows you to create reactive effects: watchEffect()\n. In fact, you may have noticed that it works pretty similarly to the magical whenDepsChange()\nin the example. We can now rework the original example using actual Vue APIs:\njs\nimport { ref, watchEffect } from 'vue'\nconst A0 = ref(0)\nconst A1 = ref(1)\nconst A2 = ref()\nwatchEffect(() => {\n// tracks A0 and A1\nA2.value = A0.value + A1.value\n})\n// triggers the effect\nA0.value = 2\nUsing a reactive effect to mutate a ref isn't the most interesting use case - in fact, using a computed property makes it more declarative:\njs\nimport { ref, computed } from 'vue'\nconst A0 = ref(0)\nconst A1 = ref(1)\nconst A2 = computed(() => A0.value + A1.value)\nA0.value = 2\nInternally, computed\nmanages its invalidation and re-computation using a reactive effect.\nSo what's an example of a common and useful reactive effect? Well, updating the DOM! We can implement simple \"reactive rendering\" like this:\njs\nimport { ref, watchEffect } from 'vue'\nconst count = ref(0)\nwatchEffect(() => {\ndocument.body.innerHTML = `Count is: ${count.value}`\n})\n// updates the DOM\ncount.value++\nIn fact, this is pretty close to how a Vue component keeps the state and the DOM in sync - each component instance creates a reactive effect to render and update the DOM. Of course, Vue components use much more efficient ways to update the DOM than innerHTML\n. This is discussed in Rendering Mechanism.\nRuntime vs. Compile-time Reactivity\nVue's reactivity system is primarily runtime-based: the tracking and triggering are all performed while the code is running directly in the browser. The pros of runtime reactivity are that it can work without a build step, and there are fewer edge cases. On the other hand, this makes it constrained by the syntax limitations of JavaScript, leading to the need of value containers like Vue refs.\nSome frameworks, such as Svelte, choose to overcome such limitations by implementing reactivity during compilation. It analyzes and transforms the code in order to simulate reactivity. The compilation step allows the framework to alter the semantics of JavaScript itself - for example, implicitly injecting code that performs dependency analysis and effect triggering around access to locally defined variables. The downside is that such transforms require a build step, and altering JavaScript semantics is essentially creating a language that looks like JavaScript but compiles into something else.\nThe Vue team did explore this direction via an experimental feature called Reactivity Transform, but in the end we have decided that it would not be a good fit for the project due to the reasoning here.\nReactivity Debugging\nIt's great that Vue's reactivity system automatically tracks dependencies, but in some cases we may want to figure out exactly what is being tracked, or what is causing a component to re-render.\nComponent Debugging Hooks\nWe can debug what dependencies are used during a component's render and which dependency is triggering an update using the onRenderTracked\nand onRenderTriggered\nlifecycle hooks. Both hooks will receive a debugger event which contains information on the dependency in question. It is recommended to place a debugger\nstatement in the callbacks to interactively inspect the dependency:\nvue\n<script setup>\nimport { onRenderTracked, onRenderTriggered } from 'vue'\nonRenderTracked((event) => {\ndebugger\n})\nonRenderTriggered((event) => {\ndebugger\n})\n</script>\nTIP\nComponent debug hooks only work in development mode.\nThe debug event objects have the following type:\nts\ntype DebuggerEvent = {\neffect: ReactiveEffect\ntarget: object\ntype:\n| TrackOpTypes /* 'get' | 'has' | 'iterate' */\n| TriggerOpTypes /* 'set' | 'add' | 'delete' | 'clear' */\nkey: any\nnewValue?: any\noldValue?: any\noldTarget?: Map<any, any> | Set<any>\n}\nComputed Debugging\nWe can debug computed properties by passing computed()\na second options object with onTrack\nand onTrigger\ncallbacks:\nonTrack\nwill be called when a reactive property or ref is tracked as a dependency.onTrigger\nwill be called when the watcher callback is triggered by the mutation of a dependency.\nBoth callbacks will receive debugger events in the same format as component debug hooks:\njs\nconst plusOne = computed(() => count.value + 1, {\nonTrack(e) {\n// triggered when count.value is tracked as a dependency\ndebugger\n},\nonTrigger(e) {\n// triggered when count.value is mutated\ndebugger\n}\n})\n// access plusOne, should trigger onTrack\nconsole.log(plusOne.value)\n// mutate count.value, should trigger onTrigger\ncount.value++\nTIP\nonTrack\nand onTrigger\ncomputed options only work in development mode.\nWatcher Debugging\nSimilar to computed()\n, watchers also support the onTrack\nand onTrigger\noptions:\njs\nwatch(source, callback, {\nonTrack(e) {\ndebugger\n},\nonTrigger(e) {\ndebugger\n}\n})\nwatchEffect(callback, {\nonTrack(e) {\ndebugger\n},\nonTrigger(e) {\ndebugger\n}\n})\nTIP\nonTrack\nand onTrigger\nwatcher options only work in development mode.\nIntegration with External State Systems\nVue's reactivity system works by deeply converting plain JavaScript objects into reactive proxies. The deep conversion can be unnecessary or sometimes unwanted when integrating with external state management systems (e.g. if an external solution also uses Proxies).\nThe general idea of integrating Vue's reactivity system with an external state management solution is to hold the external state in a shallowRef\n. A shallow ref is only reactive when its .value\nproperty is accessed - the inner value is left intact. When the external state changes, replace the ref value to trigger updates.\nImmutable Data\nIf you are implementing an undo / redo feature, you likely want to take a snapshot of the application's state on every user edit. However, Vue's mutable reactivity system isn't best suited for this if the state tree is large, because serializing the entire state object on every update can be expensive in terms of both CPU and memory costs.\nImmutable data structures solve this by never mutating the state objects - instead, it creates new objects that share the same, unchanged parts with old ones. There are different ways of using immutable data in JavaScript, but we recommend using Immer with Vue because it allows you to use immutable data while keeping the more ergonomic, mutable syntax.\nWe can integrate Immer with Vue via a simple composable:\njs\nimport { produce } from 'immer'\nimport { shallowRef } from 'vue'\nexport function useImmer(baseState) {\nconst state = shallowRef(baseState)\nconst update = (updater) => {\nstate.value = produce(state.value, updater)\n}\nreturn [state, update]\n}\nState Machines\nState Machine is a model for describing all the possible states an application can be in, and all the possible ways it can transition from one state to another. While it may be overkill for simple components, it can help make complex state flows more robust and manageable.\nOne of the most popular state machine implementations in JavaScript is XState. Here's a composable that integrates with it:\njs\nimport { createMachine, interpret } from 'xstate'\nimport { shallowRef } from 'vue'\nexport function useMachine(options) {\nconst machine = createMachine(options)\nconst state = shallowRef(machine.initialState)\nconst service = interpret(machine)\n.onTransition((newState) => (state.value = newState))\n.start()\nconst send = (event) => service.send(event)\nreturn [state, send]\n}\nRxJS\nRxJS is a library for working with asynchronous event streams. The VueUse library provides the @vueuse/rxjs\nadd-on for connecting RxJS streams with Vue's reactivity system.\nConnection to Signals\nQuite a few other frameworks have introduced reactivity primitives similar to refs from Vue's Composition API, under the term \"signals\":\nFundamentally, signals are the same kind of reactivity primitive as Vue refs. It's a value container that provides dependency tracking on access, and side-effect triggering on mutation. This reactivity-primitive-based paradigm isn't a particularly new concept in the frontend world: it dates back to implementations like Knockout observables and Meteor Tracker from more than a decade ago. Vue Options API and the React state management library MobX are also based on the same principles, but hide the primitives behind object properties.\nAlthough not a necessary trait for something to qualify as signals, today the concept is often discussed alongside the rendering model where updates are performed through fine-grained subscriptions. Due to the use of Virtual DOM, Vue currently relies on compilers to achieve similar optimizations. However, we are also exploring a new Solid-inspired compilation strategy, called Vapor Mode, that does not rely on Virtual DOM and takes more advantage of Vue's built-in reactivity system.\nAPI Design Trade-Offs\nThe design of Preact and Qwik's signals are very similar to Vue's shallowRef: all three provide a mutable interface via the .value\nproperty. We will focus the discussion on Solid and Angular signals.\nSolid Signals\nSolid's createSignal()\nAPI design emphasizes read / write segregation. Signals are exposed as a read-only getter and a separate setter:\njs\nconst [count, setCount] = createSignal(0)\ncount() // access the value\nsetCount(1) // update the value\nNotice how the count\nsignal can be passed down without the setter. This ensures that the state can never be mutated unless the setter is also explicitly exposed. Whether this safety guarantee justifies the more verbose syntax could be subject to the requirement of the project and personal taste - but in case you prefer this API style, you can easily replicate it in Vue:\njs\nimport { shallowRef, triggerRef } from 'vue'\nexport function createSignal(value, options) {\nconst r = shallowRef(value)\nconst get = () => r.value\nconst set = (v) => {\nr.value = typeof v === 'function' ? v(r.value) : v\nif (options?.equals === false) triggerRef(r)\n}\nreturn [get, set]\n}\nAngular Signals\nAngular is undergoing some fundamental changes by foregoing dirty-checking and introducing its own implementation of a reactivity primitive. The Angular Signal API looks like this:\njs\nconst count = signal(0)\ncount() // access the value\ncount.set(1) // set new value\ncount.update((v) => v + 1) // update based on previous value\nAgain, we can easily replicate the API in Vue:\njs\nimport { shallowRef } from 'vue'\nexport function signal(initialValue) {\nconst r = shallowRef(initialValue)\nconst s = () => r.value\ns.set = (value) => {\nr.value = value\n}\ns.update = (updater) => {\nr.value = updater(r.value)\n}\nreturn s\n}\nCompared to Vue refs, Solid and Angular's getter-based API style provide some interesting trade-offs when used in Vue components:\n()\nis slightly less verbose than.value\n, but updating the value is more verbose.- There is no ref-unwrapping: accessing values always require\n()\n. This makes value access consistent everywhere. This also means you can pass raw signals down as component props.\nWhether these API styles suit you is to some extent subjective. Our goal here is to demonstrate the underlying similarity and trade-offs between these different API designs. We also want to show that Vue is flexible: you are not really locked into the existing APIs. Should it be necessary, you can create your own reactivity primitive API to suit more specific needs.",
    "metadata": {
      "source": "https://vuejs.org/guide/extras/reactivity-in-depth",
      "title": "Reactivity in Depth | Vue.js"
    }
  },
  {
    "page_content": "TypeScript with Options API\nThis page assumes you've already read the overview on Using Vue with TypeScript.\nTIP\nWhile Vue does support TypeScript usage with Options API, it is recommended to use Vue with TypeScript via Composition API as it offers simpler, more efficient and more robust type inference.\nTyping Component Props\nType inference for props in Options API requires wrapping the component with defineComponent()\n. With it, Vue is able to infer the types for the props based on the props\noption, taking additional options such as required: true\nand default\ninto account:\nts\nimport { defineComponent } from 'vue'\nexport default defineComponent({\n// type inference enabled\nprops: {\nname: String,\nid: [Number, String],\nmsg: { type: String, required: true },\nmetadata: null\n},\nmounted() {\nthis.name // type: string | undefined\nthis.id // type: number | string | undefined\nthis.msg // type: string\nthis.metadata // type: any\n}\n})\nHowever, the runtime props\noptions only support using constructor functions as a prop's type - there is no way to specify complex types such as objects with nested properties or function call signatures.\nTo annotate complex props types, we can use the PropType\nutility type:\nts\nimport { defineComponent } from 'vue'\nimport type { PropType } from 'vue'\ninterface Book {\ntitle: string\nauthor: string\nyear: number\n}\nexport default defineComponent({\nprops: {\nbook: {\n// provide more specific type to `Object`\ntype: Object as PropType<Book>,\nrequired: true\n},\n// can also annotate functions\ncallback: Function as PropType<(id: number) => void>\n},\nmounted() {\nthis.book.title // string\nthis.book.year // number\n// TS Error: argument of type 'string' is not\n// assignable to parameter of type 'number'\nthis.callback?.('123')\n}\n})\nCaveats\nIf your TypeScript version is less than 4.7\n, you have to be careful when using function values for validator\nand default\nprop options - make sure to use arrow functions:\nts\nimport { defineComponent } from 'vue'\nimport type { PropType } from 'vue'\ninterface Book {\ntitle: string\nyear?: number\n}\nexport default defineComponent({\nprops: {\nbookA: {\ntype: Object as PropType<Book>,\n// Make sure to use arrow functions if your TypeScript version is less than 4.7\ndefault: () => ({\ntitle: 'Arrow Function Expression'\n}),\nvalidator: (book: Book) => !!book.title\n}\n}\n})\nThis prevents TypeScript from having to infer the type of this\ninside these functions, which, unfortunately, can cause the type inference to fail. It was a previous design limitation, and now has been improved in TypeScript 4.7.\nTyping Component Emits\nWe can declare the expected payload type for an emitted event using the object syntax of the emits\noption. Also, all non-declared emitted events will throw a type error when called:\nts\nimport { defineComponent } from 'vue'\nexport default defineComponent({\nemits: {\naddBook(payload: { bookName: string }) {\n// perform runtime validation\nreturn payload.bookName.length > 0\n}\n},\nmethods: {\nonSubmit() {\nthis.$emit('addBook', {\nbookName: 123 // Type error!\n})\nthis.$emit('non-declared-event') // Type error!\n}\n}\n})\nTyping Computed Properties\nA computed property infers its type based on its return value:\nts\nimport { defineComponent } from 'vue'\nexport default defineComponent({\ndata() {\nreturn {\nmessage: 'Hello!'\n}\n},\ncomputed: {\ngreeting() {\nreturn this.message + '!'\n}\n},\nmounted() {\nthis.greeting // type: string\n}\n})\nIn some cases, you may want to explicitly annotate the type of a computed property to ensure its implementation is correct:\nts\nimport { defineComponent } from 'vue'\nexport default defineComponent({\ndata() {\nreturn {\nmessage: 'Hello!'\n}\n},\ncomputed: {\n// explicitly annotate return type\ngreeting(): string {\nreturn this.message + '!'\n},\n// annotating a writable computed property\ngreetingUppercased: {\nget(): string {\nreturn this.greeting.toUpperCase()\n},\nset(newValue: string) {\nthis.message = newValue.toUpperCase()\n}\n}\n}\n})\nExplicit annotations may also be required in some edge cases where TypeScript fails to infer the type of a computed property due to circular inference loops.\nTyping Event Handlers\nWhen dealing with native DOM events, it might be useful to type the argument we pass to the handler correctly. Let's take a look at this example:\nvue\n<script lang=\"ts\">\nimport { defineComponent } from 'vue'\nexport default defineComponent({\nmethods: {\nhandleChange(event) {\n// `event` implicitly has `any` type\nconsole.log(event.target.value)\n}\n}\n})\n</script>\n<template>\n<input type=\"text\" @change=\"handleChange\" />\n</template>\nWithout type annotation, the event\nargument will implicitly have a type of any\n. This will also result in a TS error if \"strict\": true\nor \"noImplicitAny\": true\nare used in tsconfig.json\n. It is therefore recommended to explicitly annotate the argument of event handlers. In addition, you may need to use type assertions when accessing the properties of event\n:\nts\nimport { defineComponent } from 'vue'\nexport default defineComponent({\nmethods: {\nhandleChange(event: Event) {\nconsole.log((event.target as HTMLInputElement).value)\n}\n}\n})\nAugmenting Global Properties\nSome plugins install globally available properties to all component instances via app.config.globalProperties\n. For example, we may install this.$http\nfor data-fetching or this.$translate\nfor internationalization. To make this play well with TypeScript, Vue exposes a ComponentCustomProperties\ninterface designed to be augmented via TypeScript module augmentation:\nts\nimport axios from 'axios'\ndeclare module 'vue' {\ninterface ComponentCustomProperties {\n$http: typeof axios\n$translate: (key: string) => string\n}\n}\nSee also:\nType Augmentation Placement\nWe can put this type augmentation in a .ts\nfile, or in a project-wide *.d.ts\nfile. Either way, make sure it is included in tsconfig.json\n. For library / plugin authors, this file should be specified in the types\nproperty in package.json\n.\nIn order to take advantage of module augmentation, you will need to ensure the augmentation is placed in a TypeScript module. That is to say, the file needs to contain at least one top-level import\nor export\n, even if it is just export {}\n. If the augmentation is placed outside of a module, it will overwrite the original types rather than augmenting them!\nts\n// Does not work, overwrites the original types.\ndeclare module 'vue' {\ninterface ComponentCustomProperties {\n$translate: (key: string) => string\n}\n}\nts\n// Works correctly\nexport {}\ndeclare module 'vue' {\ninterface ComponentCustomProperties {\n$translate: (key: string) => string\n}\n}\nAugmenting Custom Options\nSome plugins, for example vue-router\n, provide support for custom component options such as beforeRouteEnter\n:\nts\nimport { defineComponent } from 'vue'\nexport default defineComponent({\nbeforeRouteEnter(to, from, next) {\n// ...\n}\n})\nWithout proper type augmentation, the arguments of this hook will implicitly have any\ntype. We can augment the ComponentCustomOptions\ninterface to support these custom options:\nts\nimport { Route } from 'vue-router'\ndeclare module 'vue' {\ninterface ComponentCustomOptions {\nbeforeRouteEnter?(to: Route, from: Route, next: () => void): void\n}\n}\nNow the beforeRouteEnter\noption will be properly typed. Note this is just an example - well-typed libraries like vue-router\nshould automatically perform these augmentations in their own type definitions.\nThe placement of this augmentation is subject to the same restrictions as global property augmentations.\nSee also:",
    "metadata": {
      "source": "https://vuejs.org/guide/typescript/options-api",
      "title": "TypeScript with Options API | Vue.js"
    }
  },
  {
    "page_content": "Vue and Web Components\nWeb Components is an umbrella term for a set of web native APIs that allows developers to create reusable custom elements.\nWe consider Vue and Web Components to be primarily complementary technologies. Vue has excellent support for both consuming and creating custom elements. Whether you are integrating custom elements into an existing Vue application, or using Vue to build and distribute custom elements, you are in good company.\nUsing Custom Elements in Vue\nVue scores a perfect 100% in the Custom Elements Everywhere tests. Consuming custom elements inside a Vue application largely works the same as using native HTML elements, with a few things to keep in mind:\nSkipping Component Resolution\nBy default, Vue will attempt to resolve a non-native HTML tag as a registered Vue component before falling back to rendering it as a custom element. This will cause Vue to emit a \"failed to resolve component\" warning during development. To let Vue know that certain elements should be treated as custom elements and skip component resolution, we can specify the compilerOptions.isCustomElement\noption.\nIf you are using Vue with a build setup, the option should be passed via build configs since it is a compile-time option.\nExample In-Browser Config\njs\n// Only works if using in-browser compilation.\n// If using build tools, see config examples below.\napp.config.compilerOptions.isCustomElement = (tag) => tag.includes('-')\nExample Vite Config\njs\n// vite.config.js\nimport vue from '@vitejs/plugin-vue'\nexport default {\nplugins: [\nvue({\ntemplate: {\ncompilerOptions: {\n// treat all tags with a dash as custom elements\nisCustomElement: (tag) => tag.includes('-')\n}\n}\n})\n]\n}\nExample Vue CLI Config\njs\n// vue.config.js\nmodule.exports = {\nchainWebpack: config => {\nconfig.module\n.rule('vue')\n.use('vue-loader')\n.tap(options => ({\n...options,\ncompilerOptions: {\n// treat any tag that starts with ion- as custom elements\nisCustomElement: tag => tag.startsWith('ion-')\n}\n}))\n}\n}\nPassing DOM Properties\nSince DOM attributes can only be strings, we need to pass complex data to custom elements as DOM properties. When setting props on a custom element, Vue 3 automatically checks DOM-property presence using the in\noperator and will prefer setting the value as a DOM property if the key is present. This means that, in most cases, you won't need to think about this if the custom element follows the recommended best practices.\nHowever, there could be rare cases where the data must be passed as a DOM property, but the custom element does not properly define/reflect the property (causing the in\ncheck to fail). In this case, you can force a v-bind\nbinding to be set as a DOM property using the .prop\nmodifier:\ntemplate\n<my-element :user.prop=\"{ name: 'jack' }\"></my-element>\n<!-- shorthand equivalent -->\n<my-element .user=\"{ name: 'jack' }\"></my-element>\nBuilding Custom Elements with Vue\nThe primary benefit of custom elements is that they can be used with any framework, or even without a framework. This makes them ideal for distributing components where the end consumer may not be using the same frontend stack, or when you want to insulate the end application from the implementation details of the components it uses.\ndefineCustomElement\nVue supports creating custom elements using exactly the same Vue component APIs via the defineCustomElement\nmethod. The method accepts the same argument as defineComponent\n, but instead returns a custom element constructor that extends HTMLElement\n:\ntemplate\n<my-vue-element></my-vue-element>\njs\nimport { defineCustomElement } from 'vue'\nconst MyVueElement = defineCustomElement({\n// normal Vue component options here\nprops: {},\nemits: {},\ntemplate: `...`,\n// defineCustomElement only: CSS to be injected into shadow root\nstyles: [`/* inlined css */`]\n})\n// Register the custom element.\n// After registration, all `<my-vue-element>` tags\n// on the page will be upgraded.\ncustomElements.define('my-vue-element', MyVueElement)\n// You can also programmatically instantiate the element:\n// (can only be done after registration)\ndocument.body.appendChild(\nnew MyVueElement({\n// initial props (optional)\n})\n)\nLifecycle\nA Vue custom element will mount an internal Vue component instance inside its shadow root when the element's\nconnectedCallback\nis called for the first time.When the element's\ndisconnectedCallback\nis invoked, Vue will check whether the element is detached from the document after a microtask tick.If the element is still in the document, it's a move and the component instance will be preserved;\nIf the element is detached from the document, it's a removal and the component instance will be unmounted.\nProps\nAll props declared using the\nprops\noption will be defined on the custom element as properties. Vue will automatically handle the reflection between attributes / properties where appropriate.Attributes are always reflected to corresponding properties.\nProperties with primitive values (\nstring\n,boolean\nornumber\n) are reflected as attributes.\nVue also automatically casts props declared with\nBoolean\norNumber\ntypes into the desired type when they are set as attributes (which are always strings). For example, given the following props declaration:jsprops: { selected: Boolean, index: Number }\nAnd the custom element usage:\ntemplate<my-element selected index=\"1\"></my-element>\nIn the component,\nselected\nwill be cast totrue\n(boolean) andindex\nwill be cast to1\n(number).\nEvents\nEvents emitted via this.$emit\nor setup emit\nare dispatched as native CustomEvents on the custom element. Additional event arguments (payload) will be exposed as an array on the CustomEvent object as its detail\nproperty.\nSlots\nInside the component, slots can be rendered using the <slot/>\nelement as usual. However, when consuming the resulting element, it only accepts native slots syntax:\nScoped slots are not supported.\nWhen passing named slots, use the\nslot\nattribute instead of thev-slot\ndirective:template<my-element> <div slot=\"named\">hello</div> </my-element>\nProvide / Inject\nThe Provide / Inject API and its Composition API equivalent also work between Vue-defined custom elements. However, note that this works only between custom elements. i.e. a Vue-defined custom element won't be able to inject properties provided by a non-custom-element Vue component.\nSFC as Custom Element\ndefineCustomElement\nalso works with Vue Single-File Components (SFCs). However, with the default tooling setup, the <style>\ninside the SFCs will still be extracted and merged into a single CSS file during production build. When using an SFC as a custom element, it is often desirable to inject the <style>\ntags into the custom element's shadow root instead.\nThe official SFC toolings support importing SFCs in \"custom element mode\" (requires @vitejs/plugin-vue@^1.4.0\nor vue-loader@^16.5.0\n). An SFC loaded in custom element mode inlines its <style>\ntags as strings of CSS and exposes them under the component's styles\noption. This will be picked up by defineCustomElement\nand injected into the element's shadow root when instantiated.\nTo opt-in to this mode, simply end your component file name with .ce.vue\n:\njs\nimport { defineCustomElement } from 'vue'\nimport Example from './Example.ce.vue'\nconsole.log(Example.styles) // [\"/* inlined css */\"]\n// convert into custom element constructor\nconst ExampleElement = defineCustomElement(Example)\n// register\ncustomElements.define('my-example', ExampleElement)\nIf you wish to customize what files should be imported in custom element mode (for example, treating all SFCs as custom elements), you can pass the customElement\noption to the respective build plugins:\nTips for a Vue Custom Elements Library\nWhen building custom elements with Vue, the elements will rely on Vue's runtime. There is a ~16kb baseline size cost depending on how many features are being used. This means it is not ideal to use Vue if you are shipping a single custom element - you may want to use vanilla JavaScript, petite-vue, or frameworks that specialize in small runtime size. However, the base size is more than justifiable if you are shipping a collection of custom elements with complex logic, as Vue will allow each component to be authored with much less code. The more elements you are shipping together, the better the trade-off.\nIf the custom elements will be used in an application that is also using Vue, you can choose to externalize Vue from the built bundle so that the elements will be using the same copy of Vue from the host application.\nIt is recommended to export the individual element constructors to give your users the flexibility to import them on-demand and register them with desired tag names. You can also export a convenience function to automatically register all elements. Here's an example entry point of a Vue custom element library:\njs\nimport { defineCustomElement } from 'vue'\nimport Foo from './MyFoo.ce.vue'\nimport Bar from './MyBar.ce.vue'\nconst MyFoo = defineCustomElement(Foo)\nconst MyBar = defineCustomElement(Bar)\n// export individual elements\nexport { MyFoo, MyBar }\nexport function register() {\ncustomElements.define('my-foo', MyFoo)\ncustomElements.define('my-bar', MyBar)\n}\nIf you have many components, you can also leverage build tool features such as Vite's glob import or webpack's require.context\nto load all components from a directory.\nWeb Components and TypeScript\nIf you are developing an application or a library, you may want to type check your Vue components, including those that are defined as custom elements.\nCustom elements are registered globally using native APIs, so by default they won't have type inference when used in Vue templates. To provide type support for Vue components registered as custom elements, we can register global component typings using the the GlobalComponents\ninterface in Vue templates and/or in JSX:\ntypescript\nimport { defineCustomElement } from 'vue'\n// vue SFC\nimport CounterSFC from './src/components/counter.ce.vue'\n// turn component into web components\nexport const Counter = defineCustomElement(CounterSFC)\n// register global typings\ndeclare module 'vue' {\nexport interface GlobalComponents {\n'Counter': typeof Counter,\n}\n}\nWeb Components vs. Vue Components\nSome developers believe that framework-proprietary component models should be avoided, and that exclusively using Custom Elements makes an application \"future-proof\". Here we will try to explain why we believe that this is an overly simplistic take on the problem.\nThere is indeed a certain level of feature overlap between Custom Elements and Vue Components: they both allow us to define reusable components with data passing, event emitting, and lifecycle management. However, Web Components APIs are relatively low-level and bare-bones. To build an actual application, we need quite a few additional capabilities which the platform does not cover:\nA declarative and efficient templating system;\nA reactive state management system that facilitates cross-component logic extraction and reuse;\nA performant way to render the components on the server and hydrate them on the client (SSR), which is important for SEO and Web Vitals metrics such as LCP. Native custom elements SSR typically involves simulating the DOM in Node.js and then serializing the mutated DOM, while Vue SSR compiles into string concatenation whenever possible, which is much more efficient.\nVue's component model is designed with these needs in mind as a coherent system.\nWith a competent engineering team, you could probably build the equivalent on top of native Custom Elements - but this also means you are taking on the long-term maintenance burden of an in-house framework, while losing out on the ecosystem and community benefits of a mature framework like Vue.\nThere are also frameworks built using Custom Elements as the basis of their component model, but they all inevitably have to introduce their proprietary solutions to the problems listed above. Using these frameworks entails buying into their technical decisions on how to solve these problems - which, despite what may be advertised, doesn't automatically insulate you from potential future churns.\nThere are also some areas where we find custom elements to be limiting:\nEager slot evaluation hinders component composition. Vue's scoped slots are a powerful mechanism for component composition, which can't be supported by custom elements due to native slots' eager nature. Eager slots also mean the receiving component cannot control when or whether to render a piece of slot content.\nShipping custom elements with shadow DOM scoped CSS today requires embedding the CSS inside JavaScript so that they can be injected into shadow roots at runtime. They also result in duplicated styles in markup in SSR scenarios. There are platform features being worked on in this area - but as of now they are not yet universally supported, and there are still production performance / SSR concerns to be addressed. In the meanwhile, Vue SFCs provide CSS scoping mechanisms that support extracting the styles into plain CSS files.\nVue will always stay up to date with the latest standards in the web platform, and we will happily leverage whatever the platform provides if it makes our job easier. However, our goal is to provide solutions that work well and work today. That means we have to incorporate new platform features with a critical mindset - and that involves filling the gaps where the standards fall short while that is still the case.",
    "metadata": {
      "source": "https://vuejs.org/guide/extras/web-components",
      "title": "Vue and Web Components | Vue.js"
    }
  },
  {
    "page_content": "KeepAlive\n<KeepAlive>\nis a built-in component that allows us to conditionally cache component instances when dynamically switching between multiple components.\nBasic Usage\nIn the Component Basics chapter, we introduced the syntax for Dynamic Components, using the <component>\nspecial element:\ntemplate\n<component :is=\"activeComponent\" />\nBy default, an active component instance will be unmounted when switching away from it. This will cause any changed state it holds to be lost. When this component is displayed again, a new instance will be created with only the initial state.\nIn the example below, we have two stateful components - A contains a counter, while B contains a message synced with an input via v-model\n. Try updating the state of one of them, switch away, and then switch back to it:\nCurrent component: A\nCount: 0You'll notice that when switched back, the previous changed state would have been reset.\nCreating fresh component instance on switch is normally useful behavior, but in this case, we'd really like the two component instances to be preserved even when they are inactive. To solve this problem, we can wrap our dynamic component with the <KeepAlive>\nbuilt-in component:\ntemplate\n<!-- Inactive components will be cached! -->\n<KeepAlive>\n<component :is=\"activeComponent\" />\n</KeepAlive>\nNow, the state will be persisted across component switches:\nCurrent component: A\nCount: 0TIP\nWhen used in in-DOM templates, it should be referenced as <keep-alive>\n.\nInclude / Exclude\nBy default, <KeepAlive>\nwill cache any component instance inside. We can customize this behavior via the include\nand exclude\nprops. Both props can be a comma-delimited string, a RegExp\n, or an array containing either types:\ntemplate\n<!-- comma-delimited string -->\n<KeepAlive include=\"a,b\">\n<component :is=\"view\" />\n</KeepAlive>\n<!-- regex (use `v-bind`) -->\n<KeepAlive :include=\"/a|b/\">\n<component :is=\"view\" />\n</KeepAlive>\n<!-- Array (use `v-bind`) -->\n<KeepAlive :include=\"['a', 'b']\">\n<component :is=\"view\" />\n</KeepAlive>\nThe match is checked against the component's name\noption, so components that need to be conditionally cached by KeepAlive\nmust explicitly declare a name\noption.\nTIP\nSince version 3.2.34, a single-file component using <script setup>\nwill automatically infer its name\noption based on the filename, removing the need to manually declare the name.\nMax Cached Instances\nWe can limit the maximum number of component instances that can be cached via the max\nprop. When max\nis specified, <KeepAlive>\nbehaves like an LRU cache: if the number of cached instances is about to exceed the specified max count, the least recently accessed cached instance will be destroyed to make room for the new one.\ntemplate\n<KeepAlive :max=\"10\">\n<component :is=\"activeComponent\" />\n</KeepAlive>\nLifecycle of Cached Instance\nWhen a component instance is removed from the DOM but is part of a component tree cached by <KeepAlive>\n, it goes into a deactivated state instead of being unmounted. When a component instance is inserted into the DOM as part of a cached tree, it is activated.\nA kept-alive component can register lifecycle hooks for these two states using onActivated()\nand onDeactivated()\n:\nvue\n<script setup>\nimport { onActivated, onDeactivated } from 'vue'\nonActivated(() => {\n// called on initial mount\n// and every time it is re-inserted from the cache\n})\nonDeactivated(() => {\n// called when removed from the DOM into the cache\n// and also when unmounted\n})\n</script>\nNote that:\nonActivated\nis also called on mount, andonDeactivated\non unmount.Both hooks work for not only the root component cached by\n<KeepAlive>\n, but also the descendant components in the cached tree.\nRelated",
    "metadata": {
      "source": "https://vuejs.org/guide/built-ins/keep-alive",
      "title": "KeepAlive | Vue.js"
    }
  },
  {
    "page_content": "Render Functions & JSX\nVue recommends using templates to build applications in the vast majority of cases. However, there are situations where we need the full programmatic power of JavaScript. That's where we can use the render function.\nIf you are new to the concept of virtual DOM and render functions, make sure to read the Rendering Mechanism chapter first.\nBasic Usage\nCreating Vnodes\nVue provides an h()\nfunction for creating vnodes:\njs\nimport { h } from 'vue'\nconst vnode = h(\n'div', // type\n{ id: 'foo', class: 'bar' }, // props\n[\n/* children */\n]\n)\nh()\nis short for hyperscript - which means \"JavaScript that produces HTML (hypertext markup language)\". This name is inherited from conventions shared by many virtual DOM implementations. A more descriptive name could be createVnode()\n, but a shorter name helps when you have to call this function many times in a render function.\nThe h()\nfunction is designed to be very flexible:\njs\n// all arguments except the type are optional\nh('div')\nh('div', { id: 'foo' })\n// both attributes and properties can be used in props\n// Vue automatically picks the right way to assign it\nh('div', { class: 'bar', innerHTML: 'hello' })\n// props modifiers such as `.prop` and `.attr` can be added\n// with `.` and `^` prefixes respectively\nh('div', { '.name': 'some-name', '^width': '100' })\n// class and style have the same object / array\n// value support that they have in templates\nh('div', { class: [foo, { bar }], style: { color: 'red' } })\n// event listeners should be passed as onXxx\nh('div', { onClick: () => {} })\n// children can be a string\nh('div', { id: 'foo' }, 'hello')\n// props can be omitted when there are no props\nh('div', 'hello')\nh('div', [h('span', 'hello')])\n// children array can contain mixed vnodes and strings\nh('div', ['hello', h('span', 'hello')])\nThe resulting vnode has the following shape:\njs\nconst vnode = h('div', { id: 'foo' }, [])\nvnode.type // 'div'\nvnode.props // { id: 'foo' }\nvnode.children // []\nvnode.key // null\nNote\nThe full VNode\ninterface contains many other internal properties, but it is strongly recommended to avoid relying on any properties other than the ones listed here. This avoids unintended breakage in case the internal properties are changed.\nDeclaring Render Functions\nWhen using templates with Composition API, the return value of the setup()\nhook is used to expose data to the template. When using render functions, however, we can directly return the render function instead:\njs\nimport { ref, h } from 'vue'\nexport default {\nprops: {\n/* ... */\n},\nsetup(props) {\nconst count = ref(1)\n// return the render function\nreturn () => h('div', props.msg + count.value)\n}\n}\nThe render function is declared inside setup()\nso it naturally has access to the props and any reactive state declared in the same scope.\nIn addition to returning a single vnode, you can also return strings or arrays:\njs\nexport default {\nsetup() {\nreturn () => 'hello world!'\n}\n}\njs\nimport { h } from 'vue'\nexport default {\nsetup() {\n// use an array to return multiple root nodes\nreturn () => [\nh('div'),\nh('div'),\nh('div')\n]\n}\n}\nTIP\nMake sure to return a function instead of directly returning values! The setup()\nfunction is called only once per component, while the returned render function will be called multiple times.\nIf a render function component doesn't need any instance state, they can also be declared directly as a function for brevity:\njs\nfunction Hello() {\nreturn 'hello world!'\n}\nThat's right, this is a valid Vue component! See Functional Components for more details on this syntax.\nVnodes Must Be Unique\nAll vnodes in the component tree must be unique. That means the following render function is invalid:\njs\nfunction render() {\nconst p = h('p', 'hi')\nreturn h('div', [\n// Yikes - duplicate vnodes!\np,\np\n])\n}\nIf you really want to duplicate the same element/component many times, you can do so with a factory function. For example, the following render function is a perfectly valid way of rendering 20 identical paragraphs:\njs\nfunction render() {\nreturn h(\n'div',\nArray.from({ length: 20 }).map(() => {\nreturn h('p', 'hi')\n})\n)\n}\nJSX / TSX\nJSX is an XML-like extension to JavaScript that allows us to write code like this:\njsx\nconst vnode = <div>hello</div>\nInside JSX expressions, use curly braces to embed dynamic values:\njsx\nconst vnode = <div id={dynamicId}>hello, {userName}</div>\ncreate-vue\nand Vue CLI both have options for scaffolding projects with pre-configured JSX support. If you are configuring JSX manually, please refer to the documentation of @vue/babel-plugin-jsx\nfor details.\nAlthough first introduced by React, JSX actually has no defined runtime semantics and can be compiled into various different outputs. If you have worked with JSX before, do note that Vue JSX transform is different from React's JSX transform, so you can't use React's JSX transform in Vue applications. Some notable differences from React JSX include:\n- You can use HTML attributes such as\nclass\nandfor\nas props - no need to useclassName\norhtmlFor\n. - Passing children to components (i.e. slots) works differently.\nVue's type definition also provides type inference for TSX usage. When using TSX, make sure to specify \"jsx\": \"preserve\"\nin tsconfig.json\nso that TypeScript leaves the JSX syntax intact for Vue JSX transform to process.\nJSX Type Inference\nSimilar to the transform, Vue's JSX also needs different type definitions.\nStarting in Vue 3.4, Vue no longer implicitly registers the global JSX\nnamespace. To instruct TypeScript to use Vue's JSX type definitions, make sure to include the following in your tsconfig.json\n:\njson\n{\n\"compilerOptions\": {\n\"jsx\": \"preserve\",\n\"jsxImportSource\": \"vue\"\n// ...\n}\n}\nYou can also opt-in per file by adding a /* @jsxImportSource vue */\ncomment at the top of the file.\nIf there is code that depends on the presence of the global JSX\nnamespace, you can retain the exact pre-3.4 global behavior by explicitly importing or referencing vue/jsx\nin your project, which registers the global JSX\nnamespace.\nRender Function Recipes\nBelow we will provide some common recipes for implementing template features as their equivalent render functions / JSX.\nv-if\nTemplate:\ntemplate\n<div>\n<div v-if=\"ok\">yes</div>\n<span v-else>no</span>\n</div>\nEquivalent render function / JSX:\njs\nh('div', [ok.value ? h('div', 'yes') : h('span', 'no')])\njsx\n<div>{ok.value ? <div>yes</div> : <span>no</span>}</div>\nv-for\nTemplate:\ntemplate\n<ul>\n<li v-for=\"{ id, text } in items\" :key=\"id\">\n{{ text }}\n</li>\n</ul>\nEquivalent render function / JSX:\njs\nh(\n'ul',\n// assuming `items` is a ref with array value\nitems.value.map(({ id, text }) => {\nreturn h('li', { key: id }, text)\n})\n)\njsx\n<ul>\n{items.value.map(({ id, text }) => {\nreturn <li key={id}>{text}</li>\n})}\n</ul>\nv-on\nProps with names that start with on\nfollowed by an uppercase letter are treated as event listeners. For example, onClick\nis the equivalent of @click\nin templates.\njs\nh(\n'button',\n{\nonClick(event) {\n/* ... */\n}\n},\n'Click Me'\n)\njsx\n<button\nonClick={(event) => {\n/* ... */\n}}\n>\nClick Me\n</button>\nEvent Modifiers\nFor the .passive\n, .capture\n, and .once\nevent modifiers, they can be concatenated after the event name using camelCase.\nFor example:\njs\nh('input', {\nonClickCapture() {\n/* listener in capture mode */\n},\nonKeyupOnce() {\n/* triggers only once */\n},\nonMouseoverOnceCapture() {\n/* once + capture */\n}\n})\njsx\n<input\nonClickCapture={() => {}}\nonKeyupOnce={() => {}}\nonMouseoverOnceCapture={() => {}}\n/>\nFor other event and key modifiers, the withModifiers\nhelper can be used:\njs\nimport { withModifiers } from 'vue'\nh('div', {\nonClick: withModifiers(() => {}, ['self'])\n})\njsx\n<div onClick={withModifiers(() => {}, ['self'])} />\nComponents\nTo create a vnode for a component, the first argument passed to h()\nshould be the component definition. This means when using render functions, it is unnecessary to register components - you can just use the imported components directly:\njs\nimport Foo from './Foo.vue'\nimport Bar from './Bar.jsx'\nfunction render() {\nreturn h('div', [h(Foo), h(Bar)])\n}\njsx\nfunction render() {\nreturn (\n<div>\n<Foo />\n<Bar />\n</div>\n)\n}\nAs we can see, h\ncan work with components imported from any file format as long as it's a valid Vue component.\nDynamic components are straightforward with render functions:\njs\nimport Foo from './Foo.vue'\nimport Bar from './Bar.jsx'\nfunction render() {\nreturn ok.value ? h(Foo) : h(Bar)\n}\njsx\nfunction render() {\nreturn ok.value ? <Foo /> : <Bar />\n}\nIf a component is registered by name and cannot be imported directly (for example, globally registered by a library), it can be programmatically resolved by using the resolveComponent()\nhelper.\nRendering Slots\nIn render functions, slots can be accessed from the setup()\ncontext. Each slot on the slots\nobject is a function that returns an array of vnodes:\njs\nexport default {\nprops: ['message'],\nsetup(props, { slots }) {\nreturn () => [\n// default slot:\n// <div><slot /></div>\nh('div', slots.default()),\n// named slot:\n// <div><slot name=\"footer\" :text=\"message\" /></div>\nh(\n'div',\nslots.footer({\ntext: props.message\n})\n)\n]\n}\n}\nJSX equivalent:\njsx\n// default\n<div>{slots.default()}</div>\n// named\n<div>{slots.footer({ text: props.message })}</div>\nPassing Slots\nPassing children to components works a bit differently from passing children to elements. Instead of an array, we need to pass either a slot function, or an object of slot functions. Slot functions can return anything a normal render function can return - which will always be normalized to arrays of vnodes when accessed in the child component.\njs\n// single default slot\nh(MyComponent, () => 'hello')\n// named slots\n// notice the `null` is required to avoid\n// the slots object being treated as props\nh(MyComponent, null, {\ndefault: () => 'default slot',\nfoo: () => h('div', 'foo'),\nbar: () => [h('span', 'one'), h('span', 'two')]\n})\nJSX equivalent:\njsx\n// default\n<MyComponent>{() => 'hello'}</MyComponent>\n// named\n<MyComponent>{{\ndefault: () => 'default slot',\nfoo: () => <div>foo</div>,\nbar: () => [<span>one</span>, <span>two</span>]\n}}</MyComponent>\nPassing slots as functions allows them to be invoked lazily by the child component. This leads to the slot's dependencies being tracked by the child instead of the parent, which results in more accurate and efficient updates.\nScoped Slots\nTo render a scoped slot in the parent component, a slot is passed to the child. Notice how the slot now has a parameter text\n. The slot will be called in the child component and the data from the child component will be passed up to the parent component.\njs\n// parent component\nexport default {\nsetup() {\nreturn () => h(MyComp, null, {\ndefault: ({ text }) => h('p', text)\n})\n}\n}\nRemember to pass null\nso the slots will not be treated as props.\njs\n// child component\nexport default {\nsetup(props, { slots }) {\nconst text = ref('hi')\nreturn () => h('div', null, slots.default({ text: text.value }))\n}\n}\nJSX equivalent:\njsx\n<MyComponent>{{\ndefault: ({ text }) => <p>{ text }</p>\n}}</MyComponent>\nBuilt-in Components\nBuilt-in components such as <KeepAlive>\n, <Transition>\n, <TransitionGroup>\n, <Teleport>\nand <Suspense>\nmust be imported for use in render functions:\njs\nimport { h, KeepAlive, Teleport, Transition, TransitionGroup } from 'vue'\nexport default {\nsetup () {\nreturn () => h(Transition, { mode: 'out-in' }, /* ... */)\n}\n}\nv-model\nThe v-model\ndirective is expanded to modelValue\nand onUpdate:modelValue\nprops during template compilation—we will have to provide these props ourselves:\njs\nexport default {\nprops: ['modelValue'],\nemits: ['update:modelValue'],\nsetup(props, { emit }) {\nreturn () =>\nh(SomeComponent, {\nmodelValue: props.modelValue,\n'onUpdate:modelValue': (value) => emit('update:modelValue', value)\n})\n}\n}\nCustom Directives\nCustom directives can be applied to a vnode using withDirectives\n:\njs\nimport { h, withDirectives } from 'vue'\n// a custom directive\nconst pin = {\nmounted() { /* ... */ },\nupdated() { /* ... */ }\n}\n// <div v-pin:top.animate=\"200\"></div>\nconst vnode = withDirectives(h('div'), [\n[pin, 200, 'top', { animate: true }]\n])\nIf the directive is registered by name and cannot be imported directly, it can be resolved using the resolveDirective\nhelper.\nTemplate Refs\nWith the Composition API, template refs are created by passing the ref()\nitself as a prop to the vnode:\njs\nimport { h, ref } from 'vue'\nexport default {\nsetup() {\nconst divEl = ref()\n// <div ref=\"divEl\">\nreturn () => h('div', { ref: divEl })\n}\n}\nFunctional Components\nFunctional components are an alternative form of component that don't have any state of their own. They act like pure functions: props in, vnodes out. They are rendered without creating a component instance (i.e. no this\n), and without the usual component lifecycle hooks.\nTo create a functional component we use a plain function, rather than an options object. The function is effectively the render\nfunction for the component.\nThe signature of a functional component is the same as the setup()\nhook:\njs\nfunction MyComponent(props, { slots, emit, attrs }) {\n// ...\n}\nMost of the usual configuration options for components are not available for functional components. However, it is possible to define props\nand emits\nby adding them as properties:\njs\nMyComponent.props = ['value']\nMyComponent.emits = ['click']\nIf the props\noption is not specified, then the props\nobject passed to the function will contain all attributes, the same as attrs\n. The prop names will not be normalized to camelCase unless the props\noption is specified.\nFor functional components with explicit props\n, attribute fallthrough works much the same as with normal components. However, for functional components that don't explicitly specify their props\n, only the class\n, style\n, and onXxx\nevent listeners will be inherited from the attrs\nby default. In either case, inheritAttrs\ncan be set to false\nto disable attribute inheritance:\njs\nMyComponent.inheritAttrs = false\nFunctional components can be registered and consumed just like normal components. If you pass a function as the first argument to h()\n, it will be treated as a functional component.\nTyping Functional Components\nFunctional Components can be typed based on whether they are named or anonymous. Vue - Official extension also supports type checking properly typed functional components when consuming them in SFC templates.\nNamed Functional Component\ntsx\nimport type { SetupContext } from 'vue'\ntype FComponentProps = {\nmessage: string\n}\ntype Events = {\nsendMessage(message: string): void\n}\nfunction FComponent(\nprops: FComponentProps,\ncontext: SetupContext<Events>\n) {\nreturn (\n<button onClick={() => context.emit('sendMessage', props.message)}>\n{props.message} {' '}\n</button>\n)\n}\nFComponent.props = {\nmessage: {\ntype: String,\nrequired: true\n}\n}\nFComponent.emits = {\nsendMessage: (value: unknown) => typeof value === 'string'\n}\nAnonymous Functional Component\ntsx\nimport type { FunctionalComponent } from 'vue'\ntype FComponentProps = {\nmessage: string\n}\ntype Events = {\nsendMessage(message: string): void\n}\nconst FComponent: FunctionalComponent<FComponentProps, Events> = (\nprops,\ncontext\n) => {\nreturn (\n<button onClick={() => context.emit('sendMessage', props.message)}>\n{props.message} {' '}\n</button>\n)\n}\nFComponent.props = {\nmessage: {\ntype: String,\nrequired: true\n}\n}\nFComponent.emits = {\nsendMessage: (value) => typeof value === 'string'\n}",
    "metadata": {
      "source": "https://vuejs.org/guide/extras/render-function",
      "title": "Render Functions & JSX | Vue.js"
    }
  },
  {
    "page_content": "Component Events\nThis page assumes you've already read the Components Basics. Read that first if you are new to components.\nEmitting and Listening to Events\nA component can emit custom events directly in template expressions (e.g. in a v-on\nhandler) using the built-in $emit\nmethod:\ntemplate\n<!-- MyComponent -->\n<button @click=\"$emit('someEvent')\">Click Me</button>\nThe parent can then listen to it using v-on\n:\ntemplate\n<MyComponent @some-event=\"callback\" />\nThe .once\nmodifier is also supported on component event listeners:\ntemplate\n<MyComponent @some-event.once=\"callback\" />\nLike components and props, event names provide an automatic case transformation. Notice we emitted a camelCase event, but can listen for it using a kebab-cased listener in the parent. As with props casing, we recommend using kebab-cased event listeners in templates.\nTIP\nUnlike native DOM events, component emitted events do not bubble. You can only listen to the events emitted by a direct child component. If there is a need to communicate between sibling or deeply nested components, use an external event bus or a global state management solution.\nEvent Arguments\nIt's sometimes useful to emit a specific value with an event. For example, we may want the <BlogPost>\ncomponent to be in charge of how much to enlarge the text by. In those cases, we can pass extra arguments to $emit\nto provide this value:\ntemplate\n<button @click=\"$emit('increaseBy', 1)\">\nIncrease by 1\n</button>\nThen, when we listen to the event in the parent, we can use an inline arrow function as the listener, which allows us to access the event argument:\ntemplate\n<MyButton @increase-by=\"(n) => count += n\" />\nOr, if the event handler is a method:\ntemplate\n<MyButton @increase-by=\"increaseCount\" />\nThen the value will be passed as the first parameter of that method:\njs\nfunction increaseCount(n) {\ncount.value += n\n}\nTIP\nAll extra arguments passed to $emit()\nafter the event name will be forwarded to the listener. For example, with $emit('foo', 1, 2, 3)\nthe listener function will receive three arguments.\nDeclaring Emitted Events\nA component can explicitly declare the events it will emit using the defineEmits()\nmacro :\nvue\n<script setup>\ndefineEmits(['inFocus', 'submit'])\n</script>\nThe $emit\nmethod that we used in the <template>\nisn't accessible within the <script setup>\nsection of a component, but defineEmits()\nreturns an equivalent function that we can use instead:\nvue\n<script setup>\nconst emit = defineEmits(['inFocus', 'submit'])\nfunction buttonClick() {\nemit('submit')\n}\n</script>\nThe defineEmits()\nmacro cannot be used inside a function, it must be placed directly within <script setup>\n, as in the example above.\nIf you're using an explicit setup\nfunction instead of <script setup>\n, events should be declared using the emits\noption, and the emit\nfunction is exposed on the setup()\ncontext:\njs\nexport default {\nemits: ['inFocus', 'submit'],\nsetup(props, ctx) {\nctx.emit('submit')\n}\n}\nAs with other properties of the setup()\ncontext, emit\ncan safely be destructured:\njs\nexport default {\nemits: ['inFocus', 'submit'],\nsetup(props, { emit }) {\nemit('submit')\n}\n}\nThe emits\noption and defineEmits()\nmacro also support an object syntax. If using TypeScript you can type arguments, which allows us to perform runtime validation of the payload of the emitted events:\nvue\n<script setup lang=\"ts\">\nconst emit = defineEmits({\nsubmit(payload: { email: string, password: string }) {\n// return `true` or `false` to indicate\n// validation pass / fail\n}\n})\n</script>\nIf you are using TypeScript with <script setup>\n, it's also possible to declare emitted events using pure type annotations:\nvue\n<script setup lang=\"ts\">\nconst emit = defineEmits<{\n(e: 'change', id: number): void\n(e: 'update', value: string): void\n}>()\n</script>\nMore details: Typing Component Emits\nAlthough optional, it is recommended to define all emitted events in order to better document how a component should work. It also allows Vue to exclude known listeners from fallthrough attributes, avoiding edge cases caused by DOM events manually dispatched by 3rd party code.\nTIP\nIf a native event (e.g., click\n) is defined in the emits\noption, the listener will now only listen to component-emitted click\nevents and no longer respond to native click\nevents.\nEvents Validation\nSimilar to prop type validation, an emitted event can be validated if it is defined with the object syntax instead of the array syntax.\nTo add validation, the event is assigned a function that receives the arguments passed to the emit\ncall and returns a boolean to indicate whether the event is valid or not.\nvue\n<script setup>\nconst emit = defineEmits({\n// No validation\nclick: null,\n// Validate submit event\nsubmit: ({ email, password }) => {\nif (email && password) {\nreturn true\n} else {\nconsole.warn('Invalid submit event payload!')\nreturn false\n}\n}\n})\nfunction submitForm(email, password) {\nemit('submit', { email, password })\n}\n</script>",
    "metadata": {
      "source": "https://vuejs.org/guide/components/events",
      "title": "Component Events | Vue.js"
    }
  },
  {
    "page_content": "Rendering Mechanism\nHow does Vue take a template and turn it into actual DOM nodes? How does Vue update those DOM nodes efficiently? We will attempt to shed some light on these questions here by diving into Vue's internal rendering mechanism.\nVirtual DOM\nYou have probably heard about the term \"virtual DOM\", which Vue's rendering system is based upon.\nThe virtual DOM (VDOM) is a programming concept where an ideal, or “virtual”, representation of a UI is kept in memory and synced with the “real” DOM. The concept was pioneered by React, and has been adopted in many other frameworks with different implementations, including Vue.\nVirtual DOM is more of a pattern than a specific technology, so there is no one canonical implementation. We can illustrate the idea using a simple example:\njs\nconst vnode = {\ntype: 'div',\nprops: {\nid: 'hello'\n},\nchildren: [\n/* more vnodes */\n]\n}\nHere, vnode\nis a plain JavaScript object (a \"virtual node\") representing a <div>\nelement. It contains all the information that we need to create the actual element. It also contains more children vnodes, which makes it the root of a virtual DOM tree.\nA runtime renderer can walk a virtual DOM tree and construct a real DOM tree from it. This process is called mount.\nIf we have two copies of virtual DOM trees, the renderer can also walk and compare the two trees, figuring out the differences, and apply those changes to the actual DOM. This process is called patch, also known as \"diffing\" or \"reconciliation\".\nThe main benefit of virtual DOM is that it gives the developer the ability to programmatically create, inspect and compose desired UI structures in a declarative way, while leaving the direct DOM manipulation to the renderer.\nRender Pipeline\nAt the high level, this is what happens when a Vue component is mounted:\nCompile: Vue templates are compiled into render functions: functions that return virtual DOM trees. This step can be done either ahead-of-time via a build step, or on-the-fly by using the runtime compiler.\nMount: The runtime renderer invokes the render functions, walks the returned virtual DOM tree, and creates actual DOM nodes based on it. This step is performed as a reactive effect, so it keeps track of all reactive dependencies that were used.\nPatch: When a dependency used during mount changes, the effect re-runs. This time, a new, updated Virtual DOM tree is created. The runtime renderer walks the new tree, compares it with the old one, and applies necessary updates to the actual DOM.\nTemplates vs. Render Functions\nVue templates are compiled into virtual DOM render functions. Vue also provides APIs that allow us to skip the template compilation step and directly author render functions. Render functions are more flexible than templates when dealing with highly dynamic logic, because you can work with vnodes using the full power of JavaScript.\nSo why does Vue recommend templates by default? There are a number of reasons:\nTemplates are closer to actual HTML. This makes it easier to reuse existing HTML snippets, apply accessibility best practices, style with CSS, and for designers to understand and modify.\nTemplates are easier to statically analyze due to their more deterministic syntax. This allows Vue's template compiler to apply many compile-time optimizations to improve the performance of the virtual DOM (which we will discuss below).\nIn practice, templates are sufficient for most use cases in applications. Render functions are typically only used in reusable components that need to deal with highly dynamic rendering logic. Render function usage is discussed in more detail in Render Functions & JSX.\nCompiler-Informed Virtual DOM\nThe virtual DOM implementation in React and most other virtual-DOM implementations are purely runtime: the reconciliation algorithm cannot make any assumptions about the incoming virtual DOM tree, so it has to fully traverse the tree and diff the props of every vnode in order to ensure correctness. In addition, even if a part of the tree never changes, new vnodes are always created for them on each re-render, resulting in unnecessary memory pressure. This is one of the most criticized aspect of virtual DOM: the somewhat brute-force reconciliation process sacrifices efficiency in return for declarativeness and correctness.\nBut it doesn't have to be that way. In Vue, the framework controls both the compiler and the runtime. This allows us to implement many compile-time optimizations that only a tightly-coupled renderer can take advantage of. The compiler can statically analyze the template and leave hints in the generated code so that the runtime can take shortcuts whenever possible. At the same time, we still preserve the capability for the user to drop down to the render function layer for more direct control in edge cases. We call this hybrid approach Compiler-Informed Virtual DOM.\nBelow, we will discuss a few major optimizations done by the Vue template compiler to improve the virtual DOM's runtime performance.\nStatic Hoisting\nQuite often there will be parts in a template that do not contain any dynamic bindings:\ntemplate\n<div>\n<div>foo</div> <!-- hoisted -->\n<div>bar</div> <!-- hoisted -->\n<div>{{ dynamic }}</div>\n</div>\nThe foo\nand bar\ndivs are static - re-creating vnodes and diffing them on each re-render is unnecessary. The Vue compiler automatically hoists their vnode creation calls out of the render function, and reuses the same vnodes on every render. The renderer is also able to completely skip diffing them when it notices the old vnode and the new vnode are the same one.\nIn addition, when there are enough consecutive static elements, they will be condensed into a single \"static vnode\" that contains the plain HTML string for all these nodes (Example). These static vnodes are mounted by directly setting innerHTML\n. They also cache their corresponding DOM nodes on initial mount - if the same piece of content is reused elsewhere in the app, new DOM nodes are created using native cloneNode()\n, which is extremely efficient.\nPatch Flags\nFor a single element with dynamic bindings, we can also infer a lot of information from it at compile time:\ntemplate\n<!-- class binding only -->\n<div :class=\"{ active }\"></div>\n<!-- id and value bindings only -->\n<input :id=\"id\" :value=\"value\">\n<!-- text children only -->\n<div>{{ dynamic }}</div>\nWhen generating the render function code for these elements, Vue encodes the type of update each of them needs directly in the vnode creation call:\njs\ncreateElementVNode(\"div\", {\nclass: _normalizeClass({ active: _ctx.active })\n}, null, 2 /* CLASS */)\nThe last argument, 2\n, is a patch flag. An element can have multiple patch flags, which will be merged into a single number. The runtime renderer can then check against the flags using bitwise operations to determine whether it needs to do certain work:\njs\nif (vnode.patchFlag & PatchFlags.CLASS /* 2 */) {\n// update the element's class\n}\nBitwise checks are extremely fast. With the patch flags, Vue is able to do the least amount of work necessary when updating elements with dynamic bindings.\nVue also encodes the type of children a vnode has. For example, a template that has multiple root nodes is represented as a fragment. In most cases, we know for sure that the order of these root nodes will never change, so this information can also be provided to the runtime as a patch flag:\njs\nexport function render() {\nreturn (_openBlock(), _createElementBlock(_Fragment, null, [\n/* children */\n], 64 /* STABLE_FRAGMENT */))\n}\nThe runtime can thus completely skip child-order reconciliation for the root fragment.\nTree Flattening\nTaking another look at the generated code from the previous example, you'll notice the root of the returned virtual DOM tree is created using a special createElementBlock()\ncall:\njs\nexport function render() {\nreturn (_openBlock(), _createElementBlock(_Fragment, null, [\n/* children */\n], 64 /* STABLE_FRAGMENT */))\n}\nConceptually, a \"block\" is a part of the template that has stable inner structure. In this case, the entire template has a single block because it does not contain any structural directives like v-if\nand v-for\n.\nEach block tracks any descendant nodes (not just direct children) that have patch flags. For example:\ntemplate\n<div> <!-- root block -->\n<div>...</div> <!-- not tracked -->\n<div :id=\"id\"></div> <!-- tracked -->\n<div> <!-- not tracked -->\n<div>{{ bar }}</div> <!-- tracked -->\n</div>\n</div>\nThe result is a flattened array that contains only the dynamic descendant nodes:\ndiv (block root)\n- div with :id binding\n- div with {{ bar }} binding\nWhen this component needs to re-render, it only needs to traverse the flattened tree instead of the full tree. This is called Tree Flattening, and it greatly reduces the number of nodes that need to be traversed during virtual DOM reconciliation. Any static parts of the template are effectively skipped.\nv-if\nand v-for\ndirectives will create new block nodes:\ntemplate\n<div> <!-- root block -->\n<div>\n<div v-if> <!-- if block -->\n...\n</div>\n</div>\n</div>\nA child block is tracked inside the parent block's array of dynamic descendants. This retains a stable structure for the parent block.\nImpact on SSR Hydration\nBoth patch flags and tree flattening also greatly improve Vue's SSR Hydration performance:\nSingle element hydration can take fast paths based on the corresponding vnode's patch flag.\nOnly block nodes and their dynamic descendants need to be traversed during hydration, effectively achieving partial hydration at the template level.",
    "metadata": {
      "source": "https://vuejs.org/guide/extras/rendering-mechanism",
      "title": "Rendering Mechanism | Vue.js"
    }
  },
  {
    "page_content": "Provide / Inject\nThis page assumes you've already read the Components Basics. Read that first if you are new to components.\nProp Drilling\nUsually, when we need to pass data from the parent to a child component, we use props. However, imagine the case where we have a large component tree, and a deeply nested component needs something from a distant ancestor component. With only props, we would have to pass the same prop across the entire parent chain:\nNotice although the <Footer>\ncomponent may not care about these props at all, it still needs to declare and pass them along just so <DeepChild>\ncan access them. If there is a longer parent chain, more components would be affected along the way. This is called \"props drilling\" and definitely isn't fun to deal with.\nWe can solve props drilling with provide\nand inject\n. A parent component can serve as a dependency provider for all its descendants. Any component in the descendant tree, regardless of how deep it is, can inject dependencies provided by components up in its parent chain.\nProvide\nTo provide data to a component's descendants, use the provide()\nfunction:\nvue\n<script setup>\nimport { provide } from 'vue'\nprovide(/* key */ 'message', /* value */ 'hello!')\n</script>\nIf not using <script setup>\n, make sure provide()\nis called synchronously inside setup()\n:\njs\nimport { provide } from 'vue'\nexport default {\nsetup() {\nprovide(/* key */ 'message', /* value */ 'hello!')\n}\n}\nThe provide()\nfunction accepts two arguments. The first argument is called the injection key, which can be a string or a Symbol\n. The injection key is used by descendant components to lookup the desired value to inject. A single component can call provide()\nmultiple times with different injection keys to provide different values.\nThe second argument is the provided value. The value can be of any type, including reactive state such as refs:\njs\nimport { ref, provide } from 'vue'\nconst count = ref(0)\nprovide('key', count)\nProviding reactive values allows the descendant components using the provided value to establish a reactive connection to the provider component.\nApp-level Provide\nIn addition to providing data in a component, we can also provide at the app level:\njs\nimport { createApp } from 'vue'\nconst app = createApp({})\napp.provide(/* key */ 'message', /* value */ 'hello!')\nApp-level provides are available to all components rendered in the app. This is especially useful when writing plugins, as plugins typically wouldn't be able to provide values using components.\nInject\nTo inject data provided by an ancestor component, use the inject()\nfunction:\nvue\n<script setup>\nimport { inject } from 'vue'\nconst message = inject('message')\n</script>\nIf the provided value is a ref, it will be injected as-is and will not be automatically unwrapped. This allows the injector component to retain the reactivity connection to the provider component.\nFull provide + inject Example with Reactivity\nAgain, if not using <script setup>\n, inject()\nshould only be called synchronously inside setup()\n:\njs\nimport { inject } from 'vue'\nexport default {\nsetup() {\nconst message = inject('message')\nreturn { message }\n}\n}\nInjection Default Values\nBy default, inject\nassumes that the injected key is provided somewhere in the parent chain. In the case where the key is not provided, there will be a runtime warning.\nIf we want to make an injected property work with optional providers, we need to declare a default value, similar to props:\njs\n// `value` will be \"default value\"\n// if no data matching \"message\" was provided\nconst value = inject('message', 'default value')\nIn some cases, the default value may need to be created by calling a function or instantiating a new class. To avoid unnecessary computation or side effects in case the optional value is not used, we can use a factory function for creating the default value:\njs\nconst value = inject('key', () => new ExpensiveClass(), true)\nThe third parameter indicates the default value should be treated as a factory function.\nWorking with Reactivity\nWhen using reactive provide / inject values, it is recommended to keep any mutations to reactive state inside of the provider whenever possible. This ensures that the provided state and its possible mutations are co-located in the same component, making it easier to maintain in the future.\nThere may be times when we need to update the data from an injector component. In such cases, we recommend providing a function that is responsible for mutating the state:\nvue\n<!-- inside provider component -->\n<script setup>\nimport { provide, ref } from 'vue'\nconst location = ref('North Pole')\nfunction updateLocation() {\nlocation.value = 'South Pole'\n}\nprovide('location', {\nlocation,\nupdateLocation\n})\n</script>\nvue\n<!-- in injector component -->\n<script setup>\nimport { inject } from 'vue'\nconst { location, updateLocation } = inject('location')\n</script>\n<template>\n<button @click=\"updateLocation\">{{ location }}</button>\n</template>\nFinally, you can wrap the provided value with readonly()\nif you want to ensure that the data passed through provide\ncannot be mutated by the injector component.\nvue\n<script setup>\nimport { ref, provide, readonly } from 'vue'\nconst count = ref(0)\nprovide('read-only-count', readonly(count))\n</script>\nWorking with Symbol Keys\nSo far, we have been using string injection keys in the examples. If you are working in a large application with many dependency providers, or you are authoring components that are going to be used by other developers, it is best to use Symbol injection keys to avoid potential collisions.\nIt's recommended to export the Symbols in a dedicated file:\njs\n// keys.js\nexport const myInjectionKey = Symbol()\njs\n// in provider component\nimport { provide } from 'vue'\nimport { myInjectionKey } from './keys.js'\nprovide(myInjectionKey, {\n/* data to provide */\n})\njs\n// in injector component\nimport { inject } from 'vue'\nimport { myInjectionKey } from './keys.js'\nconst injected = inject(myInjectionKey)\nSee also: Typing Provide / Inject",
    "metadata": {
      "source": "https://vuejs.org/guide/components/provide-inject",
      "title": "Provide / Inject | Vue.js"
    }
  },
  {
    "page_content": "Form Input Bindings\nWhen dealing with forms on the frontend, we often need to sync the state of form input elements with corresponding state in JavaScript. It can be cumbersome to manually wire up value bindings and change event listeners:\ntemplate\n<input\n:value=\"text\"\n@input=\"event => text = event.target.value\">\nThe v-model\ndirective helps us simplify the above to:\ntemplate\n<input v-model=\"text\">\nIn addition, v-model\ncan be used on inputs of different types, <textarea>\n, and <select>\nelements. It automatically expands to different DOM property and event pairs based on the element it is used on:\n<input>\nwith text types and<textarea>\nelements usevalue\nproperty andinput\nevent;<input type=\"checkbox\">\nand<input type=\"radio\">\nusechecked\nproperty andchange\nevent;<select>\nusesvalue\nas a prop andchange\nas an event.\nNote\nv-model\nwill ignore the initial value\n, checked\nor selected\nattributes found on any form elements. It will always treat the current bound JavaScript state as the source of truth. You should declare the initial value on the JavaScript side, using reactivity APIs.\nBasic Usage\nText\ntemplate\n<p>Message is: {{ message }}</p>\n<input v-model=\"message\" placeholder=\"edit me\" />\nMessage is:\nNote\nFor languages that require an IME (Chinese, Japanese, Korean etc.), you'll notice that v-model\ndoesn't get updated during IME composition. If you want to respond to these updates as well, use your own input\nevent listener and value\nbinding instead of using v-model\n.\nMultiline text\ntemplate\n<span>Multiline message is:</span>\n<p style=\"white-space: pre-line;\">{{ message }}</p>\n<textarea v-model=\"message\" placeholder=\"add multiple lines\"></textarea>\nMultiline message is:\nNote that interpolation inside <textarea>\nwon't work. Use v-model\ninstead.\ntemplate\n<!-- bad -->\n<textarea>{{ text }}</textarea>\n<!-- good -->\n<textarea v-model=\"text\"></textarea>\nCheckbox\nSingle checkbox, boolean value:\ntemplate\n<input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\" />\n<label for=\"checkbox\">{{ checked }}</label>\nWe can also bind multiple checkboxes to the same array or Set value:\njs\nconst checkedNames = ref([])\ntemplate\n<div>Checked names: {{ checkedNames }}</div>\n<input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\" />\n<label for=\"jack\">Jack</label>\n<input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\" />\n<label for=\"john\">John</label>\n<input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\" />\n<label for=\"mike\">Mike</label>\nChecked names: []\nIn this case, the checkedNames\narray will always contain the values from the currently checked boxes.\nRadio\ntemplate\n<div>Picked: {{ picked }}</div>\n<input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\" />\n<label for=\"one\">One</label>\n<input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\" />\n<label for=\"two\">Two</label>\nPicked:\nSelect\nSingle select:\ntemplate\n<div>Selected: {{ selected }}</div>\n<select v-model=\"selected\">\n<option disabled value=\"\">Please select one</option>\n<option>A</option>\n<option>B</option>\n<option>C</option>\n</select>\nSelected:\nNote\nIf the initial value of your v-model\nexpression does not match any of the options, the <select>\nelement will render in an \"unselected\" state. On iOS this will cause the user not being able to select the first item because iOS does not fire a change event in this case. It is therefore recommended to provide a disabled option with an empty value, as demonstrated in the example above.\nMultiple select (bound to array):\ntemplate\n<div>Selected: {{ selected }}</div>\n<select v-model=\"selected\" multiple>\n<option>A</option>\n<option>B</option>\n<option>C</option>\n</select>\nSelected: []\nSelect options can be dynamically rendered with v-for\n:\njs\nconst selected = ref('A')\nconst options = ref([\n{ text: 'One', value: 'A' },\n{ text: 'Two', value: 'B' },\n{ text: 'Three', value: 'C' }\n])\ntemplate\n<select v-model=\"selected\">\n<option v-for=\"option in options\" :value=\"option.value\">\n{{ option.text }}\n</option>\n</select>\n<div>Selected: {{ selected }}</div>\nValue Bindings\nFor radio, checkbox and select options, the v-model\nbinding values are usually static strings (or booleans for checkbox):\ntemplate\n<!-- `picked` is a string \"a\" when checked -->\n<input type=\"radio\" v-model=\"picked\" value=\"a\" />\n<!-- `toggle` is either true or false -->\n<input type=\"checkbox\" v-model=\"toggle\" />\n<!-- `selected` is a string \"abc\" when the first option is selected -->\n<select v-model=\"selected\">\n<option value=\"abc\">ABC</option>\n</select>\nBut sometimes we may want to bind the value to a dynamic property on the current active instance. We can use v-bind\nto achieve that. In addition, using v-bind\nallows us to bind the input value to non-string values.\nCheckbox\ntemplate\n<input\ntype=\"checkbox\"\nv-model=\"toggle\"\ntrue-value=\"yes\"\nfalse-value=\"no\" />\ntrue-value\nand false-value\nare Vue-specific attributes that only work with v-model\n. Here the toggle\nproperty's value will be set to 'yes'\nwhen the box is checked, and set to 'no'\nwhen unchecked. You can also bind them to dynamic values using v-bind\n:\ntemplate\n<input\ntype=\"checkbox\"\nv-model=\"toggle\"\n:true-value=\"dynamicTrueValue\"\n:false-value=\"dynamicFalseValue\" />\nTip\nThe true-value\nand false-value\nattributes don't affect the input's value\nattribute, because browsers don't include unchecked boxes in form submissions. To guarantee that one of two values is submitted in a form (e.g. \"yes\" or \"no\"), use radio inputs instead.\nRadio\ntemplate\n<input type=\"radio\" v-model=\"pick\" :value=\"first\" />\n<input type=\"radio\" v-model=\"pick\" :value=\"second\" />\npick\nwill be set to the value of first\nwhen the first radio input is checked, and set to the value of second\nwhen the second one is checked.\nSelect Options\ntemplate\n<select v-model=\"selected\">\n<!-- inline object literal -->\n<option :value=\"{ number: 123 }\">123</option>\n</select>\nv-model\nsupports value bindings of non-string values as well! In the above example, when the option is selected, selected\nwill be set to the object literal value of { number: 123 }\n.\nModifiers\n.lazy\nBy default, v-model\nsyncs the input with the data after each input\nevent (with the exception of IME composition as stated above). You can add the lazy\nmodifier to instead sync after change\nevents:\ntemplate\n<!-- synced after \"change\" instead of \"input\" -->\n<input v-model.lazy=\"msg\" />\n.number\nIf you want user input to be automatically typecast as a number, you can add the number\nmodifier to your v-model\nmanaged inputs:\ntemplate\n<input v-model.number=\"age\" />\nIf the value cannot be parsed with parseFloat()\n, then the original value is used instead.\nThe number\nmodifier is applied automatically if the input has type=\"number\"\n.\n.trim\nIf you want whitespace from user input to be trimmed automatically, you can add the trim\nmodifier to your v-model\n-managed inputs:\ntemplate\n<input v-model.trim=\"msg\" />\nv-model\nwith Components\nIf you're not yet familiar with Vue's components, you can skip this for now.\nHTML's built-in input types won't always meet your needs. Fortunately, Vue components allow you to build reusable inputs with completely customized behavior. These inputs even work with v-model\n! To learn more, read about Usage with v-model\nin the Components guide.",
    "metadata": {
      "source": "https://vuejs.org/guide/essentials/forms",
      "title": "Form Input Bindings | Vue.js"
    }
  },
  {
    "page_content": "Suspense\nExperimental Feature\n<Suspense>\nis an experimental feature. It is not guaranteed to reach stable status and the API may change before it does.\n<Suspense>\nis a built-in component for orchestrating async dependencies in a component tree. It can render a loading state while waiting for multiple nested async dependencies down the component tree to be resolved.\nAsync Dependencies\nTo explain the problem <Suspense>\nis trying to solve and how it interacts with these async dependencies, let's imagine a component hierarchy like the following:\n<Suspense>\n└─ <Dashboard>\n├─ <Profile>\n│ └─ <FriendStatus> (component with async setup())\n└─ <Content>\n├─ <ActivityFeed> (async component)\n└─ <Stats> (async component)\nIn the component tree there are multiple nested components whose rendering depends on some async resource to be resolved first. Without <Suspense>\n, each of them will need to handle its own loading / error and loaded states. In the worst case scenario, we may see three loading spinners on the page, with content displayed at different times.\nThe <Suspense>\ncomponent gives us the ability to display top-level loading / error states while we wait on these nested async dependencies to be resolved.\nThere are two types of async dependencies that <Suspense>\ncan wait on:\nComponents with an async\nsetup()\nhook. This includes components using<script setup>\nwith top-levelawait\nexpressions.\nasync setup()\nA Composition API component's setup()\nhook can be async:\njs\nexport default {\nasync setup() {\nconst res = await fetch(...)\nconst posts = await res.json()\nreturn {\nposts\n}\n}\n}\nIf using <script setup>\n, the presence of top-level await\nexpressions automatically makes the component an async dependency:\nvue\n<script setup>\nconst res = await fetch(...)\nconst posts = await res.json()\n</script>\n<template>\n{{ posts }}\n</template>\nAsync Components\nAsync components are \"suspensible\" by default. This means that if it has a <Suspense>\nin the parent chain, it will be treated as an async dependency of that <Suspense>\n. In this case, the loading state will be controlled by the <Suspense>\n, and the component's own loading, error, delay and timeout options will be ignored.\nThe async component can opt-out of Suspense\ncontrol and let the component always control its own loading state by specifying suspensible: false\nin its options.\nLoading State\nThe <Suspense>\ncomponent has two slots: #default\nand #fallback\n. Both slots only allow for one immediate child node. The node in the default slot is shown if possible. If not, the node in the fallback slot will be shown instead.\ntemplate\n<Suspense>\n<!-- component with nested async dependencies -->\n<Dashboard />\n<!-- loading state via #fallback slot -->\n<template #fallback>\nLoading...\n</template>\n</Suspense>\nOn initial render, <Suspense>\nwill render its default slot content in memory. If any async dependencies are encountered during the process, it will enter a pending state. During the pending state, the fallback content will be displayed. When all encountered async dependencies have been resolved, <Suspense>\nenters a resolved state and the resolved default slot content is displayed.\nIf no async dependencies were encountered during the initial render, <Suspense>\nwill directly go into a resolved state.\nOnce in a resolved state, <Suspense>\nwill only revert to a pending state if the root node of the #default\nslot is replaced. New async dependencies nested deeper in the tree will not cause the <Suspense>\nto revert to a pending state.\nWhen a revert happens, fallback content will not be immediately displayed. Instead, <Suspense>\nwill display the previous #default\ncontent while waiting for the new content and its async dependencies to be resolved. This behavior can be configured with the timeout\nprop: <Suspense>\nwill switch to fallback content if it takes longer than timeout\nto render the new default content. A timeout\nvalue of 0\nwill cause the fallback content to be displayed immediately when default content is replaced.\nEvents\nThe <Suspense>\ncomponent emits 3 events: pending\n, resolve\nand fallback\n. The pending\nevent occurs when entering a pending state. The resolve\nevent is emitted when new content has finished resolving in the default\nslot. The fallback\nevent is fired when the contents of the fallback\nslot are shown.\nThe events could be used, for example, to show a loading indicator in front of the old DOM while new components are loading.\nError Handling\n<Suspense>\ncurrently does not provide error handling via the component itself - however, you can use the errorCaptured\noption or the onErrorCaptured()\nhook to capture and handle async errors in the parent component of <Suspense>\n.\nCombining with Other Components\nIt is common to want to use <Suspense>\nin combination with the <Transition>\nand <KeepAlive>\ncomponents. The nesting order of these components is important to get them all working correctly.\nIn addition, these components are often used in conjunction with the <RouterView>\ncomponent from Vue Router.\nThe following example shows how to nest these components so that they all behave as expected. For simpler combinations you can remove the components that you don't need:\ntemplate\n<RouterView v-slot=\"{ Component }\">\n<template v-if=\"Component\">\n<Transition mode=\"out-in\">\n<KeepAlive>\n<Suspense>\n<!-- main content -->\n<component :is=\"Component\"></component>\n<!-- loading state -->\n<template #fallback>\nLoading...\n</template>\n</Suspense>\n</KeepAlive>\n</Transition>\n</template>\n</RouterView>\nVue Router has built-in support for lazily loading components using dynamic imports. These are distinct from async components and currently they will not trigger <Suspense>\n. However, they can still have async components as descendants and those can trigger <Suspense>\nin the usual way.\nNested Suspense\nWhen we have multiple async components (common for nested or layout-based routes) like this:\ntemplate\n<Suspense>\n<component :is=\"DynamicAsyncOuter\">\n<component :is=\"DynamicAsyncInner\" />\n</component>\n</Suspense>\n<Suspense>\ncreates a boundary that will resolve all the async components down the tree, as expected. However, when we change DynamicAsyncOuter\n, <Suspense>\nawaits it correctly, but when we change DynamicAsyncInner\n, the nested DynamicAsyncInner\nrenders an empty node until it has been resolved (instead of the previous one or fallback slot).\nIn order to solve that, we could have a nested suspense to handle the patch for the nested component, like:\ntemplate\n<Suspense>\n<component :is=\"DynamicAsyncOuter\">\n<Suspense suspensible> <!-- this -->\n<component :is=\"DynamicAsyncInner\" />\n</Suspense>\n</component>\n</Suspense>\nIf you don't set the suspensible\nprop, the inner <Suspense>\nwill be treated like a sync component by the parent <Suspense>\n. That means that it has its own fallback slot and if both Dynamic\ncomponents change at the same time, there might be empty nodes and multiple patching cycles while the child <Suspense>\nis loading its own dependency tree, which might not be desirable. When it's set, all the async dependency handling is given to the parent <Suspense>\n(including the events emitted) and the inner <Suspense>\nserves solely as another boundary for the dependency resolution and patching.\nRelated",
    "metadata": {
      "source": "https://vuejs.org/guide/built-ins/suspense",
      "title": "Suspense | Vue.js"
    }
  },
  {
    "page_content": "Fallthrough Attributes\nThis page assumes you've already read the Components Basics. Read that first if you are new to components.\nAttribute Inheritance\nA \"fallthrough attribute\" is an attribute or v-on\nevent listener that is passed to a component, but is not explicitly declared in the receiving component's props or emits. Common examples of this include class\n, style\n, and id\nattributes.\nWhen a component renders a single root element, fallthrough attributes will be automatically added to the root element's attributes. For example, given a <MyButton>\ncomponent with the following template:\ntemplate\n<!-- template of <MyButton> -->\n<button>Click Me</button>\nAnd a parent using this component with:\ntemplate\n<MyButton class=\"large\" />\nThe final rendered DOM would be:\nhtml\n<button class=\"large\">Click Me</button>\nHere, <MyButton>\ndid not declare class\nas an accepted prop. Therefore, class\nis treated as a fallthrough attribute and automatically added to <MyButton>\n's root element.\nclass\nand style\nMerging\nIf the child component's root element already has existing class\nor style\nattributes, it will be merged with the class\nand style\nvalues that are inherited from the parent. Suppose we change the template of <MyButton>\nin the previous example to:\ntemplate\n<!-- template of <MyButton> -->\n<button class=\"btn\">Click Me</button>\nThen the final rendered DOM would now become:\nhtml\n<button class=\"btn large\">Click Me</button>\nv-on\nListener Inheritance\nThe same rule applies to v-on\nevent listeners:\ntemplate\n<MyButton @click=\"onClick\" />\nThe click\nlistener will be added to the root element of <MyButton>\n, i.e. the native <button>\nelement. When the native <button>\nis clicked, it will trigger the onClick\nmethod of the parent component. If the native <button>\nalready has a click\nlistener bound with v-on\n, then both listeners will trigger.\nNested Component Inheritance\nIf a component renders another component as its root node, for example, we refactored <MyButton>\nto render a <BaseButton>\nas its root:\ntemplate\n<!-- template of <MyButton/> that simply renders another component -->\n<BaseButton />\nThen the fallthrough attributes received by <MyButton>\nwill be automatically forwarded to <BaseButton>\n.\nNote that:\nForwarded attributes do not include any attributes that are declared as props, or\nv-on\nlisteners of declared events by<MyButton>\n- in other words, the declared props and listeners have been \"consumed\" by<MyButton>\n.Forwarded attributes may be accepted as props by\n<BaseButton>\n, if declared by it.\nDisabling Attribute Inheritance\nIf you do not want a component to automatically inherit attributes, you can set inheritAttrs: false\nin the component's options.\nSince 3.3 you can also use defineOptions\ndirectly in <script setup>\n:\nvue\n<script setup>\ndefineOptions({\ninheritAttrs: false\n})\n// ...setup logic\n</script>\nThe common scenario for disabling attribute inheritance is when attributes need to be applied to other elements besides the root node. By setting the inheritAttrs\noption to false\n, you can take full control over where the fallthrough attributes should be applied.\nThese fallthrough attributes can be accessed directly in template expressions as $attrs\n:\ntemplate\n<span>Fallthrough attributes: {{ $attrs }}</span>\nThe $attrs\nobject includes all attributes that are not declared by the component's props\nor emits\noptions (e.g., class\n, style\n, v-on\nlisteners, etc.).\nSome notes:\nUnlike props, fallthrough attributes preserve their original casing in JavaScript, so an attribute like\nfoo-bar\nneeds to be accessed as$attrs['foo-bar']\n.A\nv-on\nevent listener like@click\nwill be exposed on the object as a function under$attrs.onClick\n.\nUsing our <MyButton>\ncomponent example from the previous section - sometimes we may need to wrap the actual <button>\nelement with an extra <div>\nfor styling purposes:\ntemplate\n<div class=\"btn-wrapper\">\n<button class=\"btn\">Click Me</button>\n</div>\nWe want all fallthrough attributes like class\nand v-on\nlisteners to be applied to the inner <button>\n, not the outer <div>\n. We can achieve this with inheritAttrs: false\nand v-bind=\"$attrs\"\n:\ntemplate\n<div class=\"btn-wrapper\">\n<button class=\"btn\" v-bind=\"$attrs\">Click Me</button>\n</div>\nRemember that v-bind\nwithout an argument binds all the properties of an object as attributes of the target element.\nAttribute Inheritance on Multiple Root Nodes\nUnlike components with a single root node, components with multiple root nodes do not have an automatic attribute fallthrough behavior. If $attrs\nare not bound explicitly, a runtime warning will be issued.\ntemplate\n<CustomLayout id=\"custom-layout\" @click=\"changeValue\" />\nIf <CustomLayout>\nhas the following multi-root template, there will be a warning because Vue cannot be sure where to apply the fallthrough attributes:\ntemplate\n<header>...</header>\n<main>...</main>\n<footer>...</footer>\nThe warning will be suppressed if $attrs\nis explicitly bound:\ntemplate\n<header>...</header>\n<main v-bind=\"$attrs\">...</main>\n<footer>...</footer>\nAccessing Fallthrough Attributes in JavaScript\nIf needed, you can access a component's fallthrough attributes in <script setup>\nusing the useAttrs()\nAPI:\nvue\n<script setup>\nimport { useAttrs } from 'vue'\nconst attrs = useAttrs()\n</script>\nIf not using <script setup>\n, attrs\nwill be exposed as a property of the setup()\ncontext:\njs\nexport default {\nsetup(props, ctx) {\n// fallthrough attributes are exposed as ctx.attrs\nconsole.log(ctx.attrs)\n}\n}\nNote that although the attrs\nobject here always reflects the latest fallthrough attributes, it isn't reactive (for performance reasons). You cannot use watchers to observe its changes. If you need reactivity, use a prop. Alternatively, you can use onUpdated()\nto perform side effects with the latest attrs\non each update.",
    "metadata": {
      "source": "https://vuejs.org/guide/components/attrs",
      "title": "Fallthrough Attributes | Vue.js"
    }
  },
  {
    "page_content": "Reactivity Fundamentals\nAPI Preference\nThis page and many other chapters later in the guide contain different content for the Options API and the Composition API. Your current preference is Composition API. You can toggle between the API styles using the \"API Preference\" switches at the top of the left sidebar.\nDeclaring Reactive State\nref()\nIn Composition API, the recommended way to declare reactive state is using the ref()\nfunction:\njs\nimport { ref } from 'vue'\nconst count = ref(0)\nref()\ntakes the argument and returns it wrapped within a ref object with a .value\nproperty:\njs\nconst count = ref(0)\nconsole.log(count) // { value: 0 }\nconsole.log(count.value) // 0\ncount.value++\nconsole.log(count.value) // 1\nSee also: Typing Refs\nTo access refs in a component's template, declare and return them from a component's setup()\nfunction:\njs\nimport { ref } from 'vue'\nexport default {\n// `setup` is a special hook dedicated for the Composition API.\nsetup() {\nconst count = ref(0)\n// expose the ref to the template\nreturn {\ncount\n}\n}\n}\ntemplate\n<div>{{ count }}</div>\nNotice that we did not need to append .value\nwhen using the ref in the template. For convenience, refs are automatically unwrapped when used inside templates (with a few caveats).\nYou can also mutate a ref directly in event handlers:\ntemplate\n<button @click=\"count++\">\n{{ count }}\n</button>\nFor more complex logic, we can declare functions that mutate refs in the same scope and expose them as methods alongside the state:\njs\nimport { ref } from 'vue'\nexport default {\nsetup() {\nconst count = ref(0)\nfunction increment() {\n// .value is needed in JavaScript\ncount.value++\n}\n// don't forget to expose the function as well.\nreturn {\ncount,\nincrement\n}\n}\n}\nExposed methods can then be used as event handlers:\ntemplate\n<button @click=\"increment\">\n{{ count }}\n</button>\nHere's the example live on Codepen, without using any build tools.\n<script setup>\nManually exposing state and methods via setup()\ncan be verbose. Luckily, it can be avoided when using Single-File Components (SFCs). We can simplify the usage with <script setup>\n:\nvue\n<script setup>\nimport { ref } from 'vue'\nconst count = ref(0)\nfunction increment() {\ncount.value++\n}\n</script>\n<template>\n<button @click=\"increment\">\n{{ count }}\n</button>\n</template>\nTop-level imports, variables and functions declared in <script setup>\nare automatically usable in the template of the same component. Think of the template as a JavaScript function declared in the same scope - it naturally has access to everything declared alongside it.\nTIP\nFor the rest of the guide, we will be primarily using SFC + <script setup>\nsyntax for the Composition API code examples, as that is the most common usage for Vue developers.\nIf you are not using SFC, you can still use Composition API with the setup()\noption.\nWhy Refs?\nYou might be wondering why we need refs with the .value\ninstead of plain variables. To explain that, we will need to briefly discuss how Vue's reactivity system works.\nWhen you use a ref in a template, and change the ref's value later, Vue automatically detects the change and updates the DOM accordingly. This is made possible with a dependency-tracking based reactivity system. When a component is rendered for the first time, Vue tracks every ref that was used during the render. Later on, when a ref is mutated, it will trigger a re-render for components that are tracking it.\nIn standard JavaScript, there is no way to detect the access or mutation of plain variables. However, we can intercept the get and set operations of an object's properties using getter and setter methods.\nThe .value\nproperty gives Vue the opportunity to detect when a ref has been accessed or mutated. Under the hood, Vue performs the tracking in its getter, and performs triggering in its setter. Conceptually, you can think of a ref as an object that looks like this:\njs\n// pseudo code, not actual implementation\nconst myRef = {\n_value: 0,\nget value() {\ntrack()\nreturn this._value\n},\nset value(newValue) {\nthis._value = newValue\ntrigger()\n}\n}\nAnother nice trait of refs is that unlike plain variables, you can pass refs into functions while retaining access to the latest value and the reactivity connection. This is particularly useful when refactoring complex logic into reusable code.\nThe reactivity system is discussed in more details in the Reactivity in Depth section.\nDeep Reactivity\nRefs can hold any value type, including deeply nested objects, arrays, or JavaScript built-in data structures like Map\n.\nA ref will make its value deeply reactive. This means you can expect changes to be detected even when you mutate nested objects or arrays:\njs\nimport { ref } from 'vue'\nconst obj = ref({\nnested: { count: 0 },\narr: ['foo', 'bar']\n})\nfunction mutateDeeply() {\n// these will work as expected.\nobj.value.nested.count++\nobj.value.arr.push('baz')\n}\nNon-primitive values are turned into reactive proxies via reactive()\n, which is discussed below.\nIt is also possible to opt-out of deep reactivity with shallow refs. For shallow refs, only .value\naccess is tracked for reactivity. Shallow refs can be used for optimizing performance by avoiding the observation cost of large objects, or in cases where the inner state is managed by an external library.\nFurther reading:\nDOM Update Timing\nWhen you mutate reactive state, the DOM is updated automatically. However, it should be noted that the DOM updates are not applied synchronously. Instead, Vue buffers them until the \"next tick\" in the update cycle to ensure that each component updates only once no matter how many state changes you have made.\nTo wait for the DOM update to complete after a state change, you can use the nextTick() global API:\njs\nimport { nextTick } from 'vue'\nasync function increment() {\ncount.value++\nawait nextTick()\n// Now the DOM is updated\n}\nreactive()\nThere is another way to declare reactive state, with the reactive()\nAPI. Unlike a ref which wraps the inner value in a special object, reactive()\nmakes an object itself reactive:\njs\nimport { reactive } from 'vue'\nconst state = reactive({ count: 0 })\nSee also: Typing Reactive\nUsage in template:\ntemplate\n<button @click=\"state.count++\">\n{{ state.count }}\n</button>\nReactive objects are JavaScript Proxies and behave just like normal objects. The difference is that Vue is able to intercept the access and mutation of all properties of a reactive object for reactivity tracking and triggering.\nreactive()\nconverts the object deeply: nested objects are also wrapped with reactive()\nwhen accessed. It is also called by ref()\ninternally when the ref value is an object. Similar to shallow refs, there is also the shallowReactive()\nAPI for opting-out of deep reactivity.\nReactive Proxy vs. Original\nIt is important to note that the returned value from reactive()\nis a Proxy of the original object, which is not equal to the original object:\njs\nconst raw = {}\nconst proxy = reactive(raw)\n// proxy is NOT equal to the original.\nconsole.log(proxy === raw) // false\nOnly the proxy is reactive - mutating the original object will not trigger updates. Therefore, the best practice when working with Vue's reactivity system is to exclusively use the proxied versions of your state.\nTo ensure consistent access to the proxy, calling reactive()\non the same object always returns the same proxy, and calling reactive()\non an existing proxy also returns that same proxy:\njs\n// calling reactive() on the same object returns the same proxy\nconsole.log(reactive(raw) === proxy) // true\n// calling reactive() on a proxy returns itself\nconsole.log(reactive(proxy) === proxy) // true\nThis rule applies to nested objects as well. Due to deep reactivity, nested objects inside a reactive object are also proxies:\njs\nconst proxy = reactive({})\nconst raw = {}\nproxy.nested = raw\nconsole.log(proxy.nested === raw) // false\nLimitations of reactive()\nThe reactive()\nAPI has a few limitations:\nLimited value types: it only works for object types (objects, arrays, and collection types such as\nMap\nandSet\n). It cannot hold primitive types such asstring\n,number\norboolean\n.Cannot replace entire object: since Vue's reactivity tracking works over property access, we must always keep the same reference to the reactive object. This means we can't easily \"replace\" a reactive object because the reactivity connection to the first reference is lost:\njslet state = reactive({ count: 0 }) // the above reference ({ count: 0 }) is no longer being tracked // (reactivity connection is lost!) state = reactive({ count: 1 })\nNot destructure-friendly: when we destructure a reactive object's primitive type property into local variables, or when we pass that property into a function, we will lose the reactivity connection:\njsconst state = reactive({ count: 0 }) // count is disconnected from state.count when destructured. let { count } = state // does not affect original state count++ // the function receives a plain number and // won't be able to track changes to state.count // we have to pass the entire object in to retain reactivity callSomeFunction(state.count)\nDue to these limitations, we recommend using ref()\nas the primary API for declaring reactive state.\nAdditional Ref Unwrapping Details\nAs Reactive Object Property\nA ref is automatically unwrapped when accessed or mutated as a property of a reactive object. In other words, it behaves like a normal property :\njs\nconst count = ref(0)\nconst state = reactive({\ncount\n})\nconsole.log(state.count) // 0\nstate.count = 1\nconsole.log(count.value) // 1\nIf a new ref is assigned to a property linked to an existing ref, it will replace the old ref:\njs\nconst otherCount = ref(2)\nstate.count = otherCount\nconsole.log(state.count) // 2\n// original ref is now disconnected from state.count\nconsole.log(count.value) // 1\nRef unwrapping only happens when nested inside a deep reactive object. It does not apply when it is accessed as a property of a shallow reactive object.\nCaveat in Arrays and Collections\nUnlike reactive objects, there is no unwrapping performed when the ref is accessed as an element of a reactive array or a native collection type like Map\n:\njs\nconst books = reactive([ref('Vue 3 Guide')])\n// need .value here\nconsole.log(books[0].value)\nconst map = reactive(new Map([['count', ref(0)]]))\n// need .value here\nconsole.log(map.get('count').value)\nCaveat when Unwrapping in Templates\nRef unwrapping in templates only applies if the ref is a top-level property in the template render context.\nIn the example below, count\nand object\nare top-level properties, but object.id\nis not:\njs\nconst count = ref(0)\nconst object = { id: ref(1) }\nTherefore, this expression works as expected:\ntemplate\n{{ count + 1 }}\n...while this one does NOT:\ntemplate\n{{ object.id + 1 }}\nThe rendered result will be [object Object]1\nbecause object.id\nis not unwrapped when evaluating the expression and remains a ref object. To fix this, we can destructure id\ninto a top-level property:\njs\nconst { id } = object\ntemplate\n{{ id + 1 }}\nNow the render result will be 2\n.\nAnother thing to note is that a ref does get unwrapped if it is the final evaluated value of a text interpolation (i.e. a {{ }}\ntag), so the following will render 1\n:\ntemplate\n{{ object.id }}\nThis is just a convenience feature of text interpolation and is equivalent to {{ object.id.value }}\n.",
    "metadata": {
      "source": "https://vuejs.org/guide/essentials/reactivity-fundamentals",
      "title": "Reactivity Fundamentals | Vue.js"
    }
  },
  {
    "page_content": "Plugins\nIntroduction\nPlugins are self-contained code that usually add app-level functionality to Vue. This is how we install a plugin:\njs\nimport { createApp } from 'vue'\nconst app = createApp({})\napp.use(myPlugin, {\n/* optional options */\n})\nA plugin is defined as either an object that exposes an install()\nmethod, or simply a function that acts as the install function itself. The install function receives the app instance along with additional options passed to app.use()\n, if any:\njs\nconst myPlugin = {\ninstall(app, options) {\n// configure the app\n}\n}\nThere is no strictly defined scope for a plugin, but common scenarios where plugins are useful include:\nRegister one or more global components or custom directives with\napp.component()\nandapp.directive()\n.Make a resource injectable throughout the app by calling\napp.provide()\n.Add some global instance properties or methods by attaching them to\napp.config.globalProperties\n.A library that needs to perform some combination of the above (e.g. vue-router).\nWriting a Plugin\nIn order to better understand how to create your own Vue.js plugins, we will create a very simplified version of a plugin that displays i18n\n(short for Internationalization) strings.\nLet's begin by setting up the plugin object. It is recommended to create it in a separate file and export it, as shown below to keep the logic contained and separate.\njs\n// plugins/i18n.js\nexport default {\ninstall: (app, options) => {\n// Plugin code goes here\n}\n}\nWe want to create a translation function. This function will receive a dot-delimited key\nstring, which we will use to look up the translated string in the user-provided options. This is the intended usage in templates:\ntemplate\n<h1>{{ $translate('greetings.hello') }}</h1>\nSince this function should be globally available in all templates, we will make it so by attaching it to app.config.globalProperties\nin our plugin:\njs\n// plugins/i18n.js\nexport default {\ninstall: (app, options) => {\n// inject a globally available $translate() method\napp.config.globalProperties.$translate = (key) => {\n// retrieve a nested property in `options`\n// using `key` as the path\nreturn key.split('.').reduce((o, i) => {\nif (o) return o[i]\n}, options)\n}\n}\n}\nOur $translate\nfunction will take a string such as greetings.hello\n, look inside the user provided configuration and return the translated value.\nThe object containing the translated keys should be passed to the plugin during installation via additional parameters to app.use()\n:\njs\nimport i18nPlugin from './plugins/i18n'\napp.use(i18nPlugin, {\ngreetings: {\nhello: 'Bonjour!'\n}\n})\nNow, our initial expression $translate('greetings.hello')\nwill be replaced by Bonjour!\nat runtime.\nSee also: Augmenting Global Properties\nTIP\nUse global properties scarcely, since it can quickly become confusing if too many global properties injected by different plugins are used throughout an app.\nProvide / Inject with Plugins\nPlugins also allow us to use inject\nto provide a function or attribute to the plugin's users. For example, we can allow the application to have access to the options\nparameter to be able to use the translations object.\njs\n// plugins/i18n.js\nexport default {\ninstall: (app, options) => {\napp.provide('i18n', options)\n}\n}\nPlugin users will now be able to inject the plugin options into their components using the i18n\nkey:\nvue\n<script setup>\nimport { inject } from 'vue'\nconst i18n = inject('i18n')\nconsole.log(i18n.greetings.hello)\n</script>",
    "metadata": {
      "source": "https://vuejs.org/guide/reusability/plugins",
      "title": "Plugins | Vue.js"
    }
  },
  {
    "page_content": "Computed Properties\nBasic Example\nIn-template expressions are very convenient, but they are meant for simple operations. Putting too much logic in your templates can make them bloated and hard to maintain. For example, if we have an object with a nested array:\njs\nconst author = reactive({\nname: 'John Doe',\nbooks: [\n'Vue 2 - Advanced Guide',\n'Vue 3 - Basic Guide',\n'Vue 4 - The Mystery'\n]\n})\nAnd we want to display different messages depending on if author\nalready has some books or not:\ntemplate\n<p>Has published books:</p>\n<span>{{ author.books.length > 0 ? 'Yes' : 'No' }}</span>\nAt this point, the template is getting a bit cluttered. We have to look at it for a second before realizing that it performs a calculation depending on author.books\n. More importantly, we probably don't want to repeat ourselves if we need to include this calculation in the template more than once.\nThat's why for complex logic that includes reactive data, it is recommended to use a computed property. Here's the same example, refactored:\nvue\n<script setup>\nimport { reactive, computed } from 'vue'\nconst author = reactive({\nname: 'John Doe',\nbooks: [\n'Vue 2 - Advanced Guide',\n'Vue 3 - Basic Guide',\n'Vue 4 - The Mystery'\n]\n})\n// a computed ref\nconst publishedBooksMessage = computed(() => {\nreturn author.books.length > 0 ? 'Yes' : 'No'\n})\n</script>\n<template>\n<p>Has published books:</p>\n<span>{{ publishedBooksMessage }}</span>\n</template>\nHere we have declared a computed property publishedBooksMessage\n. The computed()\nfunction expects to be passed a getter function, and the returned value is a computed ref. Similar to normal refs, you can access the computed result as publishedBooksMessage.value\n. Computed refs are also auto-unwrapped in templates so you can reference them without .value\nin template expressions.\nA computed property automatically tracks its reactive dependencies. Vue is aware that the computation of publishedBooksMessage\ndepends on author.books\n, so it will update any bindings that depend on publishedBooksMessage\nwhen author.books\nchanges.\nSee also: Typing Computed\nComputed Caching vs. Methods\nYou may have noticed we can achieve the same result by invoking a method in the expression:\ntemplate\n<p>{{ calculateBooksMessage() }}</p>\njs\n// in component\nfunction calculateBooksMessage() {\nreturn author.books.length > 0 ? 'Yes' : 'No'\n}\nInstead of a computed property, we can define the same function as a method. For the end result, the two approaches are indeed exactly the same. However, the difference is that computed properties are cached based on their reactive dependencies. A computed property will only re-evaluate when some of its reactive dependencies have changed. This means as long as author.books\nhas not changed, multiple access to publishedBooksMessage\nwill immediately return the previously computed result without having to run the getter function again.\nThis also means the following computed property will never update, because Date.now()\nis not a reactive dependency:\njs\nconst now = computed(() => Date.now())\nIn comparison, a method invocation will always run the function whenever a re-render happens.\nWhy do we need caching? Imagine we have an expensive computed property list\n, which requires looping through a huge array and doing a lot of computations. Then we may have other computed properties that in turn depend on list\n. Without caching, we would be executing list\n’s getter many more times than necessary! In cases where you do not want caching, use a method call instead.\nWritable Computed\nComputed properties are by default getter-only. If you attempt to assign a new value to a computed property, you will receive a runtime warning. In the rare cases where you need a \"writable\" computed property, you can create one by providing both a getter and a setter:\nvue\n<script setup>\nimport { ref, computed } from 'vue'\nconst firstName = ref('John')\nconst lastName = ref('Doe')\nconst fullName = computed({\n// getter\nget() {\nreturn firstName.value + ' ' + lastName.value\n},\n// setter\nset(newValue) {\n// Note: we are using destructuring assignment syntax here.\n[firstName.value, lastName.value] = newValue.split(' ')\n}\n})\n</script>\nNow when you run fullName.value = 'John Doe'\n, the setter will be invoked and firstName\nand lastName\nwill be updated accordingly.\nBest Practices\nGetters should be side-effect free\nIt is important to remember that computed getter functions should only perform pure computation and be free of side effects. For example, don't mutate other state, make async requests, or mutate the DOM inside a computed getter! Think of a computed property as declaratively describing how to derive a value based on other values - its only responsibility should be computing and returning that value. Later in the guide we will discuss how we can perform side effects in reaction to state changes with watchers.\nAvoid mutating computed value\nThe returned value from a computed property is derived state. Think of it as a temporary snapshot - every time the source state changes, a new snapshot is created. It does not make sense to mutate a snapshot, so a computed return value should be treated as read-only and never be mutated - instead, update the source state it depends on to trigger new computations.",
    "metadata": {
      "source": "https://vuejs.org/guide/essentials/computed",
      "title": "Computed Properties | Vue.js"
    }
  }
]